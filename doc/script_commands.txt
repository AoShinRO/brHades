//===== Documentação brHades=================================
//= Comandos de script brHades
//===== Por:====================================================
//= Equipe de desenvolvimento brHades
//===== Última atualização:==========================================
//= 20220308
//===== Descrição:=========================================
//= Um manual de referência para a linguagem de script brHades.
//= Os comandos são classificados de acordo com sua funcionalidade.
//============================================== ===========

Este documento é um manual de referência para todos os comandos e funções de script
disponível em brHades. Não é um tutorial simples. Quando as pessoas dizem para você
"Leia a porra do manual", é o que eles querem dizer.

Este não é um lugar para lhe ensinar programação básica. Este documento não vai lhe ensinar
você programação básica por si só. É mais uma referência para aqueles que têm em
pelo menos uma vaga ideia do que querem fazer e querem saber quais ferramentas têm
disponível para fazê-lo. Tentamos mantê-lo o mais simples possível, mas se você
não entendo, obter um livro claro sobre programação em geral ajudará
melhor do que ficar gritando por ajuda no fórum.

Um pouco de aprendizado nunca fez a cabeça de ninguém explodir.

//PS: em processo de tradução, consulte também a versão en

Estrutura
---------

Os comandos de script são listados sem nenhuma ordem específica, mas são agrupados por
função relativa.

*Nome do comando e parâmetros (se houver).

Texto descritivo

	Um pequeno exemplo, se possível. Geralmente estará incompleto, está lá apenas para
	dar uma ideia de como funciona na prática.

Para encontrar um comando específico, use Ctrl+F (ou qualquer tecla que chame uma pesquisa)
função em qualquer coisa que você esteja lendo isso) coloque um asterisco (*) seguido do comando
nome, e ele deverá encontrar a descrição do comando para você.

Se você perceber que algo está faltando, por favor nos avise!

Sintaxe
------

Ao longo deste documento, sempre que um comando desejar um argumento, ele será fornecido em
<colchetes angulares>. Isso não significa que você deve digitar os colchetes angulares. Se um
argumento de um comando é opcional, é dado entre {colchetes}. Você tem
sem dúvida já vi essa convenção em algum lugar. Se um comando pode opcionalmente assumir
um número não especificado de argumentos, você verá uma lista como esta:

comando <argumento>{,<argumento>...<argumento>}

Isso ainda significa que eles precisarão ser separados por vírgulas.

Quando um comando deseja uma string, ela será fornecida entre "aspas", se for um número,
será dado sem eles. Normalmente, você pode colocar uma expressão, como um monte
de funções ou operadores que retornam um valor, em (colchetes) em vez da maioria
números. Os colchetes nem sempre serão necessários, mas geralmente são uma boa opção
ideia.

Onde quer que você se refira a um nome de mapa, será sempre 'nome do mapa' (o sufixo .gat está obsoleto).


Estrutura de carregamento do script
------------------------

Os scripts são carregados pelo servidor de mapas conforme referenciado em 'conf/map_athena.conf'
arquivo de configuração, mas na configuração padrão, ele não carrega nenhum script
arquivos em si. Em vez disso, ele carrega o arquivo 'npc/(pre-)re/scripts_main.conf' que por si só
contém referências a outros arquivos. Os scripts reais são carregados do txt
arquivos, que estão vinculados assim:

npc: <caminho para um nome de arquivo>

Qualquer linha como esta, invocada, em última análise, por 'map_athena.conf' irá carregar o
script contido neste arquivo, que tornará o script disponível. Nenhum arquivo
será carregado duas vezes para evitar possíveis erros.

Outra opção de arquivo de configuração relevante é:

delnpc: <caminho para um nome de arquivo>

Isso descarregará um nome de arquivo de script especificado da memória, que, embora
aparentemente inútil, às vezes pode ser necessário.

Sempre que '//' for encontrado em uma linha durante a leitura, tudo além disso em
essa linha é considerada um comentário e é ignorada. Isso funciona onde quer que você
coloque-o.

// Esta linha será ignorada ao processar o script.

Comentários em bloco também podem ser usados, onde você pode colocar /* e */ entre qualquer texto que você
desejo que brHades ignore.

Exemplo:
/* Este texto,
* não importa qual nova linha você comece
* é ignorado, até o seguinte
* símbolo é encontrado: */

Os asteriscos (*) antes de cada linha são uma preferência pessoal e não são obrigatórios.

Ao carregar todos os arquivos, o servidor executará todos os comandos de nível superior
neles. Nenhuma variável existe ainda neste ponto, nenhum comando pode ser chamado além
do que aqueles fornecidos nesta seção. Esses comandos configuram a estrutura básica - criar
Objetos NPC, objetos de monstros de geração, sinalizadores de mapa de configuração, etc. Nenhum código é realmente
executado neste ponto. Os comandos de nível superior são bastante confusos, pois
eles não são estruturados como você esperaria (primeiro o nome do comando), mas sim,
normalmente começam com um nome de mapa.

O que é mais confuso sobre os comandos de nível superior é que a maioria deles usa um
símbolo de tabulação para dividir seus argumentos.

Para evitar problemas e confusões, os símbolos de tabulação são escritos como '%TAB%'
ao longo deste documento, embora isso torne o texto um pouco menos legível.
Usar um símbolo invisível para denotar argumentos é uma das coisas ruins sobre
esta linguagem.

Aqui está uma lista de comandos de nível superior válidos:

** Defina uma bandeira de mapa:

<nome do mapa>%TAB%mapflag%TAB%<flag>

Isso irá, ao carregar, set um sinalizador de mapa especificado em um mapa que você gosta. Estes são
normalmente em arquivos dentro de 'npc/mapflag' e são carregados primeiro, então quando o
o servidor está ativo, todos os mapas têm as bandeiras que deveriam ter. As bandeiras do mapa determinam
o comportamento do mapa em várias situações. Para mais detalhes, veja 'setmapflag'
e 'doc/mapflags.txt'.

** Crie um spawn de monstro permanente:

<nome do mapa>{,<x>{,<y>{,<xs>{,<ys>}}}}%TAB%monstro%TAB%<nome do monstro>{,<nível do monstro>}%TAB%<id do mob>,<quantidade>{,<atraso1>{,<atraso2>{,<evento>{,<tamanho do mob>{,<ia do mob>}}}}}

O nome do mapa é o nome do mapa em que os monstros irão aparecer. x,y são os
coordenadas onde o mob deve aparecer. Colocando zeros em vez destes
as coordenadas gerarão os monstros aleatoriamente.

Se as coordenadas forem diferentes de zero e xs e ys forem maiores que 1, cada monstro irá
desovam em um raio ao redor de x,y. No início do servidor, cada monstro será atribuído
sua própria célula central adicionando ou subtraindo até (xs-1),(ys-1) do dado
coordenadas x,y. Cada vez que um monstro reaparece, ele irá aparecer em um raio ao redor
sua célula central pessoal adicionando ou subtraindo até (xs-1),(ys-1) novamente.
Isso resulta em uma área total possível de spawn sobre todos os monstros da linha de spawn
de (xs,ys)*4-3, mas com um forte viés em direção ao centro dessa área:
2,2 - 5x5
3,3 - 9x9
4,4 - 13x13
5,5 - 17x17
etc.

Observe que esta é apenas a zona de spawn inicial, pois os mobs andam aleatoriamente, eles são livres
para se afastar de sua região de desova especificada.
Você pode desabilitar a escolha de uma célula central aleatória para cada monstro no
configuração de batalha. (Veja /conf/battle/monster.conf::randomize_center_cell.)

O nome do monstro é o nome que os monstros terão na tela e não tem relação
qualquer que seja o nome deles em qualquer outro lugar. É o ID da máfia que conta, que
identifica o registro do monstro no banco de dados de monstros 'mob_db.yml'. Se o nome do mob
é dado como "--ja--", o campo 'nome japonês' do banco de dados do monstro é
usado, (que, em brHades, na verdade contém um nome em inglês) se for "--en--",
é o 'nome em inglês' do banco de dados de monstros (que contém uma letra maiúscula
nome usado para invocar o monstro com um comando do Mestre).

Você pode especificar um nível personalizado para usar para o mob diferente daquele de
o banco de dados juntando o nível após o nome com uma vírgula. por exemplo:
O nome "Poring,50" gerará um monstro chamado Poring e nível 50.

Quantidade é a quantidade de monstros que serão gerados quando este comando for executado.
executado, ele é afetado pelas taxas de spawn em 'battle_athena.conf'.

Delay1 e delay2 controlam atrasos no respawn de monstros - o primeiro é fixo
tempo de respawn base, e o segundo é a variação aleatória sobre o tempo base.
Ambos os valores são dados em milissegundos (1000 = 1 segundo).
Observe que o servidor também impõe um atraso mínimo de respawn de 1 segundo (consulte
/conf/battle/monster.conf::mob_respawn_time).

Evento é um evento de script a ser executado quando o mob é morto. O evento deve
estar no formato "NPCName::OnEventName" para executar, e o rótulo do nome do evento
deve começar com "On". Como em todos os eventos, se o NPC for um NPC on-touch, o
o jogador que aciona o script deve estar dentro do alcance do 'gatilho' para que o evento ocorra
trabalhar.

Há dois campos opcionais para tamanho do monstro e IA.
Os inimigos naturais dos monstros de IA são monstros normais.

<tamanho do grupo> pode ser:
	Size_Small	(0)
	Size_Medium	(1)
	Size_Large	(2)

<mob ai> pode ser:
	AI_NONE (0) (padrão)
	AI_ATTACK (1) (ataque/amigável)
	AI_SPHERE (2) (habilidade de alquimista)
	AI_FLORA (3) (habilidade de alquimista)
	AI_ZANZOU (4) (habilidade Kagerou/Oboro)
	AI_LEGION (5) (habilidade Sera)
	AI_FAW (6) (Habilidade mecânica)
	AI_WAVEMODE (7) Monstros normais ignorarão ataques de monstros AI_WAVEMODE

Alternativamente, um monstro gerado usando 'boss_monster' em vez de 'monster' é capaz
para ser detectado no mapa com o status SC_BOSSMAPINFO (usado pelo Convex Mirror).
Um spawn de monstro chefe com coordenadas fixas sempre irá aparecer no local fornecido
coordenadas, mesmo que estejam bloqueadas (por exemplo, por Icewall).

** Nomes de NPCs

/!\ AVISO: isso se aplica a warps, NPCs, duplicatas e lojas /!\

Os nomes dos NPCs são meio especiais e são formatados desta forma:

<Nome de exibição>{::<Nome exclusivo>}

Todos os NPCs precisam ter um nome único que seja usado para fins de identificação.
Quando você tiver que identificar um NPC pelo seu nome, você deve usar <Nome único>.
Se <Nome exclusivo> não for fornecido, use <Nome de exibição>.

O cliente tem um recurso especial ao exibir nomes:
se o nome de exibição contiver um caractere '#', ele ocultará essa parte do nome.
ex: se o seu NPC for chamado de 'Hunter#hunter1', ele será exibido como 'Hunter'

<Nome de exibição> deve ter no máximo 24 caracteres.
<Nome exclusivo> deve ter no máximo 24 caracteres.

** Defina um ponto de distorção

<de nome do mapa>,<deX>,<deY>,<de frente>%TAB%warp%TAB%<nome do warp>%TAB%<spanx>,<spany>,<para nome do mapa>,<paraX>,<paraY>
<de nome do mapa>,<deX>,<deY>,<de frente>%TAB%warp2%TAB%<nome do warp>%TAB%<spanx>,<spany>,<para nome do mapa>,<paraX>,<paraY>
<de nome do mapa>,<deX>,<deY>,<voltado para>%TAB%warp(<estado>)%TAB%<nome do warp>%TAB%<spanx>,<spany>,<para nome do mapa>,<paraX>,<paraY>
<de nome do mapa>,<deX>,<deY>,<voltado para>%TAB%warp2(<estado>)%TAB%<nome do warp>%TAB%<spanx>,<spany>,<para nome do mapa>,<paraX>,<paraY>

Isso setá um NPC de teletransporte que teletransportará um jogador entre os mapas e, embora a maioria
argumentos disso são óbvios, alguns merecem menção especial.

SpanX e SpanY tornarão a distorção sensível a um personagem que não pisou
diretamente nele, mas entrou em uma zona que está centrada na dobra de
coordenadas e é SpanX em cada direção através do eixo X e SpanY em cada
direção através do eixo Y.

Os objetos NPC Warp também têm um nome, porque você pode usá-lo para se referir a eles mais tarde
com 'enablenpc'/'disablenpc'

O enfrentamento de um objeto warp é irrelevante, ele não é usado no código e todos
os scripts atuais têm um zero ali.

Diferentemente de 'warp', 'warp2' também será acionado por um jogador oculto.

O estado básico do warp pode ser definido em <state>. Apenas um estado pode ser definido por vez.
Warps duplicados (incluindo warps de instância) herdam o <estado> do warp original.

<estado> válidos são:
CLOAKED Torna o warp especificado camuflado.
HIDDEN Torna o warp especificado oculto.
DISABLED Desabilita o warp especificado.

** Defina um objeto NPC.

<nome do mapa>,<x>,<y>,<voltado para>%TAB%script%TAB%<Nome do NPC>%TAB%<id do sprite>,{<código>}
<nome do mapa>,<x>,<y>,<voltado para>%TAB%script%TAB%<Nome do NPC>%TAB%<id do sprite>,<gatilhoX>,<gatilhoY>,{<código>}
<nome do mapa>,<x>,<y>,<voltado>%TAB%script(<estado>)%TAB%<Nome do NPC>%TAB%<id do sprite>,{<código>}
<nome do mapa>,<x>,<y>,<voltado>%TAB%script(<estado>)%TAB%<Nome do NPC>%TAB%<id do sprite>,<gatilhoX>,<gatilhoY>,{<código>}

Isso colocará um objeto NPC em um mapa especificado no local especificado e
é um comando de nível superior que você usará mais em seus scripts personalizados. Os NPCs
são acionados ao clicar neles e/ou ao caminhar em sua área de gatilho, se
definido, veja abaixo.

A direção em que o sprite do NPC ficará voltado é a direção em que ele ficará. Nem todos os sprites do NPC têm
imagens diferentes dependendo da direção de onde você olha, então para alguns voltados
não terá sentido. Os revestimentos são contados no sentido anti-horário em incrementos de 45
graus, onde 0 significa voltado para o topo do mapa. (Então, para virar o sprite
na parte inferior do mapa, você usa a posição 4, e para fazer com que pareça sudeste
está voltado para 5.)

<estado> funciona como o <estado> de distorção definido acima, mas para NPCs.

Sprite ID é o número do sprite ou constante usada para exibir este NPC específico.
Você também pode usar o ID de um monstro para exibir um sprite de monstro para este NPC.
Também é possível usar um sprite de trabalho, mas primeiro você deve defini-lo como um
sprite monstro em 'mob_avail.yml', uma descrição completa sobre como fazer isso não está disponível
no escopo deste manual.
Um Sprite ID '-1' tornará o NPC invisível (e não clicável).
Um Sprite ID '111' criará um NPC que não tem um sprite, mas ainda é
clicável, o que é útil se você quiser fazer um objeto clicável do 3D
terreno.

TriggerX e triggerY, se fornecidos, setão uma área, centralizada no NPC e
abrangendo células triggerX em todas as direções em X e triggerY em todas
direção através de Y. Entrar naquela área irá acionar o NPC. Se não
O rótulo especial 'OnTouch:' está presente no código NPC, a execução começará
do início do script, caso contrário, ele começará em 'OnTouch:'
rótulo. Monstros também podem acionar o NPC, embora o rótulo 'OnTouchNPC:' seja
usado neste caso.

A parte do código é o código do script que será executado sempre que o NPC estiver
acionado. Pode conter comandos e chamadas de função, cujas descrições
compor a maior parte deste documento. Tem que estar entre chaves, ao contrário de outros lugares
onde usamos chaves, elas NÃO significam um parâmetro opcional.

Exemplo de como <estado> funciona:

// Defina um NPC camuflado:
lighthalzen,306.267,5 script Skia#ep162_04 4_EP16_SKIA,{
	//...
	end;

OnInit:
	cloakonnpc();
	end;
}

// Outra maneira de set um NPC camuflado usando <estado> :
lighthalzen,306.267,5 script(CLOAKED) Skia#ep162_04 4_EP16_SKIA,{
	//...
	end;
}

** Defina um objeto NPC 'flutuante'.

-%TAB%script%TAB%<Nome do NPC>%TAB%-1,{<código>}

Isso setá um objeto NPC não acionável por meios normais. Isso seria
normalmente significa que é inútil, pois não pode fazer nada, mas existem
exceções, principalmente relacionadas à execução de scripts em um horário específico, que é o que
esses objetos NPC flutuantes são para. Mais sobre isso abaixo.

** Defina um NPC de loja/loja de dinheiro/loja de itens/loja de pontos.

-%TAB%shop%TAB%<Nome do NPC>%TAB%<id do sprite>{,desconto},<itemid>:<preço>{,<itemid>:<preço>...}
<nome do mapa>,<x>,<y>,<de frente>%TAB%shop%TAB%<Nome do NPC>%TAB%<id do sprite>{,desconto},<itemid>:<preço>{,<itemid>:<preço>...}

-%TAB%cashshop%TAB%<Nome do NPC>%TAB%<id do sprite>,<itemid>:<preço>{,<itemid>:<preço>...}
<nome do mapa>,<x>,<y>,<voltado para>%TAB%cashshop%TAB%<Nome do NPC>%TAB%<id do sprite>,<itemid>:<preço>{,<itemid>:<preço>...}

-%TAB%itemshop%TAB%<Nome do NPC>%TAB%<id do sprite>,<costitemid>{:<desconto>},<itemid>:<preço>{,<itemid>:<preço>...}
<nome do mapa>,<x>,<y>,<voltado para>%TAB%itemshop%TAB%<Nome do NPC>%TAB%<id do sprite>,<costitemid>{:<desconto>},<itemid>:<preço>{,<itemid>:<preço>...}

-%TAB%pointshop%TAB%<Nome do NPC>%TAB%<id do sprite>,<variável de custo>{:<desconto>},<itemid>:<preço>{,<itemid>:<preço>...}
<nome do mapa>,<x>,<y>,<voltado para>%TAB%pointshop%TAB%<Nome do NPC>%TAB%<id do sprite>,<variável de custo>{:<desconto>},<itemid>:<preço>{,<itemid>:<preço>...}

<nome do mapa>,<x>,<y>,<voltado para>%TAB%marketshop%TAB%<Nome do NPC>%TAB%<id do sprite>,<itemid>:<preço>:<estoque>{,<itemid>:<preço>:<estoque>...}

Nota: Além disso, as lojas de troca podem ser definidas em npc/barters.yml

Isso setá um NPC de loja, que, quando acionado (o que só pode ser feito por
clicando) fará com que uma vitrine apareça. Nenhum código é executado na loja
NPCs e você não pode alterar os preços de outra forma a não ser editando o script
em si.

O Item ID é o número do item no banco de dados 'db/item_db.yml'. Se o preço for definido
para -1, o 'preço de compra' fornecido no banco de dados do item será usado. Caso contrário, o
o preço que você deu será usado para este item, que é como você cria diferentes
preços de itens em diferentes lojas.

Opcionalmente, você pode especificar a opção de desconto e defini-la como "sim" ou "não" para habilitar ou desabilitar o desconto.

Existem outros tipos de lojas disponíveis:
cashshop - use "cashshop" no lugar de "shop" para usar a interface Cash Shop, permitindo
você pode comprar itens com pontos especiais que são armazenados como variáveis ​​de conta
chamados #CASHPOINTS e #KAFRAPOINTS. Este tipo de loja não permitirá que você venda
itens nele, faça apenas compras. O layout usado para set itens de venda ainda conta, e
"<preço>" refere-se a quantos pontos serão gastos na compra deles.

"itemshop" e "pointshop" usam a interface da Loja, permitindo que você compre itens com um
item ou pontos especiais de uma variável. 'pointshop' suporta apenas variáveis ​​de caracteres permanentes,
variáveis ​​de caracteres temporárias, variáveis ​​de conta locais permanentes ou variáveis ​​de conta globais permanentes
variáveis. Essas variáveis ​​devem ser do tipo inteiro, não string. O sinalizador 'desconto' é um
valor opcional que faz com que o preço naquela loja seja afetado pela habilidade de desconto.

"marketshop" pode ter uma quantidade limitada de um item em estoque.
Use -1 no campo de estoque para ter estoque ilimitado em um mercado.

** Defina uma duplicata de warp/shop/cashshop/itemshop/pointshop/NPC.

warp/warp2: <nome do mapa>,<x>,<y>,<voltado>%TAB%duplicate(<rótulo>)%TAB%<Nome do NPC>%TAB%<spanx>,<spany>
loja/cashshop/itemshop/pointshop/npc: -%TAB%duplicate(<label>)%TAB%<Nome do NPC>%TAB%<id do sprite>
loja/loja de dinheiro/loja de itens/loja de pontos/npc: <nome do mapa>,<x>,<y>,<de frente>%TAB%duplicate(<rótulo>)%TAB%<Nome do NPC>%TAB%<id do sprite>
npc: -%TAB%duplicate(<rótulo>)%TAB%<Nome do NPC>%TAB%<id do sprite>,<gatilhoX>,<gatilhoY>
npc: <nome do mapa>,<x>,<y>,<voltado>%TAB%duplicate(<rótulo>)%TAB%<Nome do NPC>%TAB%<id do sprite>,<gatilhoX>,<gatilhoY>

Isso duplicará um warp/shop/cashshop/itemshop/pointshop/NPC referenciado por 'label'.
Duplicatas de distorção herdam o local de destino.
Duplicatas de loja/loja de dinheiro/loja de itens/loja de pontos herdam a lista de itens.
Duplicatas de NPCs herdam o código do script.
O resto (nome, localização, face, ID do sprite, extensão/área de disparo)
é obtido a partir da definição da duplicata (não herdada).

** Defina um objeto de função

function%TAB%script%TAB%<nome da função>%TAB%{<código>}

Isso setá um objeto de função, que pode ser chamado com o comando 'callfunc' (veja
abaixo). Este objeto será carregado em cada servidor de mapa separadamente, para que você possa obter
de qualquer lugar. Não é possível chamar o código neste objeto por
qualquer coisa diferente do comando de script 'callfunc'.

A parte do código é o código do script que será executado sempre que a função for
chamado com 'callfunc'. Tem que estar entre chaves, diferente de outros lugares onde
usamos chaves, elas NÃO significam um parâmetro opcional.

Uma vez que um objeto é definido que tem um campo 'código' para sua definição, ele
contém comandos de script que podem ser acionados e executados.

~ GID? RID? ~

O que é um RID e por que você precisa saber
-----------------------------------------

A maioria dos comandos e funções de script desejará solicitar dados sobre um
personagem, armazenar variáveis ​​referenciadas a esse personagem, enviar coisas para o
cliente conectado a esse personagem específico. Sempre que um script é invocado por um
personagem, é passado um chamado RID - este é o número de identificação da conta de um
personagem que fez com que o código fosse executado ao clicar nele, entrando em seu
Zona OnTouch, ou outra.

Se você estiver escrevendo apenas NPCs comuns, não precisa se preocupar com isso. No entanto,
se você usar funções, se você usar temporizadores, se você usar script baseado em relógio
ativação, você precisa estar ciente de todos os casos em que uma execução de script pode ser
acionado sem um RID anexado. Isso fará com que muitos comandos e funções
inutilizável, pois eles querem dados de um personagem específico, querem enviar coisas para
um cliente específico, deseja armazenar variáveis ​​específicas para aquele personagem, e eles
não saberia em qual personagem trabalhar se não houvesse RID.

A menos que você use 'attachrid' para anexar explicitamente um caractere ao script primeiro.

Sempre que dizemos "invocar personagem", queremos dizer "o personagem que está LIVRE é
anexado ao script em execução. A função de script "playerattached" pode ser
usado para verificar qual é o player atualmente anexado ao script (ele irá
retornar 0 se não houver nenhum jogador anexado ou se o jogador anexado não estiver mais
está conectado ao servidor de mapas).

Mas e quanto ao GID?
-------------------

GID significa Game ID de algo, pode ser o GID obtido
através de mobspawn (comandos de controle de mob) ou do ID da conta de um personagem.
Outra maneira seria clicar com o botão direito em um mob, NPC ou personagem como personagem do GM
para visualizar o GID.

Veja também 'getpetinfo', 'getmercinfo', 'gethominfo' e 'geteleminfo'.

Isso é usado principalmente para a nova versão de habilidade e os comandos de controle de multidão
implementado.

Scripts de itens e animais de estimação
--------------------

Cada item no banco de dados de itens tem três campos especiais - Script, EquipScript
e UnEquipScript. O primeiro é o código de script executado toda vez que um personagem equipa o item,
com o RID do personagem que o equipa. Toda vez que eles desequipam um item, todos
os bônus temporários dados pelos comandos de script são limpos e todos os scripts
são executados mais uma vez para reconstruí-los. Isso também acontece em vários outros
situações (como no login), mas a lista completa é atualmente desconhecida.

EquipScript é um pedaço de código de script executado sempre que o item é usado por um personagem
clicando duas vezes nele. O UnEquipScript é executado sempre que o
o equipamento é desequipado por um personagem

Nem todos os comandos de script funcionam corretamente nos scripts de itens. Onde os comandos e
funções são conhecidas por serem destinadas especificamente para uso em scripts de itens, elas são
descrito como tal.

Cada animal de estimação no banco de dados de animais de estimação tem um campo PetScript, que determina o animal de estimação
comportamento. Ele é invocado sempre que um pet do tipo especificado é gerado.
(eclodido de um ovo ou carregado do servidor de char quando um personagem que tinha
que o animal de estimação que os segue conecta) Isso pode ocorrer em algumas outras situações como
bem. Não espere nada além de comandos definitivamente marcados como utilizáveis ​​em
scripts de estimação para funcionarem lá de forma confiável.

Números
-------

Além dos números decimais comuns, que não são nada especiais (embora
não espere usar frações, pois TODOS os números são inteiros nesta linguagem),
o mecanismo de script também lida com números hexadecimais, que de outra forma seriam
idêntico. Escrever um número como '0x<dígitos hexadecimais>' fará com que ele seja reconhecido como um
valor hexadecimal. Observe que 0x10 é igual a 16. Observe também que se você tentar
para 'mes 0x10' ele imprimirá '16'.

Os valores numéricos não podem exceder os limites de uma variável inteira: Qualquer número
maior que INT64_MAX (9223372036854775807) ou menor que INT64_MIN
(-9223372036854775808) será limitado a esses valores e causará um aviso
a ser relatado.

Variáveis
---------

A essência de toda linguagem de programação são as variáveis ​​- lugares onde você armazena
dados.

Na linguagem de script brHades, nomes de variáveis ​​não diferenciam maiúsculas de minúsculas.

As variáveis ​​são divididas e identificadas exclusivamente pela combinação de:
prefixo - determina o escopo e a extensão (ou tempo de vida) da variável
nome - um identificador que consiste em '_' e caracteres alfanuméricos
postfix - determina o tipo da variável: inteiro ou string

O escopo pode ser:
global - global para todos os servidores
local - local para o servidor
conta - anexada à conta do personagem identificado pelo RID
personagem - anexado ao personagem identificado por RID
npc - anexado ao NPC
escopo - anexado ao escopo da instância

A extensão pode ser:
permanentes - Eles ainda existem quando o servidor é reiniciado.
temporários - Eles deixam de existir quando o servidor é reiniciado.

Prefixo: escopo e extensão
nada - Uma variável permanente anexada ao caractere, a variável padrão
           tipo. Eles são armazenados pelo char-server no `char_reg_num` e
           `char_reg_str`.
"@" - Uma variável temporária anexada ao caractere.
           As versões SVN anteriores à revisão 2094 e à versão RC5 também tratarão
           'l' como um prefixo de variável temporária, portanto, tome cuidado ao ter variável
           nomes que começam com 'l' se você quiser compatibilidade total com versões anteriores.
"$" - Uma variável global permanente.
           Eles são armazenados pelo map-server na tabela de banco de dados `mapreg`.
"$@" - Uma variável temporária global.
           Isso é importante para scripts que são chamados sem RID
           anexado, ou seja, não acionado por um objeto de caractere específico.
"." - Uma variável NPC.
           Eles existem no NPC e desaparecem quando o servidor reinicia ou o
           O NPC é recarregado. Pode ser acessado de dentro do NPC ou chamando
           'getvariableofnpc'. Objetos de função também podem ter .variables que
           são acessíveis de dentro da função, no entanto 'getvariableofnpc'
           NÃO funciona em objetos de função.
".@" - Uma variável de escopo.
           Eles são exclusivos para a instância e escopo. Cada instância tem seu
           próprio escopo que termina quando o script termina. Chamar uma função com
           callsub/callfunc inicia um novo escopo, retornando da função
           termina. Quando um escopo termina, suas variáveis ​​são convertidas em valores
           ('return .@var;' retorna um valor, não uma referência).
"'" - Uma variável de instância.
           Eles são usados ​​com o sistema de instanciação e são exclusivos para cada
           tipo de instância. Pode ser acessado de dentro da instância ou chamando
           'obterinstancevar'.
"#" - Uma variável de conta local permanente.
           Eles são armazenados pelo char-server na tabela `acc_reg_num` e
           `acc_reg_str`.
"##" - Uma variável de conta global permanente armazenada pelo servidor de login.
           Eles são armazenados na tabela `global_acc_reg_num` e
		   `reg_str_acc_global`.
           A única diferença que você notará em relação às variáveis ​​# normais é quando
           você tem vários char-servers conectados ao mesmo servidor de login.
           As variáveis ​​# são exclusivas para cada char-server, enquanto as variáveis ​​##
           são compartilhados por todos esses char-servers.

Posfix: inteiro ou string
nada - variável inteira, pode armazenar números positivos e negativos, mas apenas
          números inteiros (então não espere fazer nenhuma matemática fracionária)
'$' - variável string, pode armazenar texto

Exemplos:
name - variável inteira de caractere permanente
name$ - variável de cadeia de caracteres permanente
@name - variável temporária de caractere inteiro
@name$ - variável temporária de sequência de caracteres
$name - variável global inteira permanente
$name$ - variável de string global permanente
$@name - variável inteira global temporária
$@name$ - variável de string global temporária
.name - variável inteira NPC
.name$ - variável de string NPC
.@name - variável inteira de escopo
.@name$ - variável de string de escopo
'nome - variável inteira de instância
'name$ - variável de string de instância
#name - variável inteira de conta local permanente
#name$ - variável de string de conta local permanente
##name - variável inteira de conta global permanente
##name$ - variável de string de conta global permanente

Se uma variável nunca foi definida, ela é considerada igual a zero para inteiros
variáveis ​​ou uma string vazia ("", nada entre aspas) para string
variáveis. Depois de defini-lo, a variável é tão boa quanto esquecida
para sempre, e nenhum vestígio permanece dele, mesmo que tenha sido armazenado com caráter ou
dados da conta.

Algumas variáveis ​​são especiais, ou seja, já estão definidas para você pelo
mecanismo de script. Você pode ver a lista completa em 'src/map/script_constants.hpp', que
é um arquivo que você deve ler, pois ele também permite que você substitua muitos números
argumentos para muitos comandos com texto mais fácil de ler. As variáveis ​​especiais mais
comumente usadas são todas as variáveis ​​permanentes baseadas em caracteres:

Zeny - Quantidade de Zeny.
Hp - Quantidade atual de pontos de vida.
MaxHp - Quantidade máxima de pontos de vida.
Sp - Pontos de magia atuais.
MaxSp - Quantidade máxima de pontos de magia.
StatusPoint - Quantidade de pontos de status restantes.
SkillPoint - Quantidade de pontos de habilidade restantes.
BaseLevel - Nível base do personagem.
JobLevel - Nível de trabalho do personagem.
BaseExp - Quantidade de pontos de experiência base.
JobExp - Quantidade de pontos de experiência de trabalho.
NextBaseExp - Quantidade de pontos de experiência base necessários para atingir o próximo nível.
NextJobExp - Quantidade de pontos de experiência de trabalho necessários para atingir o próximo nível.
Weight - Quantidade de peso que o personagem carrega atualmente.
MaxWeight - Peso máximo que o personagem pode carregar.
Sex - 0 se feminino, 1 se masculino.
Class - Função do personagem.
Upper - 0 se o personagem for de classe normal, 1 se avançado, 2 se bebê.
BaseClass - O trabalho 'normal' 1-1 do personagem, independentemente do valor Upper.
              Por exemplo, isso retornará Job_Acolyte para Acolyte, Priest/Monk,
              Sumo Sacerdote/Campeão e Arcebispo/Sura. Se o personagem não tiver
              atingiu uma classe 1-1, retornará Job_Novice.
BaseJob - O trabalho "normal" do personagem, independentemente do valor Upper.
              Por exemplo, isso retornará Job_Acolyte para Acolyte,
              Bebê Acólito e Alto Acólito.
Karma - O karma do personagem. O sistema de karma não é totalmente funcional, mas
              isso não significa que não funcione. Não testado.
Manner - A classificação de maneira do personagem. Torna-se negativo se o jogador
              profere palavras proibidas através do uso de 'manner.txt' do lado do cliente
              arquivo.
Ap - Quantidade atual de pontos de atividade.
MaxAp - Quantidade máxima de pontos de atividade.

Embora elas se comportem como variáveis, nem sempre espere apenas defini-las - é
não tenho certeza se isso funcionará para todos eles. Sempre que houver um comando
ou uma função para set algo, geralmente é preferível usar isso. O
uma exceção notável é a Zeny, que você pode e frequentemente irá abordar diretamente -
configurá-lo fará com que o personagem possua esse número de Zeny.
Se você tentar set Zeny para um número negativo, o script será encerrado com um erro.

Algumas constantes de origem-fim também podem ser acessadas em scripts. Esta lista está localizada em
'src/map/script_constants.hpp', que contém constantes como definições de servidor e opções de status:

	PACKETVER, MAX_LEVEL, MAX_STORAGE, MAX_INVENTORY, MAX_CART, MAX_ZENY, MAX_PARTY,
	MAX_GUILD, MAX_GUILDLEVEL, MAX_GUILD_STORAGE, MAX_BG_MEMBERS, MAX_CHAT_USERS,
	VIP_SCRIPT, MIN_STORAGE

	Option_Nothing, Option_Sight, Option_Hide, Option_Cloak, Option_Falcon, Option_Riding,
	Option_Invisible, Option_Orcish, Option_Wedding, Option_Chasewalk, Option_Flying,
	Option_Xmas, Option_Transform, Option_Summer, Option_Dragon1, Option_Wug,
	Option_Wugrider, Option_Madogear, Option_Dragon2, Option_Dragon3, Option_Dragon4,
	Option_Dragon5, Option_Hanbok, Option_Oktoberfest, Option_Dragon, Option_Costume

Atribuindo variáveis
--------- ---------

Variáveis ​​podem ser acessadas e modificadas como em outras linguagens de programação.

	.@x = 100;
	.@x = .@y = 100;

O suporte para modificar valores de variáveis ​​usando 'set' ainda é suportado (e necessário
existir para que esse novo método funcione), então os scripts anteriores continuarão funcionando.

Ao atribuir valores, todos os métodos de operador são suportados, os quais existem abaixo
Seção 'Operadores'. Por exemplo:

	.@x += 100;
	.@x -= 100;
	.@x *= 2;
	.@x /= 2;
	.@x %= 5;
	.@x >>= 2;
	.@x <<= 2;

Todos funcionarão. Para mais informações sobre os operadores disponíveis, consulte a seção Operadores
descrito abaixo. Todos os operadores listados ali podem ser colocados na frente do sinal '='
ao modificar variáveis ​​para executar a ação conforme necessário.

Observação:

!! Atualmente, o mecanismo de script não suporta cópia direta de variáveis ​​de array.
!! Para copiar arrays entre variáveis ​​o uso da função 'copyarray' ainda é
!! obrigatório.

Cordas
-------

Para incluir o símbolo '"' em uma string você deve usar o prefixo '\"'


Matrizes
------

Arrays (pelo menos no brHades) são essencialmente um conjunto de variáveis ​​que vão sob o
mesmo nome. Você pode diferenciar as variáveis ​​específicas de uma matriz com um
'índice de array', um número de uma variável naquele array:

<nome da variável>[<índice da matriz>]

Todos os tipos de variáveis ​​podem ser usados ​​como matrizes.

Variáveis ​​armazenadas dessa forma, dentro de um array, também são chamadas de 'elementos do array'.
Os arrays são especialmente úteis para armazenar um conjunto de dados semelhantes (como vários
IDs de itens, por exemplo) e, em seguida, fazer um loop por ele. Você pode endereçar qualquer array
variável como se fosse uma variável normal:

	set .@arrayofnumbers[0],1;

Você também pode fazer coisas como usar uma variável (ou uma expressão, ou mesmo uma
valor de outra matriz) para obter um valor de matriz:

	set .@x,100;
	set .@arrayofnumbers[.@x],10;

Isso fará com que .@arrayofnumbers[100] seja igual a 10.

A numeração do índice sempre começa com 0 e as matrizes podem conter mais de 2 bilhões
variáveis. Como tal, os valores permitidos (garantidos) para índices estão no
intervalo 0 ~ 2147483647.

E índices de array provavelmente não podem ser negativos. Ninguém testou o que acontece quando
você tenta obter uma variável numerada negativamente de uma matriz, mas não está indo
para ser bonita.

Os arrays podem armazenar strings naturalmente:

.@menulines$[0] é o 0º elemento do array .@menulines$ de strings. Observe
o '$', normalmente denotando uma variável de string, antes dos colchetes que
denota um índice de matriz.

Referências Variáveis
-------------------

//##PENDÊNCIA



Operadores
---------

Operadores são coisas que você pode fazer com variáveis ​​e números. Eles são ou
operações matemáticas comuns ou operadores condicionais

+ - adicionará dois números. Se você tentar adicionar duas strings, o resultado será um
    corda colada no +. Você pode adicionar um número a uma string, e o
    result será uma string. Nenhum outro operador matemático funciona com strings.
- - subtrairá dois números.
* - multiplicará dois números.
/ - dividirá dois números. Observe que esta é uma divisão inteira, ou seja
    7/2 não é igual a 3,5, é igual a 3.
% - lhe dará o resto da divisão. 7%2 é igual a 1.

Existem também operadores condicionais. Isso tem a ver com o condicional
comando 'if' e eles devem retornar 1 se a condição for satisfeita
e 0 se não for. (É o que eles chamam de variáveis ​​'booleanas'. 0 significa 'Falso'.
Qualquer coisa exceto o zero é 'Verdadeiro' Ímpar como é, -1 e -5 e qualquer coisa abaixo
zero também será Verdadeiro.)

Você pode comparar números entre si e comparar strings entre si, mas
você não pode comparar números a strings.

== - É verdadeiro se ambos os lados forem iguais. Para strings, significa que são iguais.
>= - Verdadeiro se o primeiro valor for igual ou maior que o segundo valor.
<= - Verdadeiro se o primeiro valor for igual ou menor que o segundo valor
> - Verdadeiro se o primeiro valor for maior que o segundo valor
< - Verdadeiro se o primeiro valor for menor que o segundo valor
!= - Verdadeiro se o primeiro valor NÃO for igual ao segundo

Exemplos:

1 == 1 é Verdadeiro.
1<2 é Verdadeiro enquanto 1>2 é Falso.
.@x>2 é verdadeiro se .@x for igual a 3. Mas não é verdadeiro se .@x for 2.

Apenas ' == ' e '!=' foram testados para comparar strings. Como não há como
para codificar uma estrutura de dados seriamente complexa nesta linguagem, tentando classificar
sequências por alfabeto seriam inúteis de qualquer forma.

As comparações podem ser empilhadas na mesma condição:

&& - É verdadeiro se e somente se AMBOS os lados forem verdadeiros.
      ('1 == 1 && 2 == 2' é verdadeiro. '2 == 1 && 1 == 1' é falso.)
|| - É Verdadeiro se qualquer um dos lados desta expressão for Verdadeiro.

1 == 1 && 2 == 2 é Verdadeiro.
1 == 1 && 2 == 1 é Falso.
1 == 1 || 2 == 1 é Verdadeiro.

Operadores lógicos bit a bit funcionam apenas com números e são os seguintes:

<< - Deslocamento para a esquerda.
>> - Deslocamento para a direita.
	O deslocamento para a esquerda move o binário 1(s) de um número n posições para a esquerda,
	que é o mesmo que multiplicar por 2, n vezes.
	Por outro lado, o deslocamento para a direita move o binário 1(s) de um número n posições
	para a direita, o que é o mesmo que dividir por 2, n vezes.
		Exemplo:
		set b,2;
		set a, b << 3;
		mes a;
		set a, a >> 2;
		mes a;
	O primeiro comando mes exibiria 16, que é o mesmo que 2 x (2 x 2 x 2) = 16.
	O segundo comando mes exibiria 4, que é o mesmo que 16 / 2 = 8. 8 / 2 = 4.
& - E.
| - Ou.
	O operador bit a bit AND (&) é usado para testar dois valores um contra o outro,
	e resulta na configuração de bits que são ativos em ambos os argumentos. Isso pode
	pode ser usado para algumas coisas, mas em brHades esse operador é geralmente usado para
	criar máscaras de bits em scripts.

	O operador bit a bit OU (|) define como 1 uma posição binária se a posição binária
	de um dos números é 1. Desta forma uma variável pode conter vários valores que podemos verificar,
	conhecido como bit-mask. Uma variável atualmente pode conter até 32 bit-mask (da posição 0
	para a posição 1). Esta é uma maneira barata e fácil de evitar o uso de matrizes para armazenar vários cheques
	que um jogador pode ter.

	Uma máscara de bits basicamente é (ab)usar os bits das variáveis ​​para set várias opções em
	uma variável. Com o limite atual de variáveis ​​é possível armazenar 32
	diferentes opções em uma variável (usando os bits nas posições 0 a 31).

	Exemplo(s):
	- Exemplo básico do operador &, exemplo de bit:
		10 e 2 = 2
	Por que? :
		10 = 2^1 + 2^3 (2 + 8), então em bits seria 1010
		2 = 2^1 (2), então em bits (mesmo tamanho) seria 0010
		O operador & (AND) define bits que são ativos (1) em ambos os argumentos, portanto, no
		exemplo 1010 e 0010, apenas o bit 2^1 está ativo (1) em ambos. Resultando no bit
		0010, que é 2.
	- Exemplo básico de criação e utilização de uma máscara de bits:
		set .@options,2|4|16; //(nota: isto é o mesmo que 2+4+16, ou 22)
		if (.@options & 1) mes "A opção 1 está ativada";
		if (.@options & 2) mes "A opção 2 está ativada";
		if (.@options & 4) mes "A opção 3 está ativada";
		if (.@options & 8) mes "A opção 4 está ativada";
		if (.@options & 16) mes "Opções 5 está ativado";
	Isso retornaria as mensagens sobre as opções 2, 3 e 5 sendo mostradas (já que definimos
	os 2,4 e 16 bits para 1).
^ - Xor.
	O operador bit a bit XOR (eXclusive OR) define uma posição binária como 0 se ambos
	os números têm o mesmo valor na referida posição. Por outro lado,
	define como 1 se eles tiverem valores diferentes na referida posição binária.
	Esta é outra maneira de set e desset bits em máscaras de bits.

	Exemplo:
	- Primeiro vamos set as missões que estão em andamento:
		set inProgress,1|8|16; // quest 1,8 e 16 estão em andamento
	- Depois de jogar um pouco, o jogador inicia outra missão:
		if (emProgresso&2 == 0) {
			// isso setá o bit para a missão 2 (o inProgress tem esse bit definido como 0)
			definido emProgresso,emProgresso^2;
			mes "Missão 2: encontre um novato e seja útil a ele por uma hora.";
			close;
		}
	- Depois de passar algum tempo lendo informações sobre Xor, o jogador finalmente completa a missão 1:
		if (emProgresso&1 && estáConcluído) {
			// isso irá desconfigurar o bit para a missão 1 (o inProgress tem esse bit definido como 1)
			set emProgresso,emProgresso^1;
			mes "Missão 1 concluída!! Você desvendou os segredos da dinastia Xor, use-os com sabedoria.";
			close;
		}

Operadores unários com apenas um único número, que segue o operador, e
estão seguindo:

- - Negação.
	O sinal do número será invertido. Se o número for positivo, ele será
	tornam-se negativos e vice-versa.

	Exemplo:
		set .@myvar,10;
		mes "Negativo 10 é " + (-.@myvar);

! - Lógico Não.
	Inverte o resultado booleano de uma expressão. True se tornará false e
	o falso se tornará verdadeiro.

	Exemplo:
		if (!callfunc("F_dosomething"))
		{
			mes "Fazer algo falhou.";
			close;
		}

~ - Bitwise Não.
	Inverte cada bit em um número, também conhecido como complemento de um. Bits limpos
	são definidos e os bits definidos são apagados.

	Exemplo:
	- Certifique-se de que a missão 2 esteja desabilitada, mantendo todas as outras ativas, se estiverem.
		set inProgress,inProgress&(~2); // o mesmo que set inProgress,inProgress&0xfffffffd

Os operadores ternários aceitam três expressões (números, strings ou booleanos) e são
seguindo:

?: - Operador condicional
	Muito útil, por exemplo, para substituir

		if (sex) mes "..."; else mes "...";

	cláusulas com simples

		mes "Bem-vindo, " + (Sexo?"Sr.":"Sra.") + " " + strcharinfo(0);

	ou para substituir quaisquer outras cláusulas if-else simples. Pode valer a pena
	mencionando que ?: tem baixa prioridade e deve ser incluído com
	parênteses na maioria dos casos (se não em todos).

Etiquetas
------

No código do script executável, algumas linhas podem ser rótulos:

<nome do rótulo>:

Os rótulos são pontos de referência em seu script, que podem ser usados ​​para rotear
execução com os comandos 'goto', 'menu' e 'jump_zero', invocados com 'doevent'
e comandos 'donpcevent' e são essenciais de outra forma. O nome de um rótulo não pode ser
com mais de 22 caracteres. (23º é o ':'.) Há alguma confusão no
fonte sobre se é 22, 23 ou 24 em todo o lugar, então mantendo rótulos
menos de 22 caracteres pode ser sensato. Pode conter apenas caracteres alfanuméricos
e sublinhado. Além dos rótulos que você nomeia, também existem alguns
rótulos especiais dos quais o mecanismo de script iniciará a execução se um especial
evento acontece:

OnClock<hora><minuto>:
OnMinute<minuto>:
OnHour<hora>:
On<dia da semana><hora><minuto>:
OnDay<mês><dia>:

Isso será executado quando o relógio do servidor atingir a data ou hora especificada. Horas
e os minutos são dados em horário militar. ('0105' significará 01:05 AM). Dias úteis
são Dom, Seg, Ter, Qua, Qui, Sex, Sáb. Os meses são de 01 a 12, os dias são de 01 a 31.
Lembre-se do zero.

OnInit:
OnInterIfInit:
OnInterIfInitOnce:

O OnInit será executado sempre que o carregamento dos scripts for concluído, inclusive quando
eles são recarregados com o comando @reloadscript. OnInterIfInit será executado quando
o servidor de mapas se conecta a um servidor de char, OnInterIfInitOnce executará apenas
uma vez e não será executado se o servidor de mapas se reconectar ao servidor de caracteres mais tarde.

OnAgitStart:
OnAgitEnd:
OnAgitInit:
OnAgitStart2:
OnAgitEnd2:
OnAgitInit2:
OnAgitStart3:
OnAgitEnd3:
OnAgitInit3:

O OnAgitStart será executado sempre que o servidor mudar para o modo WoE, seja
feito com o comando GM @agitstart ou com o comando de script 'AgitStart'. OnAgitEnd
fará o mesmo no final do WoE.

OnAgitInit será executado quando os dados de todos os castelos e todas as guildas que possuem um castelo
é recebido pelo map-server do char-server após a conexão inicial.

Nenhum RID será anexado enquanto qualquer um dos rótulos mencionados acima for acionado, portanto
nenhuma variável baseada em personagem ou conta estará acessível até que você anexe um
RID com 'attachrid' (veja abaixo).

O acima também se aplica aos últimos três rótulos, a única diferença é que
esses rótulos são usados ​​exclusivamente para WoE SE e são chamados de forma independente.

OnInstanceInit:

Este rótulo será executado quando uma instância for criada e inicializada por meio de
o comando 'instance_create'. Ele será executado novamente se @reloadscript for usado enquanto
uma instância está em andamento.

OnInstanceDestroy:

Este rótulo será executado quando uma instância for destruída por um tempo limite, excedendo
o tempo keepalive ou através do comando 'instance_destroy'. Ele será chamado
exatamente antes da instância ser destruída e todos os outros NPCs da instância
ainda estará disponível neste momento.

Em toque:

Este rótulo será executado se uma área de gatilho for definida para o objeto NPC em que está
em. Se não estiver presente, a execução começará do início do NPC
código. O RID do objeto de caractere de disparo será anexado.

Ao toque_:

Semelhante ao OnTouch, mas executará apenas uma instância. Outro personagem é
escolhido quando o personagem que acionou o gatilho deixa a área.

OnTouchNPC:

Semelhante ao OnTouch, mas só será acionado para monstros. Para este caso, usando
'getattachedrid' retornará GID (ID retornado ao usar 'monster').

Evento OnPCLogin:
OnPCLogoutEvent:
OnPCBaseLvUpEvent:
OnPCJobLvUpEvent:

É bem óbvio quando esses quatro rótulos especiais serão invocados.

OnPCDieEvent:

Este rótulo especial é acionado quando um jogador morre. A variável 'killerrid' é
definido como a ID do assassino.

OnPCKillEvent:

Este rótulo especial é acionado quando um jogador mata outro jogador. A variável
'killedrid' é definido como o ID do jogador morto.

OnNPCKillEvent:

Este rótulo especial é acionado quando um jogador mata um monstro sem rótulo.
A variável 'killedrid' é definida como a Clasif (ID do mob) do monstro morto.
A variável 'killedgid' é definida como o ID (ID exclusivo do jogo do mob) do monstro morto.

OnPCLoadMapEvent:

Este rótulo especial é acionado quando um jogador pisa em um mapa marcado com o
'loadevent' mapflag e anexa seu RID. O fato de que este rótulo requer um
mapflag para que funcione é porque, caso contrário, seria em todo o servidor e acionaria
toda vez que um jogador mudasse de mapa. Imagine a carga do servidor com 1.000 jogadores
(oh a dor...)

OnWhisperGlobal:

Este rótulo especial é acionado quando um jogador sussurra o NPC e será executado com o
RID do jogador anexado. Ele pode aceitar até dez parâmetros, que serão armazenados
em variáveis ​​de string de caracteres temporárias separadas @whispervar0$ a @whispervar9$.
Veja 'doc/whisper_sys.txt' para documentação adicional.

Somente os rótulos especiais que não estão associados a nenhum comando de script são
listados aqui. Existem outros tipos de rótulos que podem ser acionados de forma semelhante
maneira, mas são descritos com seus comandos associados.

OnNaviGenerate:

Este rótulo especial é acionado ao executar o binário map-server-generator. Ele é usado
em combinação com 'naviregisterwarp' para registrar warps extras para um npc.

Em<nome do rótulo>:

Esses rótulos especiais são usados ​​principalmente com scripts Mob e comandos de script
que requer que você aponte/vincule um comando a um mob ou outro NPC, dando um rótulo
nome para começar. O nome do rótulo pode ser qualquer um de sua preferência, mas deve ser
começou com "On".

Exemplo:

monster "prontera",123,42,"Poringz0rd",2341,23,"Master::OnThisMobDeath";

amatsu,13,152,4 script Master 767,{
	mes "Olá";
	close;

OnThisMobDeath:
	announce "Ei, " + strcharinfo(0) + " acabei de matar um Poringz0rd!",bc_blue|bc_all;
	end;
}

Cada vez que você matar um, aquele anúncio aparecerá em azul para todos.

Etiquetas "globais"

Há um problema com rótulos e doevent. Se você chamar um rótulo (usando doevent)
e o rótulo chamado está no NPC que tem área de gatilho, esse rótulo deve terminar com
“Global” para trabalhar globalmente (ou seja, se o RID estiver fora da área de gatilho, o que
geralmente acontece porque senão não faria sentido chamar a gravadora com
doevent, porque o OnTouch faria o trabalho). Para mais referências, procure por
npc_event em npc.cpp.

Comandos e funções de script
--------------------------------

Os comandos e funções são listados aqui sem nenhuma ordem específica. Há uma
diferença entre comandos e funções - comandos não deixam nenhum 'valor de retorno'
que pode ser usado em uma declaração condicional, como um argumento de comando ou armazenado
em uma variável. Chamar comandos como se fossem funções às vezes funcionará,
mas não é aconselhável, pois isso pode levar a alguns erros difíceis de rastrear. Chamando
funções como se fossem comandos bagunçarão a pilha, então o comando 'return'
não retornará corretamente depois que isso acontecer em um script específico.

Todos os comandos devem terminar com ';'.

-------------------------


A partir daqui, teremos os comandos classificados da seguinte forma:

1.- Comandos básicos.
2.- Comandos de recuperação de informações.
3.- Verificação de comandos.
4.- Comandos relacionados ao jogador.
5.- Comandos relacionados a mobs/NPCs.
6.- Outros comandos.
7.- Comandos de instância.
8.- Comandos do Quest Log.
9.- Comandos do campo de batalha.
10.- Comandos para animais de estimação.
10.1.- Os comandos da IA ​​do Pet.
11.- Comandos do Homúnculo.
12.- Comandos mercenários.
13.- Comandos do partido.
14.- Comandos de canal.
15.- Comandos de realização.

=====================
|1.- Comandos básicos.|
=====================
---------------------------------------

*mes "<string>"{,"<string>"{,...}};

Este comando exibirá uma caixa na tela para o caractere invocador, se não houver
essa caixa já é exibida e imprimirá a string especificada nela
caixa. Normalmente não há um botão 'fechar' ou 'próximo' nesta caixa, a menos que você
crie um com 'fechar' ou 'próximo', e enquanto estiver aberto o jogador não pode fazer muita coisa
senão, então é importante criar um botão depois. Se a string estiver vazia,
aparecerá como uma linha em branco.

	mes "Texto que aparecerá na caixa";

Cores
------
Dentro da string você pode colocar códigos de cores, que irão alterar a cor do
texto impresso depois deles. Os códigos de cores são todos '^<R><G><B>' e contêm três
números hexadecimais representando cores como se fossem cores HTML - ^FF0000 é
vermelho brilhante, ^00FF00 é verde brilhante, ^0000FF é azul brilhante, ^000000 é preto.
^FF00FF é um magenta puro, mas também é uma cor considerada transparente
sempre que o cliente estiver desenhando janelas na tela, imprimindo texto naquela cor
terá um efeito meio estranho. Depois de set a cor de um texto para algo,
você tem que colocá-lo de volta em preto, a menos que queira que todo o resto do texto fique em
essa cor:

	mes "Este é ^FF0000 vermelho ^000000 e este é ^00FF00 verde, ^000000 então.";

Observe que a coloração do texto é tratada exclusivamente pelo cliente. Se você usar não-
Caracteres ingleses, os códigos de cores podem ser alterados se eles ficarem presos às letras
sem espaço de intervenção. Separando-os com espaços das letras em
qualquer lado resolve o problema.

Várias linhas
--------------
Para exibir várias linhas de mensagem usando apenas um comando 'mes',
use o comando script no seguinte formato:

	mes "Linha 1", "Linha 2", "Linha 3";

Isso exibirá 3 linhas diferentes enquanto consome apenas uma única linha em
o arquivo de script relevante.

Navegação
----------
Para clientes datados de 2011-10-10aRagexe em diante, você pode gerar links de navegação
usando rótulos semelhantes a HTML:

	<NAVI>Nome de exibição<INFO>nome do mapa,x,y,0,000,flag</INFO></NAVI>

O parâmetro "flag" pode ser:
0: Não abrir a janela de navegação (padrão).
1: Abra a janela de navegação.

O exemplo abaixo tornará o texto [Loja de ferramentas] clicável e iniciará a navegação
para alberta (98.154) quando clicado.

	mes "Você já deu uma olhada na <NAVI>[Loja de Ferramentas]<INFO>alberta,98,154,0,000,0</INFO></NAVI>?";

Veja também 'navigateto', que pode ser usado para certos eventos de NPCs.

Unid
-----
Você pode consultar itens usando links semelhantes a HTML para determinados itens:

	<ITEMLINK>Nome de exibição<INFO>ID do item</INFO></ITEMLINK>

Onde <Nome de exibição> é o nome que será exibido para seu link e
<Item ID> é o ID do item que você deseja vincular quando clicado.

Em 2015, o nome da tag foi alterado para <ITEM>, resultando na seguinte sintaxe:

	<ITEM>Nome de exibição<INFO>ID do item</INFO></ITEM>

Portanto, criamos o comando de script "mesitemlink" que permite criar a sintaxe correta
dependendo da versão do pacote configurada. Recomendamos que você use este comando de script
em vez de codificar as tags semelhantes a HTML. Para mais detalhes, veja a documentação para "mesitemlink".

O exemplo a seguir abrirá uma janela de visualização do Red Potion:

	mes "Você já consumiu uma <ITEMLINK>Poção Vermelha<INFO>501</INFO></ITEMLINK>?";
	// Ou em 2015:
	mes "Você já consumiu uma <ITEM>Poção Vermelha<INFO>501</INFO></ITEM>?";

OBSERVAÇÃO: Esteja ciente de que os links dos itens estão quebrados em alguns clientes de 2015.

URLs
----
Da mesma forma, você pode criar links para sites que abrem em uma nova janela:

	<URL>Nome de exibição<INFO>http://www.example.com/</INFO></URL>";

Missões
------
Você pode criar um link para uma missão:

	<QUEST>Missão<INFO>1</INFO></QUEST>

Mensagem
-------
Você pode mostrar uma mensagem da tabela msgstring:

	<MSG>1</MSG>

Pontas
----
Você pode mostrar uma caixa de gorjetas:

	<TIPBOX>Mostrar Dica<INFO>1</INFO></TIPBOX>

---------------------------------------

*next;

Este comando exibirá um botão 'próximo' na janela de mensagem para o
invocando o personagem. Clicar nele fará com que a janela seja limpa e exibida
um novo. Usado para segmentar a conversa de NPCs, next é frequentemente usado em combinação com
'mes' e 'close'.

Se nenhuma janela estiver na tela no momento, uma será criada, mas assim que a invocação
o personagem clica nele, um aviso é lançado no console do servidor e o script
será encerrado.

	mes "[Mulher]";
	mes "Isso apareceria na página";
	next;
	// Isso é necessário porque é uma nova página e o topo agora estará em branco
	mes "[Mulher]";
	mes "Isso apareceria na 2ª página";

---------------------------------------

*clear;

Este comando limpará o texto do diálogo e continuará o script sem interação do jogador.

Exemplo:
	mes "É assim que o comando de script 'clear' funciona.";
	sleep2 3000;
	clear; // Isso limpará o diálogo e continuará para o próximo.
	mes "Eu vou te mostrar novamente.";
	sleep2 3000;
	clear;
	mes "Tchau!";
	close;

---------------------------------------

*close;

Este comando criará um botão 'fechar' na janela de mensagem para a invocação
personagem. Se nenhuma janela estiver na tela no momento, a execução do script será encerrada. Este é um
das maneiras de terminar um discurso de um NPC. Uma vez que o botão é clicado, o NPC
a execução do script será encerrada e a caixa de mensagem desaparecerá.

	mes "[Mulher]";
	mes "Terminei de falar com você. Clique no botão fechar.";
	close;
	mes "Este comando não será executado, pois o script foi encerrado.";

---------------------------------------

*close2;

Este comando criará um botão 'fechar' na janela de mensagem para a invocação
personagem. AVISO: Se nenhuma janela estiver na tela no momento, a execução do script será interrompida
indefinidamente! Veja 'fechar'. Há uma diferença importante, no entanto - embora
a caixa de mensagem será fechada, a execução do script não será interrompida e os comandos posteriores
'close2' ainda será executado, o que significa que um 'end' deve ser usado para parar o script, a menos que você
faça-o parar de alguma outra maneira.

	mes "[Mulher]";
	mes "Eu vou te teletransportar agora.";
	close2;
	warp "lugar",50,50;
	end;

Não espere que as coisas corram bem se você não fizer seus scripts "terminarem".

---------------------------------------

*close3;

O comando é semelhante ao "close", mas o cutin (se houver) é limpo após o fechamento.

---------------------------------------

*end;

Este comando interromperá a execução deste script em particular. Os dois
versões são perfeitamente equivalentes. É a maneira normal de terminar um script que
não usa 'mes'.

	if (BaseLevel <= 10)
		npctalk "Olha só, você ainda é um n00b";
	else if (BaseLevel <= 20)
		npctalk "Olha só, você está melhorando, mas ainda é um novato";
	else if (BaseLevel <= 30)
		npctalk "Olha só, você está chegando lá, você está quase na segunda profissão agora, certo???";
	else if (BaseLevel <= 40)
		npctalk "Olha só que você é quase uma segunda profissão";
	end;

Sem o uso de 'end' ele viajaria pelos rótulos até o final do
script. Se você fosse lvl 10 ou menos, você veria todas as falas, o uso
de 'end' interrompe isso e finaliza o script.

---------------------------------------

*set <variável>,<expressão>{,<char_id>};
*set(<variável>,<expressão>{,<id do caractere>})

Este comando setá uma variável para o valor que a expressão resulta.
As variáveis ​​podem ser definidas por meio deste comando ou diretamente, como qualquer outro
outra linguagem de programação (consulte a seção "Atribuição de variáveis").

Este é o comando de script mais básico e é muito usado sempre que você tenta fazer
qualquer coisa mais avançada do que apenas imprimir texto em uma caixa de mensagem.

	set .@x,100;

fará com que .@x seja igual a 100.

	conjunto .@x,1+5/8+9;

calculará 1+5/8+9 (que é, surpreendentemente, 10 - lembre-se, todos os números são
inteiro nesta linguagem) e faça .@x igual a ele.

Retorna a referência da variável (desde o tronco r12870).

---------------------------------------

*setd "<nome da variável>",<valor>{,<char_id>};

Funciona quase de forma idêntica ao conjunto, exceto que o nome da variável é identificado como uma string
e pode, portanto, ser construído dinamicamente.

Este comando é equivalente a:
	set getd("nome da variável"),<valor>;

Exemplos:

	setd ".@var$", "Poporing";
	mes .@var$; // Exibe "Poporing".

	setd ".@" + .@var$ + "123$", "Poporar é legal";
	mes .@Poporing123$; // Exibe "Poporing é legal".

OBSERVAÇÃO:
	'char_id' só funciona para variáveis ​​que não sejam de servidor.
	O jogador com ID de personagem 'char_id' deve estar online.

---------------------------------------

*getd("<nome da variável>")

Retorna uma referência a uma variável, o nome pode ser construído dinamicamente.
Consulte 'setd' para uso.

Isso também pode ser usado para set uma matriz dinamicamente:
	setarray getd(".array[0]"), 1, 2, 3, 4, 5;

Exemplos:

	set getd("$varRefence"), 1;
	set .@i, getd("$" + "pikachu");

---------------------------------------

*getvariableofnpc(<variável>,"<nome do npc>")

Retorna uma referência a uma variável NPC (prefixo .) do NPC alvo.
Isso só pode ser usado para obter variáveis.

Exemplos:

//Isso retornará o valor de .var, observe que isso não pode ser usado, pois o valor não é capturado.
	getvariableofnpc(.var,"TargetNPC");

//Isso setá a variável .v para o valor da variável .var do TargetNPC.
	set .v, obtervariáveldenpc(.var,"TargetNPC");

//Isso setá a variável .var do TargetNPC como 1.
	set getvariableofnpc(.var,"TargetNPC"), 1;

Nota: embora os objetos de função possam ter .variables,
getvariableofnpc não funcionará neles.

---------------------------------------

*getvar <variável>,<char_id>;

Obter valor variável do jogador especificado. Apenas variáveis ​​de jogador/conta
podem ser usados ​​(variável de caractere temporária "@", permanente
caractere "", conta local permanente "#" e conta global permanente "##").

---------------------------------------

*goto <rótulo>;

Este comando fará o script pular para um rótulo, geralmente usado em conjunto
com outro comando, como "if", mas frequentemente usado sozinho.

	...
	goto Rótulo;

	mes "Isso não será visto";
	end;
Rótulo:
	mes "Isso será visto";
	end;

Este comando deve ser evitado e usado somente se não houver outra opção.

---------------------------------------

*menu "<texto_opção>",<rótulo_alvo>{,"<texto_opção>",<rótulo_alvo>,...};

Este comando criará um menu selecionável para o personagem invocador. Apenas um
o menu pode estar na tela ao mesmo tempo.

Dependendo do que o jogador escolher no menu, a execução do script será
continuar a partir do rótulo correspondente. (são pares string-rótulo, não rótulo-
corda)

As opções podem ser agrupadas, separadas pelo caractere ':'.

	menu "A:B",L_Errado,"C",L_Direito;

Ele também define uma variável de caractere temporária especial @menu, que contém o
número de opções que o jogador escolheu. (A numeração das opções começa em 1.)
Este número é consistente com opções vazias e opções agrupadas.

	menu "A::B",L_Errado,"",L_Impossível,"C",L_Certo;

	L_Errado:
		// Se clicarem em "A" ou "B" eles acabarão aqui
		// @menu == 1 se "A"
		// @menu == 2 nunca acontecerá porque a opção está vazia
		// @menu == 3 se "B"
	L_Impossível:
		// As opções vazias não são exibidas e, portanto, não podem ser selecionadas
		// este rótulo nunca será alcançado pelo comando de menu
	L_Certo:
		// Se clicarem em "C" eles vão parar aqui
		// @menu == 5

Se um rótulo for '-', a execução do script continuará logo após o menu
comando se essa opção for selecionada, isso pode ser usado para economizar seu tempo e
otimizar scripts grandes.

	menu "A::B:",-,"C",L_Direita;
		// Se clicarem em "A" ou "B" eles acabarão aqui
		// @menu == 1 se "A"
		// @menu == 3 se "B"
	L_Direita:
		// Se clicarem em "C" eles vão parar aqui
		// @menu == 5

Ambos os exemplos executarão exatamente a mesma tarefa.

Se você fornecer uma string vazia como um item de menu, o item não será exibido. Isto
pode ser usado efetivamente para criar scripts de menus dinâmicos usando uma string vazia para
entradas que não deveriam estar disponíveis naquele momento.

Você pode fazer isso usando matrizes, mas observe com cuidado - esse truque não é alto
magia, mas magia menor pelo menos. Você não pode esperar duplicá-la facilmente
até você entender como funciona.

Crie uma matriz temporária de strings para conter os itens do seu menu e preencha-a
com as strings que devem entrar no menu nesta execução, certificando-se de não
para deixar quaisquer lacunas. Normalmente, você faz isso com um loop e um contador extra, como
esse:

	setarray .@possiblemenuitems$[0],<lista de itens de menu potenciais>;
	.@j = 0; // Esse é o contador de linhas do menu.

	// Percorremos a lista de possíveis itens de menu.
	// .@i é nosso contador de loop.
	for( .@i = 0; .@i < getarraysize(.@possiblemenuitems$); .@i++ )
	{
		// Essa 'condição' é qualquer condição que determina se
		// um número de item de menu .@i realmente entra no menu ou não.

		if (<condição>)
		{
			// Registramos a opção na lista de opções realmente disponíveis.

			.@menulist$[@j] = .@possiblemenuitems$[@i];

			// Acabamos de copiar a string, precisamos do seu número para mais tarde
			// então gravamos também.

			.@menureference[@j] = .@i;

			// Como acabamos de adicionar um item de menu à lista, incrementamos
			// o contador de linhas do menu.

			.@j++;
		}

		// Vamos para o próximo item de menu possível.
	}

Isso criará um array .@menulist$ que contém o texto de todos os itens
que deveria realmente entrar no menu com base na sua condição e uma matriz
.@menureference, que contém seus números na lista de possíveis itens de menu.
(Lembre-se, os arrays começam com 0.) Há menos deles do que o menu possível
itens que você definiu, mas o comando de menu pode manipular as linhas vazias - somente se
eles são os últimos da lista, e se for feito dessa forma, eles são. Agora vem um
truque sujo:

	// X é qualquer item de menu que você espera manipular.
	menu .@menulist$[0],-,.@menulist$[1],-,...,.@menulist$[<X>],-;

Isso chama um menu de todos os seus itens. Como você não copiou alguns dos
possíveis itens de menu na lista, seu final está vazio e, portanto, nenhum item de menu será
aparecer depois do fim. Mas essa chamada de menu não pula para lugar nenhum, ela apenas
continua a execução logo após o comando do menu. (E é uma coisa boa que
não, porque você só pode set explicitamente rótulos para pular, e como você faz isso?
saiba quais set se você não sabe de antemão quais opções acabarão
onde no seu menu?)
Mas como você descobre qual opção o usuário escolheu? Digite o @menu.

@menu contém o número de opções que o usuário selecionou na lista,
começando com 1 para a primeira opção. Agora você sabe qual opção o usuário escolheu
e qual número na sua lista real de possíveis itens de menu ele traduziu para:

    mes "Você selecionou " + .@possiblemenuitems$[.@menureference[@menu-1]] + "!";

@menu é o número de opções que o usuário escolheu.
@menu-1 é o índice da matriz para a lista de itens de menu realmente usados ​​que nós
feito.
.@menureference[@menu-1] é o número do item na matriz de menus possíveis
itens que guardamos apenas para esse propósito.

E .@possiblemenuitems$[.@menureference[@menu-1]] é a string que usamos para
exibir a linha de menu que o usuário escolheu. (Sim, é um pouco trabalhoso, mas funciona.)

Você pode configurar um monte de instruções 'if (.@menureference[@menu-1] == X) goto Y' para
roteie sua execução com base na linha selecionada e ainda gere um diferente
menu todas as vezes, o que é útil quando você deseja, por exemplo, fazer com que os usuários selecionem
itens em qualquer ordem específica antes de prosseguir, ou crie um menu embaralhado aleatoriamente.

O código Kafra incluído na distribuição padrão usa uma matriz semelhante
técnica de menu para listas de teletransporte, mas é muito mais simples e não usa @menu,
provavelmente porque isso não foi documentado em lugar nenhum.

Veja também 'select', que provavelmente é melhor neste caso em particular. Em vez de
menu, você pode usar 'select' assim:

    .@dummy = select(.@menulist$[0],.@menulist$[1],...,.@menulist$[<X>]);

Para os propósitos da técnica descrita acima, essas duas afirmações são
perfeitamente equivalente.

---------------------------------------

*select("<opção>"{,"<opção>",...})
*prompt("<opção>"{,"<opção>",...})

Esta função é uma substituição útil para 'menu' para alguns casos específicos onde
você não quer uma estrutura de rótulo complexa - como, por exemplo, pedir um simples sim-
sem perguntas. Ele retornará o número de opções de menu selecionadas, começando com 1.
Assim como 'menu', ele também setá a variável @menu para conter a opção que o usuário
escolhido.

    if (select("Sim:Não" ) == 1)
		mes "Você disse sim, eu sei.";

E como no 'menu', a opção selecionada é consistente com as opções agrupadas
e opções vazias.

'prompt' funciona quase da mesma forma que selecionar, exceto que quando um personagem clica
o botão Cancelar, esta função retornará 255.

---------------------------------------

*input(<variável>{,<min>{,<max>}})

Este comando fará com que uma caixa de entrada apareça no cliente conectado ao
invocando caractere, para permitir a entrada de um número ou uma string. Isso tem muitos
usos, um exemplo seria um jogo de adivinhação, também fazendo uso do 'rand'
função:

	mes "[Mulher]";
	mes "Tente adivinhar o número que estou pensando.";
	mes "O número estará entre 1 e 10.";
	next;
	.@número = rand(1,10);
	input .@palpite;
	if (.@palpite == .@número) {
		mes "[Mulher]";
		mes "Muito bem, esse era o número que eu estava pensando!";
		close;
	} outro {
		mes "[Mulher]";
		mes "Desculpe, esse não era o número que eu estava pensando.";
		close;
	}

Se você der ao comando de entrada uma variável de string para colocar a entrada, ele irá
permite que o jogador insira texto. Caso contrário, somente números serão permitidos.

	mes "[Mulher]";
	mes "Por favor diga OLÁ";
	next;
	input .@var$;
	if (.@var$ == "OLÁ") {
		mes "[Mulher]";
		mes "Muito bem, você digitou corretamente.";
		close;
	} outro {
		mes "[Mulher]";
		mes "Desculpe, você entendeu errado.";
		close;
	}

Normalmente você não pode inserir um número negativo com este comando.
Isso é feito para evitar explorações em scripts mal escritos, o que
deixe as pessoas, por exemplo, colocar quantias negativas de Zeny em um script bancário e
receba Zeny grátis como resultado.

Desde o tronco r12192, o comando tem dois argumentos opcionais e um valor de retorno.
O valor padrão de 'min' e 'max' pode ser definido com 'input_min_value' e
'input_max_value' em script_athena.conf.
Para entradas numéricas, o valor é limitado ao intervalo [min,max]. Retorna 1 se
o valor era maior que 'max', -1 se menor que 'min' e 0 caso contrário.
Para entradas de string, ele retorna 1 se a string for maior que 'max', -1 é
menor que 'min' e 0 caso contrário.

---------------------------------------

*callfunc "<função>"{,<argumento>,...<argumento>};
*callfunc("<função>"{,<argumento>,...<argumento>})

Este comando permite que você chame um NPC de função. Um NPC de função pode ser chamado de
qualquer script em qualquer servidor de mapas. Usando o comando 'return' ele retornará para
o lugar que o chamou.

	lugar,50,50,6%TAB%script%TAB%Mulher%TAB%115,{
		mes "[Mulher]"
		mes "Vamos ver se você ganha...";
		callfunc "funcNPC";
		mes "Muito bem, você venceu!";
		close;
	}
	function%TAB%script%TAB%funcNPC%TAB%{
		.@win = rand(2);
		if (.@win == 0)
			retornar;
		mes "Desculpe, você perdeu.";
		close;
	}

Você pode passar argumentos para sua função - valores que dizem exatamente o que fazer -
que estará disponível lá com getarg() (veja 'getarg')
Observe que retornar não é obrigatório, você pode encerrar a execução ali mesmo.

Se você quiser retornar um valor real de dentro da sua função NPC, é melhor
para escrevê-lo na forma de função, o que também funcionará e tornará o script
geralmente mais limpo:

	lugar,50,50,6%TAB%script%TAB%Homem%TAB%115,{
		mes "[Homem]"
		mes "Me dê um número!";
		next;
		input .@número;
		if (callfunc("OddFunc",.@number)) mes "É estranho!";
		close;
	}
	function%TAB%script%TAB%OddFunc%TAB%{
		if (getarg(0)%2 == 0)
			retornar 0;// é par
		return 1;// é estranho
	}

Alternativamente, a partir da revisão 15979 e 15981 do brHades, funções definidas pelo usuário
pode ser chamado diretamente sem o uso do comando de script 'callfunc'.

	function<tab>script<tab>DigaOla<tab>{
		mes "Olá " + getarg(0);
		retornar 0;
	}

	lugar,50,50,6<tab>script<tab>Homem<tab>115,{
		mes "[Homem]";
		DigaOla strcharinfo(0);
		close;
	}

Observação:

!! Uma função definida pelo usuário deve ser declarada /antes/ de um script tentar
!! chame-o. Ou seja, qualquer função deve ser colocada acima de scripts ou NPCs
!! (ou carregados em um arquivo separado primeiro) antes de tentar chamá-los diretamente.

---------------------------------------

*callsub <rótulo>{,<argumento>,...<argumento>};
*callsub(<rótulo>{,<argumento>,...<argumento>})

Este comando irá para um rótulo especificado dentro do script atual (NÃO use
aspas ao redor) entrando como se fosse uma chamada 'callfunc' e passando-a
argumentos fornecidos, se houver, que podem ser recuperados lá com 'getarg'. Quando feito
lá, você deve usar o comando 'return' para voltar ao ponto de onde
esse rótulo foi chamado. Isso é usado quando há uma coisa específica no script
fará repetidamente, isso permite que você use o mesmo pedaço de código quantas vezes quiser
você gosta, para economizar espaço e tempo, sem criar objetos NPC extras que são
necessário com 'callfunc'. Um rótulo não pode ser chamado dessa maneira de outro
roteiro.

Exemplo 1: callsub para verificação (se as verificações forem aprovadas, retornar ao script)
	callsub S_CheckFull, "guild_vs2",50;
	alternar(rand(4)) {
		caso 0: warp "guild_vs2",9,50; end;
		caso 1: warp "guild_vs2",49,90; end;
		caso 2: warp "guild_vs2",90,50; end;
		caso 3: warp "guild_vs2",49,9; end;
	}

...

S_VerificaçãoCompleta:
	if (getmapusers(getarg(0)) >= getarg(1)) {
		mes "Desculpe, esta arena está cheia. Por favor, tente novamente mais tarde.";
		close;
	}
	retornar;

Exemplo 2: callsub usado repetidamente, com argumentos diferentes
// observe como a verificação/exclusão do Zeny é reutilizada, em vez de copiar e colar para cada distorção
	switch(select("Lago Abyss: Calabouço Amatsu: Anthell: Calabouço Ayothaya: Ilha Beacon, Pharos")) {
		caso 1: callsub S_DunWarp,"hu_fild05",192,207;
		caso 2: callsub S_DunWarp,"ama_in02",119,181;
		caso 3: callsub S_DunWarp,"moc_fild20",164,145;
		caso 4: callsub S_DunWarp,"ayo_fild02",279,150;
		caso 5: callsub S_DunWarp,"cmd_fild07",132,125;
		// etc
	}

...

S_DunWarp:
// getarg(0) = "nome do mapa"
// getarg(1) = x
// getarg(2) = y
	if (Zeny >= 100) {
		Zeny -= 100;
		deformar getarg(0), getarg(1), getarg(2);
	} outro {
		mes "A viagem de masmorra custa 100 Zeny.";
	}
	close;

---------------------------------------

*getarg(<índice>{,<valor_padrão>})

Esta função é usada quando você usa os comandos 'callsub' ou 'callfunc'. No
chamada você pode especificar variáveis ​​que farão essa chamada diferente de outra
um. Esta função retornará um argumento que a função ou sub-rotina foi
chamado com, e é a maneira normal de obtê-los.
Essa é outra coisa que pode fazer com que você use o mesmo código mais de uma vez.

A numeração dos argumentos começa com 0, ou seja, o primeiro argumento que você deu é o número 0.
Se nenhum argumento desse tipo for fornecido, um zero será retornado.

	lugar,50,50,6%TAB%script%TAB%Mulher1%TAB%115,{
		mes "[Mulher]";
		mes "Vamos ver se você ganha...";
		callfunc "funcNPC",2;
		mes "Muito bem, você venceu!";
		close;
	}

	lugar,52,50,6%TAB%script%TAB%Mulher2%TAB%115,{
		mes "[Mulher]";
		mes "Vamos ver se você ganha...";
		callfunc "funcNPC",5;
		mes "Muito bem, você venceu!";
		close;
	}

	função%TAB%script%TAB%funcNPC%TAB%{
		.@win = rand(getarg(0));
		if (.@win == 0) retornar;
		mes "Desculpe, você perdeu.";
		close;
	|

O objeto NPC "woman1" chama o funcNPC. O argumento que ele fornece nesta chamada é
declarado como 2, então quando o número aleatório é gerado pela função 'rand', ele
só pode ser 0 ou 1. Enquanto "woman2" fornece 5 como o número do argumento 0 quando
chamando a função, então o número aleatório pode ser 0, 1, 2, 3 ou 4, isso faz
"woman2" tem menos probabilidade de dizer que o jogador venceu.

Você pode passar vários argumentos em uma chamada de função:

	callfunc "funcNPC",5,4,3;

getarg(0) seria 5, getarg(1) seria 4 e getarg(2) seria 3.

'getarg' tem um argumento opcional desde o tronco r10773 e o estável r10958.
Se o argumento de destino existir, ele será retornado.
Caso contrário, se <default_value> estiver presente, ele será retornado,
caso contrário, o script termina imediatamente.

No exemplo anterior, getarg(2,-1) seria 3 e getarg(3,-1) seria -1.

---------------------------------------

*obtercontagem()

Esta função é usada quando você usa os comandos 'callsub' ou 'callfunc'. No
chamada você pode especificar argumentos. Esta função retornará o número de argumentos
oferecido.

Exemplo:
	callfunc "funcNPC",5,4,3;
	...
	função%TAB%script%TAB%funcNPC%TAB%{
		.@count = getargcount(); // 3
		...
	}

---------------------------------------

*retornar {<valor>};

Este comando faz com que a execução do script saia da função chamada anteriormente
com callfunc ou script com callsub e retornar ao local onde a chamada foi feita
originado de. Opcionalmente, um valor de retorno pode ser fornecido, quando a chamada foi
feito usando a função form.

Usar este comando fora de funções ou scripts referenciados por callsub irá
resultar em erro e encerramento do script.

	callfunc "<sua função>";// quando nada é retornado
	set <variável>,callfunc("<sua função>");// quando um valor está sendo retornado

---------------------------------------

*function <nome da função>;
*<nome da função>{(<argumento>,...<argumento>)};
*function <nome da função> {
<código>
}

Isso funciona como callfunc e é usado para scripts mais limpos e rápidos. A função
deve ser definido e usado dentro de um script e funciona como um rótulo com argumentos.
Observe que o nome pode conter apenas caracteres alfanuméricos e sublinhado.

Uso:

    1. Declare a função.
	função <nome da função>;
    2. Chame a função em qualquer lugar do script.
       Ele também pode retornar um valor quando usado com parênteses.
	<nome da função>;
    3. Defina a função dentro do script.
	<nome da função> {<código>}

Exemplo:

prontera,154,189,4 script Item Vendedor 767,{
	/* Declaração de função */
	função SF_Selling;

	if (Zeny > 50) {
		mes "Bem-vindo!";
		/* Chamada de função */
		SF_Vendas;
	}
	senão me "Você precisa de 50z, desculpe!";
	close;

	/* Definição de função */
	função SF_Selling {
		mes "Você gostaria de comprar um phracon por 50z?";
		next;
		if (select("Sim","Não, obrigado") == 1) {
			Zeny -= Zeny;
			obter item 1010,1;
			mes "Obrigado!";
		}
		retornar;
	}
}

Exemplo com parâmetros e valor de retorno:

prontera,150,150,0 script TestNPC 123,{
	/* Declaração de função */
	função MyAdd;

	mes "Digite dois números.";
	next;
	entrada .@a;
	entrada .@b;
	/* Chamada de função */
	mes .@a + " + " + .@b + " = " + MyAdd(.@a,.@b);
	close;

	/* Definição de função */
	função MyAdd {
		retornar getarg(0)+getarg(1);
	}
}


---------------------------------------

*is_function("<nome da função>")

Este comando verifica se uma função existe.
Ele retorna 1 se a função for encontrada, ou 0 se não for.

Exemplo:

	função script tente {
		faça isso;
	}

	- teste de script -1,{
		.@try = is_function("tentar"); // 1
		.@not = is_function("não"); // 0
	}

---------------------------------------

*if (<condição>) <declaração>;

Este é o comando básico de declaração condicional e praticamente o único
disponível nesta linguagem de script.

A condição pode ser qualquer expressão. Todas as expressões que resultam em um valor diferente de zero
valor será considerado Verdadeiro, incluindo valores negativos. Todas as expressões
resultando em zero são falsas.

Se a expressão resultar em True, a instrução será executada. Se não for
verdade, nada acontece e passamos para a próxima linha do script.

    if (1) mes "Isso sempre será impresso.";
    if (0) mes "E isso nunca será impresso.";
    if (5) mes "Isso também sempre será impresso.";
    if (-1) mes "Por mais engraçado que seja, isso também será impresso perfeitamente.";

Para mais informações sobre operadores condicionais, consulte a seção de operadores acima.
Qualquer coisa que seja retornada por uma função pode ser usada em uma verificação de condição sem
incomodando-se em armazená-lo em uma variável específica:

    if (strcharinfo(0) == "Daniel Jackson") mes "É verdade, você é Daniel!";

Mais exemplos de uso do comando 'if' no mundo real:

Exemplo 1:

	.@resposta = 1;
	entrada .@entrada;
	if (.@input == .@answer)
		close;
	mes "Desculpe, sua resposta está incorreta.";
	close;

Exemplo 2:

	.@resposta = 1;
	entrada .@entrada;
	if (.@entrada != .@resposta)
		mes "Desculpe, sua resposta está incorreta.";
	close;

Observe que os exemplos 1 e 2 têm o mesmo efeito.

Exemplo 3:

	.@contagem++;
	mes "[Homem Esquecido]";
	if (.@count == 1) mes "Esta é a primeira vez que você fala comigo.";
	if (.@count == 2) mes "Esta é a segunda vez que você fala comigo.";
	if (.@count == 3) mes "Esta é a terceira vez que você fala comigo.";
	if (.@contagem == 4) {
		mes "Esta é a quarta vez que você fala comigo.";
		mes "Acho que estou tendo amnésia, esqueci de você...";
		.@contagem = 0;
	}
	close;

Exemplo 4:

	mes "[Pessoa da Missão]";
	if (countitem(512) < 1) { // 512 é o ID do item para Apple, encontrado em db/item_db.yml
		mes "Você pode me trazer uma maçã, por favor?";
		close;
	}
	mes "Oh, você trouxe uma maçã!";
	mes "Eu não queria isso, eu só queria ver um.";
	close;

Exemplo 5:

	mes "[Verificador de Pessoas]";
	if ($@name$ == "") { // variável global ainda não definida
		mes "Por favor me diga o nome de alguém";
		next;
		entrada $@nome$;
		$@nome2$ = strcharinfo(0);
		mes "[Verificador de Pessoas]";
		mes "Obrigado.";
		close;
	}
	if ($@name$ == strcharinfo(0)) { // o nome do jogador corresponde a $@name$
		mes "Você é a pessoa que " + $@name2$ + " acabou de mencionar.";
		mes "Prazer em conhecê-lo!";

		// redefine as variáveis ​​globais
		$@nome$ = "";
		$@nome2$ = "";

		close;
	}
	mes "Você não é a pessoa que " + $name2$ + " mencionou.";
	close;

Veja 'strcharinfo' para uma explicação do que esta função faz.

Exemplo 6: Usando condições complexas.

	mes "[Verificações múltiplas]";
	if (@queststarted == 1 && countitem(512) >= 5) {
		mes "Muito bem, você começou a missão e me trouxe 5 maçãs.";
		@queststarted = 0;
		delimitação 512,5;
		close;
	}
	mes "Por favor, traga-me 5 maçãs.";
	@queststarted = 1;
	close;

O mecanismo de script também suporta instruções 'if' aninhadas:

	if (<condição>)
		faça isso;
	outro
		faça isso;

Se a condição não for atendida, ele executará a ação seguinte ao 'else'.
Também podemos agrupar diversas ações dependendo de uma condição:

	if (<condição>) {
		faça isso1;
		faça isso2;
	} outro {
		faça isso1;
		faça isso2;
		faça isso3;
	}

Lembre-se de que se você planeja fazer várias ações sob a condição ser falsa, e
você esqueceu de usar as chaves (o { } ), a segunda ação será executada independentemente
a saída da condição, a menos que, é claro, você pare a execução do script se o
condição é verdadeira (ou seja, no primeiro agrupamento usando um return; e end; ou um close; )

Além disso, você pode ter várias condições aninhadas ou encadeadas.

	if (<condição 1>)
		faça isso;
	else if (<condição 2>) {
		faça isso;
		end;
	} outro
		faça isso;

---------------------------------------

*jump_zero (<condição>),<rótulo>;

Este comando funciona como uma combinação de 'if'+'goto' de uma só vez. (Veja 'if').
Se a condição for falsa (igual a zero), este comando irá imediatamente pular para
o rótulo especificado como em 'goto'. Enquanto 'if' é mais geralmente útil, para
em alguns casos isso pode ser uma otimização.

O principal motivo desse comando é que outras instruções de controle, como
'switch', 'for' ou 'while', são desmontados em expressões simples juntos
com este comando quando um script é analisado.

---------------------------------------

*switch (expressão);

A instrução switch é semelhante a uma série de instruções if na mesma expressão.
Em muitas ocasiões, você pode querer comparar a mesma variável (ou expressão)
com muitos valores diferentes e executar um pedaço diferente de código dependendo
em qual valor ele é igual. É exatamente para isso que serve a instrução switch.

É importante entender como a instrução switch é executada para
para evitar erros. A instrução switch executa linha por linha (na verdade, instrução por instrução).
No início, nenhum código é executado. Somente quando uma instrução case é encontrada
com um valor que corresponde ao valor da expressão switch da(s) declaração(ões) case
vontade de ser executado. O analisador continua a executar as instruções até o final
do bloco switch, ou a primeira vez que ele vê uma instrução break. Se você não
escreva uma instrução break no final da lista de instruções de um caso, o analisador irá
continue executando as instruções do caso seguinte (fall-through).

Exemplo 1:

	switch(select("Sim:Não")) {
		caso 1:
			mes "Você disse sim!";
			quebrar;
		caso 2:
			mes "Aww, por quê?";
			quebrar;
	}
	close;

O exemplo acima funcionaria como um menu e iria para o primeiro caso se
o usuário seleciona a opção, caso contrário, irá para a segunda.

Exemplo 2:

	alternar(obteridgrupo()) {
		caso 1:
			mes "Uau, você é demais!";
			quebrar;
		caso 2:
			mes "Uma mão amiga!";
			quebrar;
		caso 3:
			mes "10001010010011";
			quebrar;
		caso 4:
			mes "Sim, milorde?";
			quebrar;
		padrão:
			mes "Olá!";
			quebrar;
	}

O exemplo acima imprimiria uma mensagem dependendo do groupid do jogador.
Se não houver nenhuma declaração para o groupid correspondente, o script
usaria a declaração 'padrão' que se aplica ao restante dos valores possíveis,
semelhante a 'else' na instrução if-else.

---------------------------------------

*while (<condição>) <declaração>;

Esta é provavelmente a estrutura de loop mais simples e mais usada. O 'while'
a declaração pode ser interpretada como "enquanto <condição> for verdadeira, execute <declaração>".
É um loop de pré-teste, o que significa que a expressão condicional é testada antes de qualquer um dos
instruções no corpo do loop são executadas. Se a condição for avaliada como
falso, a(s) declaração(ões) no corpo do loop nunca é/são executada(s). Se o
condição é avaliada como verdadeira, a(s) declaração(ões) é(são) executada(s) e, em seguida, o controle é transferido
de volta à expressão condicional, que é reavaliada e o ciclo continua.

Várias instruções podem ser agrupadas com { }, chaves, assim como na instrução 'if'.

Exemplo 1:
	enquanto (switch(selecionar("Sim:Não") == 2 ))
		mes "Você escolheu não.";
	close;

Exemplo 2: múltiplas declarações
	enquanto (switch(selecionar("Sim:Não") == 2 )) {
		mes "Por que você escolheu não?";
		mes "Você deveria escolher sim!";
	}
	close;

Exemplo 3: loop controlado por contador
	.@i = 1;
	enquanto (.@i <= 5) {
		mes "Esta linha será impressa 5 vezes.";
		.@i += 1;
	}
	close;

Exemplo 4: loop controlado por sentinela
	mes "Digite 0 para parar";
	entrada .@num;
	enquanto (.@num != 0) {
		mes "Você entrou " + .@num;
		entrada .@num;
	}
	close;

---------------------------------------

*for (<inicialização de variável>; <condição>; <atualização de variável>) <instrução>;

Outra estrutura de loop de pré-teste é a declaração 'for'. É considerada uma
forma especializada da declaração 'while' e geralmente é associada a counter-
loops controlados. Aqui estão as etapas da instrução 'for': a inicialização
a instrução é executada primeiro e somente uma vez. O teste de condição é executado.
Quando a condição é avaliada como falsa, o restante da instrução for é ignorado.
Quando a condição é avaliada como verdadeira, o corpo do loop é executado e, em seguida, o
a instrução update é executada (isso geralmente envolve incrementar uma variável).
Então a condição é reavaliada e o ciclo continua.

Exemplo 1:
	for( .@i = 1; .@i <= 5; .@i++ )
		mes "Esta linha será impressa 5 vezes.";

Exemplo 2:
	mes "Isso imprimirá os números de 1 a 5.";
	for( .@i = 1; .@i <= 5; .@i++ )
		mes "Número: " + .@i;

---------------------------------------

*do { <declaração>; } while (<condição>);

'do...while' é a única estrutura de loop pós-teste disponível neste script
idioma. Com um pós-teste, as instruções são executadas uma vez antes da condição
é testado. Quando a condição é verdadeira, a(s) declaração(ões) é(são) repetida(s). Quando a
condição for falsa, o controle é transferido para a declaração seguinte à
Expressão de loop 'do...while'.

Exemplo 1: loop controlado por sentinela
	mes "Este menu continuará aparecendo até que você escolha Cancelar";
	fazer {
		.@menu = select("Um:Dois:Três:Cancelar");
	} enquanto (.@menu != 4);

Exemplo 2: loop controlado por contador
	mes "Isso fará uma contagem regressiva de 10 a 1.";
	.@i = 10;
	fazer {
		eu .@i;
		.@i -= 1;
	} enquanto (.@i > 0);

---------------------------------------

*freeloop({<alternar>})

Alternar isso para habilitado (1) permite que a instância do script ignore o loop infinito
proteção, permitindo que seu script faça um loop tanto quanto for necessário. Desabilitar (0) irá
avisá-lo se um loop infinito for detectado.

O comando retornará o estado do freeloop para o script anexado, mesmo que não haja
argumento é fornecido.

Exemplo:
	freeloop(1); // permite que o script faça um loop livremente

	// tenha cuidado com o que você faz aqui
	para ( .@i = 0; .@i < .@bigloop; .@i++ ) {
		faça isso;
		// colocará o script em espera por 1 ms quando detectar um loop infinito
		// deixe o brHades fazer o que precisa fazer (socket, timer, processo, etc.)
	}

	freeloop(0); // desabilitar freeloop

	para ( .@i = 0; .@i < .@bigloop; .@i++ ) {
		faça isso;
		// lança um erro de loop infinito
	}

---------------------------------------

*setarray <nome do array>[<primeiro valor>],<valor>{,<valor>...<valor>};

Este comando permitirá que você preencha rapidamente um array de uma só vez. Verifique o
Scripts Kafra na distribuição para ver isso é muito usado.

    setray .@array[0], 100, 200, 300, 400, 500, 600;

O primeiro valor é o índice do primeiro elemento da matriz a ser alterado. Para
exemplo:

    setarray .@array[0],200,200,200;
    setarray .@array[1],300,150;

produzirá:

.@matriz[0]=200
.@matriz[1]=300
.@matriz[2]=150

---------------------------------------

*cleararray <nome do array>[<primeiro valor a ser alterado>],<valor>,<número de valores a serem definidos>;

Este comando alterará muitos valores de matriz ao mesmo tempo para o mesmo valor.

    setray .@array[0], 100, 200, 300, 400, 500, 600;
    // Isso fará com que todos os 6 valores sejam 0
    limparmatriz .@matriz[0],0,6;
    // Isso fará com que o elemento 0 do array mude para 245
    limparmatriz .@matriz[0],245,1;
    // Isso fará com que os elementos 1 e 2 mudem para 345
    limparmatriz .@matriz[1],345,2;

Veja 'setarray'.

---------------------------------------

*copyarray <matriz de destino>[<primeiro valor>],<matriz de origem>[<primeiro valor>],<quantidade de dados a serem copiados>;

Este comando permite que você embaralhe rapidamente uma grande quantidade de dados entre matrizes, o que está em
alguns casos inestimáveis.

    setray .@array[0], 100, 200, 300, 400, 500, 600;
    // Então fizemos .@array[]
    copiarmatriz .@matriz2[0],@matriz[2],2;

    // Agora, .@array2[0] será igual a .@array[2] (300) e
    // .@array2[1] será igual a .@array[3].

Então, usando os exemplos acima:
.@matriz[0] = 100
.@matriz[1] = 200
.@matriz[2] = 300
.@matriz[3] = 400
.@matriz[4] = 500
.@matriz[5] = 600

Nova Matriz:
.@matriz2[0] = 300
.@matriz2[1] = 400
.@matriz2[2] = 0
.@matriz2[3] = 0

Observe que .@array[4] e .@array[5] não serão copiados para o segundo array e retornarão um
0.

---------------------------------------

*deletearray <nome do array>[<primeiro valor>]{,<quanto excluir>};

Este comando excluirá totalmente um número especificado de elementos de uma matriz
matriz, deslocando todos os elementos além disso para o início.

    // Isso excluirá o elemento 0 da matriz e moverá todos os outros elementos da matriz
    // uma posição acima.
    excluirmatriz .@matriz[0],1

// Isso excluiria os elementos da matriz numerados 1, 2 e 3, deixando o elemento 0 em seu
// coloque e mova os outros elementos para cima, para que não haja espaços.

    excluirmatriz .@matriz[1],3

---------------------------------------

*inarray <nome do array>,<valor>;

Este comando retorna o índice do primeiro valor correspondente encontrado na matriz.
Retornará -1 se o valor não for encontrado.

	setray .@array[0], 100, 200, 300, 400, 500, 600, 100;
	
	inarray(.@array[0], 200);
	//retorna 1 porque 200 está no índice 1
	//outra maneira de dizer isso é .@array[1] == 200
	
	.@index = inarray(.@array[0], 600);
	//.@index agora é 5 porque .@array[5] == 600
	
	inarray(.@array[0], 100);
	//enquanto o índice 6 também é 100, o comando retornará a primeira instância que encontrar
	//retorna 0 porque .@array[0] == 100

	inarray(.@array[0], 800);
	//retorna -1 porque 800 não é um elemento do array .@array

Para mais detalhes, veja o exemplo em 'doc/sample/inarray.txt'.

---------------------------------------

*countinarray <nome do array>{[<índice inicial>]},<nome do array>{[<índice inicial>]};

Este comando verificará se há correspondências entre os valores da matriz e retornará o número de correspondências.
Embora seja opcional, se [<índice inicial>] for fornecido, a pesquisa começará a partir do valor de índice fornecido.

	setray .@array[0], 100, 200, 300, 400, 500, 600;
	
	.@variável = 100;
	se(contarmatriz(.@matriz[0], .@variável))
		mes "O número 100 foi encontrado no array .@array";
	
	countinarray(.@array[0], .@variável);
	//retorna 1 porque o número 100 é um elemento do array .@array
	
	setarray .@array2[0],100,500;
	countinarray(.@array[0], .@array2[0]);
	//retorna 2 porque os números 100 e 500 são elementos do array .@array
	
	set matriz .@array3[0],100,700;
	countinarray(.@array[0], .@array3[0]);
	//retorna 1 porque o número 100 é um elemento do array .@array
	//mas o número 700 não é um elemento do array .@array

	//você também pode alterar a posição entre as matrizes no comando
	se(contarray(.@array[0], .@array3[0]) == contarray(.@array3[0], .@array[0]))
		//Isto é verdade

Para mais detalhes, veja o exemplo em 'doc/sample/inarray.txt'.

---------------------------------------

======================================
|2.- Comandos de recuperação de informações.|
======================================
---------------------------------------

*strcharinfo(<tipo>{,<id_char>})

Esta função retornará o nome, o nome do grupo ou o nome da guilda para o
invocando o caractere. O que ele retorna é determinado pelo tipo.

0 - Nome do personagem.
1 - O nome do partido em que estão, se houver.
2 - O nome da guilda em que estão, se houver.
3 - O nome do mapa em que o personagem está.

Se um personagem não for membro de nenhum grupo ou guilda, uma string vazia será exibida.
retornado ao solicitar essas informações.

---------------------------------------

*convertpcinfo(<id_char>,<tipo>)
*convertpcinfo(<id_da_conta>,<tipo>)
*convertpcinfo(<nome_do_jogador>,<tipo>)

Esta função retornará a informação <tipo> para o
caractere especificado. O que quer que ele retorne é determinado pelo tipo.

CPC_NAME - Nome do personagem.
CPC_CHAR - ID do personagem.
CPC_ACCOUNT - ID da conta.

Se um personagem não for encontrado (ou não estiver online) ao solicitar essa informação,
uma string vazia será retornada para CPC_NAME, 0 para outros <tipo>.

---------------------------------------

*strnpcinfo(<tipo>)

Esta função retornará as várias partes do nome do NPC que fez a chamada.
O que ele retorna é determinado pelo tipo.

0 - Nome de exibição do NPC (visível#oculto)
1 - A parte visível do nome de exibição do NPC
2 - A parte oculta do nome de exibição do NPC
3 - Nome único do NPC (::nome)
4 - O nome do mapa em que o NPC está.

---------------------------------------

*getarraysize(<nome do array>)

Esta função retorna o maior índice do array que está preenchido.
Observe que zeros e strings vazias no final desta matriz não são
contados para esse número.

Por exemplo:

    setray .@array[0], 100, 200, 300, 400, 500, 600;
    set .@arraysize,getarraysize(.@array);

Isso fará com que .@arraysize == 6. Mas se você tentar isto:

    setarray .@array[0], 100, 200, 300, 400, 500, 600, 0;
    set .@arraysize,getarraysize(.@array);

.@arraysize ainda será igual a 6, mesmo que você tenha definido 7 valores.

---------------------------------------

*getelementofarray(<nome do array>,<índice>)

Este comando recupera o valor do elemento de uma determinada matriz no índice fornecido.
Isso é equivalente a usar:

    <nome da matriz>[<índice>]

A razão para isso é que esta forma curta é internamente convertida em uma chamada
para getelementofarray, quando o script é carregado.

Também é útil ao passar matrizes para funções ou acessar matrizes de outro NPC:
    getelementofarray(getarg(0),<índice>)
    getelementofarray(getvariableofnpc(.var, "testNPC"),<índice>)

---------------------------------------

*readparam(<número do parâmetro>{,"<nome do personagem>"})
*readparam(<número do parâmetro>{,<char_id>})

Esta função retornará a estatística especificada do caractere invocador ou, se um
nome do personagem ou id do personagem é especificado, daquele jogador. A estatística pode
seja um número ou nome de parâmetro, definido em 'src/map/script_constants.hpp'.

Alguns parâmetros de exemplo:

StatusPoint, BaseLevel, SkillPoint, Classe, Superior, Zeny, Sexo, Peso, MaxWeight,
JobLevel, BaseExp, JobExp, Próxima BaseExp, Próxima JobExp, Hp, MaxHp, Sp, MaxSp,
BaseJob, Karma, Maneira, bVit, bDex, bAgi, bStr, bInt, bLuk, Ap, MaxAp

Todas elas também se comportam como variáveis, mas não espere poder simplesmente 'set'
eles - alguns não funcionarão por vários motivos internos.

Exemplo 1:

    // Retorna quantos pontos de status você ainda não gastou.
    mes "Pontos de status não utilizados: " + readparam(9);

Não é necessário usar essas informações específicas como uma chamada de função. Digitando isso
retornará o mesmo resultado:

    mes "Pontos de status não utilizados: " + StatusPoint;

Exemplo 2:

Você também pode usar este comando para obter valores estatísticos.

    if (readparam(bVit) > 77)
        mes "Somente pessoas com mais de 77 Vit estão lendo isso!";

---------------------------------------

*getcharid(<tipo>{,"<nome do personagem>"})

Esta função retornará um número de identificação exclusivo do caractere de chamada ou, se for um
o nome do personagem é especificado, daquele jogador.

Tipo é o tipo de número de ID associado necessário:

0 - ID do personagem
1 - Identificação da parte
2 - ID da guilda
3 - ID da conta
4 - ID do campo de batalha
5 - ID do clã

Para a maioria dos propósitos que não sejam impressão, é melhor ter um número do que um nome
(as pessoas fazem coisas horríveis com os nomes dos seus personagens).

Se o personagem não estiver em um grupo ou em uma guilda, a função retornará 0
se o número da guilda ou do grupo for solicitado. Se um nome for especificado e o personagem
não for encontrado, 0 será retornado.

Se getcharid(0) retornar zero, o script não foi chamado por um caractere e
não tem um RID anexado. Observe que isso fará com que o servidor de mapas
imprima mensagens de erro "player not attached!", por isso é preferível usar
"playerattached" para verificar o personagem anexado ao script.

if (getcharid(2) == 0)
	mes "Somente membros de uma guilda são permitidos aqui!";

---------------------------------------

*getnpcid(<tipo>{,"<nome do npc>"});

Recupera IDs do NPC atualmente invocado. Se um nome de npc exclusivo for
dado, os IDs desse NPC são recuperados em vez disso. O tipo especifica qual ID
para recuperar e pode ser um dos seguintes:

    0 - ID do jogo NPC

Se um tipo inválido for fornecido ou o NPC não existir, 0 será retornado.

---------------------------------------

*obteridcriança({<id_char>})
*obteridmãe({<id_char>})
*obteridpai({<id_char>})

Essas funções retornam o ID do personagem do filho do jogador anexado,
mãe, mãe ou pai, respectivamente. Retorna 0 se nenhum ID for encontrado.

    if (getmotherid()) mes "O ID da sua mãe é: " + getmotherid();

---------------------------------------

*éparceiro({<id_char>})

Esta função retorna 1 se o parceiro de casamento do personagem que faz a invocação for
atualmente online e 0 se não estiverem ou se o personagem não tiver parceiro.

---------------------------------------

*obteridparceiro({<id_char>})

Esta função retorna o ID do personagem do casamento do personagem que faz a chamada
parceiro, se houver. Se o personagem invocador não for casado, ele retornará 0,
que é uma maneira rápida de ver se eles são casados:

    if (getpartnerid()) mes "Eu não vou ser sua namorada!";
    if (getpartnerid()) mes "Você já é casado!";

---------------------------------------

*getlook(<tipo>{,<id_char>})

Esta função retornará o número para o valor de aparência do caractere atual
especificado por tipo. Veja 'setlook' para tipos de aparência válidos.

Isso pode ser usado para fazer com que um determinado script se comporte de forma diferente para os personagens
vestida de preto.

---------------------------------------

*getsavepoint(<tipo de informação>{,<char_id>})

Esta função retornará informações sobre o ponto de salvamento do personagem que o invoca.
Você pode usá-lo para permitir que um personagem troque entre vários pontos de salvamento gravados.
Os tipos de informações disponíveis são:

0 - Nome do mapa (uma string)
1 - Coordenada X
2 - Coordenada Y

---------------------------------------

*getcharip({"<nome do personagem>"|<id da conta>|<id do personagem>})

Esta função retornará o endereço IP do personagem que invoca ou, se for um jogador
é especificado, daquele personagem. Uma string em branco é retornada se nenhum jogador estiver anexado.

Exemplos:

// Exibe o endereço IP do player conectado.
	mes "Seu IP: " + getcharip();

// Exibe o endereço IP do personagem "Silver".
	mes "IP de Silver: " + getcharip("Silver");

---------------------------------------

*vip_status(<tipo>,{"<nome do personagem>"})

Retorna várias informações sobre o status VIP de um jogador.

Tipos válidos:
VIP_STATUS_ACTIVE - Status VIP: verdadeiro se o jogador for VIP ou falso se não for
VIP_STATUS_EXPIRE - Carimbo de data e hora de expiração do VIP se o jogador for VIP ou 0 se não for
VIP_STATUS_REMAINING - Tempo VIP restante em segundos

OBSERVAÇÃO: Este comando só estará disponível se o Sistema VIP estiver habilitado.

---------------------------------------

*vip_time <hora>,{"<nome do personagem>"};

Altera o tempo VIP de um jogador (em minutos). Um valor positivo aumentará o tempo, e um
valor negativo diminuirá o tempo.

OBSERVAÇÃO: Este comando só estará disponível se o Sistema VIP estiver habilitado.

---------------------------------------

*addspiritball <contagem>,<duração>{,<char_id>};

Adiciona uma bola espiritual ao jogador por "duração" em milissegundos.

---------------------------------------

*delspiritball <contagem>{,<id_char>};

Exclui a(s) bola(s) espiritual(ais) do jogador.

---------------------------------------

*contagemespíritobola {<char_id>};

Conta a bola espiritual que o jogador possui.

---------------------------------------

*ignoretimeout <sinalizador>{,<id_char>};

Desabilita a função SECURE_NPCTIMEOUT no personagem que invoca o script,
ou pelo ID/nome do personagem fornecido.

Bandeira válida:
0 - SECURE_NPCTIMEOUT habilitado.
1 - Desabilite SECURE_NPCTIMEOUT.

Observação: SECURE_NPCTIMEOUT deve estar habilitado para que isso funcione.

---------------------------------------
\\
2,2 Comandos relacionados a itens
\\
---------------------------------------

*getequipid({<slot de equipamento>,<char_id>})

Esta função retorna o ID do item do slot de item que chama o script
no personagem invocador ou no slot de equipamento especificado. Se nada for
equipado lá, ele retorna -1.
Os slots de equipamento válidos são:

EQI_COMPOUND_ON (-1) - Slot de item que chama este script (no contexto do script de item) - exclusivo para getequipid
EQI_ACC_L (0) - Acessório 1
EQI_ACC_R (1) - Acessório 2
EQI_SHOES (2) - Calçados (sapatos, botas)
EQI_GARMENT (3) - Vestuário (silenciosos, capuzes, manteaux)
EQI_HEAD_LOW (4) - Equipamento de cabeça inferior (barbas, algumas máscaras)
EQI_HEAD_MID (5) - Equipamento de cabeça médio (máscaras, óculos)
EQI_HEAD_TOP (6) - Capacete superior
EQI_ARMOR (7) - Armadura (jaquetas, vestes)
EQI_HAND_L (8) - Mão esquerda (armas, escudos)
EQI_HAND_R (9) - Mão direita (armas)
EQI_COSTUME_HEAD_TOP (10) - Chapéu de traje superior
EQI_COSTUME_HEAD_MID (11) - Chapéu de traje médio
EQI_COSTUME_HEAD_LOW (12) - Chapéu de traje inferior
EQI_COSTUME_GARMENT (13) - Traje de fantasia
EQI_AMMO (14) – Flecha/Munição
EQI_SHADOW_ARMOR (15) - Armadura de Sombra
EQI_SHADOW_WEAPON (16) - Arma de Sombra
EQI_SHADOW_SHIELD (17) - Escudo de Sombra
EQI_SHADOW_SHOES (18) - Sapatos de Sombra
EQI_SHADOW_ACC_R (19) - Acessório de sombra 2
EQI_SHADOW_ACC_L (20) - Acessório de sombra 1

Observe que alguns itens ocupam vários espaços de equipamento e, se o personagem estiver
usando tal item, 'getequipid' retornará seu número de ID para cada slot.

Pode ser usado para verificar se você tem algo equipado ou se não tem
algo equipado:

	if (getequipid(EQI_HEAD_TOP) == 2234)
		mes "Que tiara linda você está usando";
	outro
		mes "Volte quando você estiver com uma tiara";
	close;

Você também pode usá-lo para garantir que as pessoas não passem de um ponto antes de remover um
item totalmente deles. Digamos que você não quer que as pessoas usem Legion Plate
armadura, mas também não quero que eles se equipem se após a verificação, você fizer isso:

	if (getequipid(EQI_ARMOR) == 2341 || getequipid(EQI_ARMOR) == 2342) {
		mes "Você está usando uma armadura de placas da Legião, por favor, coloque-a em seu estoque antes de continuar";
		close;
	}
	// o || é usado como um argumento ou, há 2341 e 2342 porque há
	// duas armaduras de placas de legião diferentes, uma com uma ranhura e outra sem.

	if (contaritem(2341) > 0 || contaritem(2432) > 0) {
		mes "Você tem alguma armadura de placas da Legião em seu inventário, por favor, coloque-a em seu estoque antes de continuar";
		close;
	}
	mes "Eu vou deixar você passar.";
	close2;
	warp "lugar",50,50;
	end;

---------------------------------------

*getequipuniqueid(<slot de equipamento>{,<char_id>})

Esta função retorna o ID exclusivo (como uma string) do item equipado no slot de equipamento
especificado no caractere invocador. Se nada estiver equipado ali, ele retorna uma string vazia.
Veja 'getequipid' para uma lista completa de slots de equipamentos válidos.

---------------------------------------

*getequipname(<slot de equipamento>{,<char_id>})

Retorna o jname do item equipado no slot de equipamento especificado no
caractere de invocação, ou uma string vazia se nada estiver equipado nessa posição.
Faz a mesma coisa que getitemname(getequipid()). Útil para um NPC declarar
o que você está vestindo, ou talvez salvando como uma variável de string.
Veja 'getequipid' para uma lista completa de slots de equipamentos válidos.

        if ( getequipname(EQI_HEAD_TOP) != "" )
	        mes "Então você está usando um " + getequipname(EQI_HEAD_TOP) + " na sua cabeça";
	outro
	        mes "Você não está usando nenhum equipamento de cabeça";

---------------------------------------

*getitemname(<id do item>)
*getitemname(<nome do item aegis>)

Dado o número de ID do banco de dados de um item, esta função retornará o texto
armazenado no campo 'Nome' em item_db_*.yml para versão de texto
ou campo 'name_english' para versão SQL. A função retorna "null" se o item não existir.

---------------------------------------

*getbrokenid(<número>{,<id_char>})

Esta função pesquisará no inventário do personagem que o invoca em busca de qualquer item quebrado
itens e retornará seus números de ID de item. Como o personagem pode ter
vários itens quebrados, 1 dado como argumento retornará o primeiro encontrado, 2
retornará o segundo, etc. Retornará 0 se nenhum item for encontrado.

	// Vamos ver se eles têm algo quebrado:
	if (getbrokenid(1) == 0)
		mes "Você não tem nada quebrado, pare de me incomodar.";
	outro
	// Eles fazem, então vamos imprimir o nome do primeiro item quebrado:
		mes "Oh, vejo que você tem um " + getitemname(getbrokenid(1)) + " quebrado aqui!";
	end;

---------------------------------------

*getequipisequiped(<slot de equipamento>{,<char_id>})

Esta função retornará 1 se houver um equipamento colocado no local especificado
slot de equipamento e 0 caso contrário. Para uma lista de slots de equipamento
veja 'getequipid'. Função originalmente usada pelos NPCs refinadores:

    if (getequipisequiped(EQI_HEAD_TOP)) {
        mes "[Refinador]";
        mes "Que chapéu lindo você está usando aí...";
        close;
	} outro {
		mes "[Refinador]";
		mes "Você quer que eu refine sua cabeça idiota?";
		close;
	}

---------------------------------------

*getequipisenableref(<slot de equipamento>{,<char_id>})

Retornará 1 se o item estiver equipado no personagem invocador no especificado
slot de equipamento é refinável, e 0 se não for. Para uma lista de slots de equipamento
veja 'getequipid'.

	if (getequipisenableref(EQI_HEAD_TOP)) {
		mes "[Refinador]";
		mes "Ok, posso refinar isso";
		close;
	} outro {
		mes "[Refinador]";
		mes "Não consigo refinar esse chapéu!...";
		close;
	}

---------------------------------------

*getequiprefinerycnt(<slot de equipamento>{,<char_id>})

Retorna o número atual de pontos positivos para o item no equipamento especificado
slot. Para uma lista de slots de equipamento, veja 'getequipid'.

Pode ser usado para verificar se você atingiu um valor máximo de refino, padrão para
isto é +10:

	if (getequiprefinerycnt(EQI_HEAD_TOP) < 10)
		mes "Agora atualizarei seu " + getequipname(EQI_HEAD_TOP);
	outro
		mes "Desculpe, não é possível refinar chapéus melhor que +10";
	close;

---------------------------------------

*getequipweaponlv({<slot de equipamento>{,<char_id>}})

Esta função retorna o nível da arma equipada no local especificado
slot de equipamento no personagem invocador. Para uma lista de slots de equipamento, veja
'obterequipamento'.

Normalmente, apenas EQI_HAND_L e EQI_HAND_R fazem sentido, pois apenas armas têm
um nível de arma.

Se nenhum item estiver equipado neste slot, ou se ele não tiver um nível de arma
de acordo com o banco de dados, 0 será retornado.

Exemplos:

    interruptor (getequipweaponlv(EQI_HAND_R)) {
      caso 1: mes "Você está segurando uma arma de nível 1."; break;
      caso 2: mes "Você está segurando uma arma de nível 2."; break;
      caso 3: mes "Você está segurando uma arma de nível 3."; break;
      caso 4: mes "Você está segurando uma arma de nível 4."; break;
      caso 5: mes "Você está segurando uma arma de nível 5."; break;
      caso 6: mes "Você está segurando uma arma de nível 6, hm, deve ser um design personalizado..."; break;
      default: mes "Parece que você não tem uma arma."; break;
    }

    if (getequipid(EQI_HAND_L) == 0) {
        mes "Parece que você não tem nada equipado aqui.";
        close;
    }
    interruptor (getequipweaponlv(EQI_HAND_L)) {
      caso 0: mes "Você não está segurando uma arma, então ela não tem um nível."; break;
      caso 1: mes "Você está segurando uma arma de nível 1."; break;
      caso 2: mes "Você está segurando uma arma de nível 2."; break;
      caso 3: mes "Você está segurando uma arma de nível 3."; break;
      caso 4: mes "Você está segurando uma arma de nível 4."; break;
      caso 5: mes "Você está segurando uma arma de nível 5."; break;
      caso 6: mes "Você está segurando uma arma de nível 6, hm, deve ser um design personalizado..."; break;
    }

---------------------------------------

*getequiparmorlv({<slot de equipamento>{,<char_id>}})

Esta função retorna o nível de armadura do item equipado no local especificado
slot de equipamento no personagem invocador. Para uma lista de slots de equipamento, veja
'obterequipamento'.

Se nenhum item estiver equipado neste slot, ou se ele não tiver um nível de armadura
de acordo com o banco de dados, 0 será retornado.

    if (getequipid(EQI_ARMOR) == 0) {
        mes "Parece que você não tem nada equipado aqui.";
        close;
    }
    switch (getequiparmorlv(EQI_ARMOR)) {
      caso 1: mes "Você está usando uma armadura de nível 1."; break;
      caso 2: mes "Você está usando uma armadura de nível 2."; break;
      caso 3: mes "Você está usando uma armadura de nível 3, hm, deve ser um design personalizado..."; break;
    }

---------------------------------------

*getequippercentrefinery(<slot de equipamento>{,<enriquecido>,<char_id>})

Esta função calcula e retorna o valor percentual de chance de sucesso
refinar o item encontrado no slot de equipamento especificado do personagem invocador
por +1. Não existe uma fórmula real, a taxa de sucesso para um determinado nível de arma de
um certo nível de refinamento é encontrado no arquivo db/(pre-)re/refine_db.yml. Para uma lista de
slots de equipamento veja 'getequipid'.

Se o parâmetro enriquecido for definido como verdadeiro, há chance de refinar o item com sucesso com
material enriquecido é devolvido em seu lugar.

Esses valores podem ser exibidos para o jogador ver ou usados ​​para calcular o
mudança aleatória de um refinamento bem-sucedido ou malsucedido e, em seguida, prosseguir com ele
(que é para isso que os scripts oficiais de refinaria do NPC o usam)

// Isso encontrará um número aleatório de 0 a 99 e se for igual ou maior
// do que o valor recuperado por este comando irá para L_Fail
    if (getequippercentrefinery(EQI_HAND_L)<=rand(100)) vá para L_Fail;

---------------------------------------

*getequiprefinecost(<slot de equipamento>,<tipo>,<informação>{,<id do caractere>})

Esta função retorna o custo de refino para o equipamento em <slot de equipamento> com base em
argumentos passados ​​<tipo> e <informação>.

Os tipos de custos válidos são:

REFINE_COST_NORMAL - Para refino normal
REFINE_COST_HD - Para refino com minérios HD
REFINE_COST_ENRICHED - Para refino com minérios enriquecidos

Esta função retornará o custo necessário para o refino com base no argumento <information>.

Os tipos de informações válidos são:

REFINAR_ZENY_CUSTO - Zeny
REFINE_MATERIAL_ID - ID do item de material

Esta função retornará -1 em caso de falha. A função falha se o tipo de custo
é inválido ou se não há item no slot de equipamento.

---------------------------------------

*getareadropitem("<nome do mapa>",<x1>,<y1>,<x2>,<y2>,<item>)

Esta função contará todos os itens com o número de ID especificado no
aterrar no mapa especificado dentro do quadrado x1/y1-x2/y2 nele e retornar isso
número.

Esta é a única função em que um parâmetro pode ser uma string ou uma
número! Se for um número, significa que apenas os itens com esse número de ID de item
será contado. Se for uma string, presume-se que significa o 'nome em inglês'
campo do banco de dados de itens.

---------------------------------------

*getequipcardcnt(<slot de equipamento>)

Esta função retornará o número de cartas que foram compostas em um
item equipado específico para o personagem invocador. Veja 'getequipid' para uma lista
de possíveis slots de equipamento.

---------------------------------------

*obterlistadeinventário {<id_char>};

Este comando define um monte de matrizes com uma lista completa de tudo o que
o personagem invocador tem em seu inventário, incluindo todos os dados necessários para
recrie esses itens perfeitamente se eles forem destruídos. Aqui está o que você ganha:

@inventorylist_id[] - matriz de IDs de itens.
@inventorylist_idx[] - matriz de índice de inventário de itens.
@inventorylist_amount[] - seus valores de itens correspondentes.
@inventorylist_equip[] - em qual posição o item está equipado (veja constantes EQP_*)
                                     Ele conterá 0 se o item não estiver equipado.
@inventorylist_refine[] - por quanto ele é refinado.
@inventorylist_identify[] - se está identificado.
@inventorylist_attribute[] - se está quebrado.
@inventorylist_card1[] - Essas quatro matrizes contêm dados de cartão para os itens.
@inventorylist_card2[] Esses slots de dados também são usados ​​para armazenar nomes
@inventorylist_card3[] inscrito nos itens, para que você possa verificar explicitamente
@inventorylist_card4[] se o personagem possui um item feito por um específico
                                     artesão.
@inventorylist_expire[] - tempo de expiração (carimbo de data/hora Unix). 0 significa que nunca expira.
@inventorylist_bound[] - o tipo vinculado dos itens (veja constantes BOUND_*)
@inventorylist_enchantgrade[] - o enchantgrade dos itens
@inventorylist_count - o número de itens nessas listas.
@inventorylist_option_id1[] - primeira matriz de IDs de opções aleatórias
@inventorylist_option_value1[] - primeira matriz de valores de opções aleatórios
@inventorylist_option_parameter1[] - primeira matriz de parâmetros de opção aleatórios
@inventorylist_option_id2[] - segunda matriz de IDs de opções aleatórias
@inventorylist_option_value2[] - segunda matriz de valores de opções aleatórios
@inventorylist_option_parameter2[] - segunda matriz de parâmetros de opção aleatórios
@inventorylist_option_id3[] - terceira matriz de IDs de opções aleatórias
@inventorylist_option_value3[] - terceira matriz de valores de opções aleatórios
@inventorylist_option_parameter3[] - terceira matriz de parâmetros de opção aleatórios
@inventorylist_option_id4[] - quarta matriz de IDs de opções aleatórias
@inventorylist_option_value4[] - quarta matriz de valores de opções aleatórios
@inventorylist_option_parameter4[] - quarta matriz de parâmetros de opção aleatórios
@inventorylist_option_id5[] - quinta matriz de IDs de opções aleatórias
@inventorylist_option_value5[] - quinta matriz de valores de opções aleatórios
@inventorylist_option_parameter5[] - quinta matriz de parâmetros de opção aleatórios
@inventorylist_tradable - Retorna se um item é negociável ou não (passa item_db.yml, bound e restrições de aluguel).
@inventorylist_favorite - Retorna se um item é favorito ou não

Isso pode ser útil para salvar/restaurar o inventário de um personagem, já que nenhum outro
comando retorna um conjunto completo de dados e também pode ser a única maneira de
lidar corretamente com um comerciante NPC para itens com cartão e nome que poderia revendê-los
- já que os objetos NPC não podem possuir itens, eles precisam armazenar dados dos itens em
variáveis ​​e recriar os itens.

Observe que as variáveis ​​geradas por este comando são todas temporárias, anexadas a
o caractere e o inteiro.

Certifique-se de usar @inventorylist_count para percorrer essas matrizes, e não
'getarraysize', porque as matrizes não são limpas automaticamente entre as execuções
de 'getinventorylist'.

---------------------------------------

*cartõescnt()

Esta função retornará o número de cartões inseridos no equipamento
a partir do qual a função é chamada.

Esta função deve ser usada em scripts de itens.

---------------------------------------

*obterrefinamento()

Esta função retornará a contagem refinada do equipamento do qual o
a função é chamada.

Esta função deve ser usada em scripts de itens.

---------------------------------------

*getnameditem(<id do item>,"<nome a ser inscrito>"|<id do caractere>);
*getnameditem("<nome do item>","<nome a ser inscrito>"|<id do caractere>);

Esta função é equivalente a usar 'getitem', no entanto, ela não fornecerá apenas
o personagem é um objeto de item, mas também irá inscrevê-lo com um especificado
nome do personagem. Você não pode inscrever itens com strings arbitrárias, apenas com
nomes de personagens que realmente existem. Embora isso não seja dito em lugar nenhum
especificamente, aparentemente, itens nomeados podem não ter cartas, slots ou não -
esses slots de dados são ocupados pelo ID do personagem cujo nome está inscrito. Apenas um
continua livre e não está muito claro se um cartão pode estar lá.

Esta função retornará 1 se um item foi criado com sucesso e 0 se ele
não foi por qualquer razão. Como 'getitem', esta função também aceitará um
'nome em inglês' do banco de dados do item como um nome de item e retornará 0 se não
tal item existe.

---------------------------------------

*getitemslots(<ID do item>)

Esta função irá procurar o item com o número de ID especificado no banco de dados
e retornar o número de slots que esse tipo de item possui - 0 se não forem
com fenda. Também será 0 para todos os itens não equipáveis, naturalmente, a menos que
alguém bagunçou o banco de dados de itens. Ele retornará -1 se não houver tal item.

Exemplo:

//.@slots agora tem a quantidade de slots do item com ID 1205.
	.@slots = obteritenslots(1205);

---------------------------------------

*getiteminfo(<ID do item>,<tipo>)
*getiteminfo(<nome do item>,<tipo>)
*getiteminfo(<nome do item aegis>,<tipo>)

Esta função irá procurar o item com o número de ID especificado no banco de dados
e retornar as informações definidas pelo argumento TYPE.
Ele retornará -1 se não houver tal item ou "" se o nome do item aegis for solicitado.

Os tipos válidos são:
	ITEMINFO_BUY (0) - Preço de compra
	ITEMINFO_SELL (1) - Preço de venda
	ITEMINFO_TYPE (2) - Tipo
	ITEMINFO_MAXCHANCE (3) - maxchance (chance máxima de queda deste item, por exemplo, 1 = 0,01%)
		                        se = 0, então os monstros não o deixam cair (raro ou um item de missão)
		                        se = 10000, então este item é vendido apenas em lojas de NPC
	ITEMINFO_GENDER (4) - Gênero
	ITEMINFO_LOCATIONS (5) - Localização(ões)
	ITEMINFO_WEIGHT (6) - Peso
	ITEMINFO_ATAQUE (7) - ATAQUE
	ITEMINFO_DEFESA (8) - DEF
	ITEMINFO_RANGE (9) - Intervalo
	ITEMINFO_SLOT (10) - Slot
	ITEMINFO_VIEW (11) - Ver
	ITEMINFO_EQUIPLEVELMIN (12) - equipamento LV
	ITEMINFO_WEAPONLEVEL (13) - arma LV
	ITEMINFO_ALIASNAME (14) - Nome do Alias
	ITEMINFO_EQUIPLEVELMAX (15) - equipamento LV Max
	ITEMINFO_MAGICATTACK (16) - matk se RENEWAL for definido
	ITEMINFO_ID (17) - ID do item
	ITEMINFO_AEGISNAME (18) - nome do item aegis
	ITEMINFO_ARMORLEVEL (19) - armadura LV
	ITEMINFO_SUBTYPE (20) - Subtipo

Veja o exemplo em 'doc/sample/getiteminfo.txt'.

---------------------------------------

*getequipcardid(<slot para equipamento>,<slot para cartão>)

Retorna o valor do slot do item equipado no slot indicado (0, 1, 2 ou 3).

Esta função retorna CARD ID, CARD0_FORGE, CARD0_CREATE ou CARD0_PET (para o cartão 0, se o item for produzido).
É útil quando você deseja verificar se um item contém cartões ou se está assinado.

---------------------------------------

*mergeitem({,<id_char>});

Abra a janela de mesclagem de itens para mesclar os itens disponíveis.

Exemplos
1. Veja o NPC 'npc/re/other/merge_item.txt'.
2. Uso simples:
    mes "Vamos verificar se algum item pode ser mesclado.";
    close2;
    mesclar item;
    end;

---------------------------------------

*mergeitem2({<id_item>{,<id_char>}});
*mergeitem2({"<nome do item>"{,<char_id>}});

Mesclar todos os itens empilháveis ​​separados por sinalizadores GUID
(UniqueId em item_db ou em item_group).
Se nenhum ID/nome de item for fornecido, todos os itens possíveis no inventário do jogador serão mesclados.

---------------------------------------

*getequiptradability(<slot de equipamento>{,<id do caractere>});

Retorna verdadeiro se o item em <slot de equipamento> for negociável.
Caso contrário, retorna falso.

---------------------------------------

*identifyall({<tipo>{,<id_da_conta>}});

Retorna a contagem de itens não identificados no inventário do jogador.
Se <type> for verdadeiro, o comando identificará todos os itens não identificados também (padrão).
Se <tipo> for falso, o comando retornará apenas a contagem de itens não identificados.

---------------------------------------

*getenchantgrade({<slot de equipamento>,<char_id>})

Esta função retornará o enchantgrade do equipamento do qual o
a função é chamada ou o slot de equipamento especificado. Se nada for
equipado lá, ele retorna -1.

Os slots de equipamento válidos são:

EQI_COMPOUND_ON - Slot de item que chama este script (no contexto do script de item) (padrão)

Para uma lista de outros slots de equipamento, veja 'getequipid'.

---------------------------------------

*obtertempos()

Esta função retornará a posição do equipamento do qual o
a função é chamada. (veja constantes EQP_*)

Esta função deve ser usada em scripts de itens.

---------------------------------------
//
2,1.- Fim dos comandos relacionados aos itens.
//
---------------------------------------

*getmapxy("<variável para nome do mapa>",<variável para x>,<variável para y>{,<tipo>,"<valor de pesquisa>"})

Esta função localizará as coordenadas de um objeto de personagem, objeto NPC ou animal de estimação
e colocar suas coordenadas nas variáveis ​​especificadas ao chamá-lo.
retornará 0 se a pesquisa foi bem-sucedida e -1 se os parâmetros fornecidos foram
não variáveis ​​ou a busca não foi bem sucedida.

Tipo é o tipo de objeto a ser pesquisado:

	BL_PC - Objeto de personagem (padrão)
	BL_NPC - Objeto NPC
	BL_PET - Objeto de estimação
	BL_HOM - Objeto homúnculo
	BL_MER - Objeto mercenário
	BL_ELEM - Objeto elementar

O valor da pesquisa é opcional. Se não for especificado, a localização do
o caractere de invocação sempre será retornado para os tipos BL_PC e BL_PET,
a localização do NPC executando esta função para o tipo BL_NPC.

Se um valor de pesquisa for especificado, para os tipos BL_PC e BL_NPC, o
personagem ou NPC com o nome ou GID especificado será localizado.

Se o tipo for BL_PET/BL_HOM/BL_MER/BL_ELEM, a pesquisa
localizará o objeto atual do personagem cujo nome/GID é fornecido no
valor de pesquisa, ele NÃO localizará o objeto pelo nome.

Exemplo:

    prontera,164.301,3%TAB%script%TAB%Meh%TAB%730,{
        mes "Meu nome é Meh. Estou aqui para que Nyah possa me encontrar.";
        close;
    }

    prontera,164.299,3%TAB%script%TAB%Nyah%TAB%730,{
        mes "Meu nome é Nyah.";
        mes "Agora vou procurar Meh por todo o mundo!";
        if (getmapxy(.@mapname$, .@mapx, .@mapy, BL_NPC, "Meh") != 0) {
                mes "Não consigo encontrar Meh em lugar nenhum!";
                close;
        }
        mes "E eu o encontrei no mapa " + .@mapname$ + " em X:" + .@mapx + " Y:" + .@mapy + " !";
        close;
   }

Observe que objetos NPC desabilitados com 'disablenpc' ainda serão localizados.

---------------------------------------

*mapid2name(<ID do mapa>)

Retorna o nome do mapa do ID do mapa fornecido. Retorna uma string vazia se fornecido
ID do mapa não existe.

---------------------------------------

*getgmlevel({<id_char>})

Esta função retornará o nível (GM) associado ao grupo de jogadores ao qual
o caractere invocador pertence. Se isso for executado de alguma forma a partir de um comando de console,
99 será retornado, e 0 será retornado se a conta não tiver nível de GM.

Isso permite que você torne os NPCs acessíveis apenas para certos níveis de GM ou se comportem
especialmente quando conversado por Mestres.

   if (getgmlevel()) mes "Qual é o seu comando, sua divindade?";

---------------------------------------

*obteridgrupo({<id_caractere>})

Esta função retornará o ID do grupo ao qual o jogador que faz a chamada pertence.

---------------------------------------

*gettimetick(<tipo de tique>)

Esta função retornará um tique dependendo do <tipo de tique>:
0: O tique do servidor, uma medida em milissegundos usada pelo cronômetro do servidor
    sistema. Este tick é um unsigned int que faz um loop a cada ~50 dias.
1: O tempo, em segundos, desde o início do dia atual.
2: O tempo do sistema em UNIX epoch time, ou o número de segundos decorridos desde
    1º de janeiro de 1970. Útil para medir intervalos de tempo de forma confiável.

---------------------------------------

*gettime(<tipo>)

Esta função retornará informações especificadas sobre a hora atual do sistema.

DT_SECOND - Segundos (do minuto atual)
DT_MINUTE - Minutos (da hora atual)
DT_HOUR - Hora (do dia atual)
DT_DAYOFWEEK - Dia da semana (constantes para SEGUNDA a DOMINGO estão disponíveis)
DT_DAYOFMONTH - Dia do mês atual
DT_MONTH - Mês (constantes de JANEIRO a DEZEMBRO estão disponíveis)
DT_YEAR - Ano
DT_DAYOFYEAR - Dia do ano
DT_AAAAMMDD - data atual no formato AAAAMMDD

Ele retornará apenas números. Se outro tipo for fornecido, -1 será retornado.

	if (gettime(DT_DAYOFWEEK) == SATURDAY) mes "É sábado. Eu não trabalho aos sábados.";

---------------------------------------

*gettimestr(<"formato de hora">,<comprimento máximo>{,<time_tick>})

Esta função retornará uma string contendo dados de tempo conforme especificado pelo
formato de hora.

Isto usa a função C 'strfmtime', que obedece a caracteres de formato especial. Para
uma descrição completa veja, por exemplo, a descrição de 'strfmtime' em
http://www.delorie.com/gnu/docs/glibc/libc_437.html
Todos os caracteres de formato fornecidos ali devem funcionar corretamente.
Comprimento máximo é o comprimento máximo de uma sequência de tempo a ser gerada.

O exemplo dado nos scripts de amostra do brHades funciona assim:

  mes gettimestr("%Y-%m/%d %H:%M:%S",21);

O exemplo acima imprimirá a data e hora atuais como 'AAAA-MM/DD HH:MM:SS'.
O exemplo a seguir imprimirá a data e a hora em que o status VIP do jogador
expira no <time_tick> fornecido:

  mes gettimestr("%Y-%m/%d %H:%M:%S",21,vip_status(VIP_STATUS_EXPIRE));

---------------------------------------

*getusers(<tipo>)

Esta função retornará um número de usuários em um mapa ou o servidor inteiro. O que
ele retorna é especificado por Tipo.

O tipo pode ser um dos seguintes valores, que controlam o que será retornado:

    0 - Contagem de todos os caracteres no mapa do personagem invocador.
    1 - Contagem de todos os personagens em todo o servidor.
    8 - Contagem de todos os personagens do mapa do NPC que o script está
        correndo para dentro.

---------------------------------------

*getmapusers("<nome do mapa>")

Esta função retornará o número de usuários atualmente localizados no local especificado
mapa.

Isso é usado oficialmente em scripts PVP para verificar se uma sala está lotada.

---------------------------------------

*getareausers("<nome do mapa>",<x1>,<y1>,<x2>,<y2>)

Esta função retornará a contagem de caracteres conectados que estão localizados
dentro da área especificada - um quadrado x1/y1-x2/y2 no mapa especificado.

Isso é útil para mapas que são divididos em muitos edifícios, como todos os
"*_in" mapas, devido a todas as lojas e casas.

---------------------------------------

*getunits(<tipo>{,<variável_matriz>[<primeiro valor>]})
*getmapunits(<tipo>,<"nome do mapa">{,<variável_de_matriz>[<primeiro valor>]})
*getareaunits(<tipo>,<"nome do mapa">,<x1>,<y1>,<x2>,<y2>{,<variável_de_matriz>[<primeiro valor>]})

O comando 'getunits' retornará o número de objetos <type> ativos no servidor.

O comando 'getmapunits' retornará o número de objetos <tipo> ativos no
especificou <"nome do mapa">.

O comando 'getareaunits' retornará o número de objetos <tipo> localizados ativamente
dentro da área especificada onde <x1>, <y1>, <x2>, <y2> formam a área.

Tipo é o tipo de objeto a ser pesquisado:

	BL_PC - Objetos de personagem
	BL_MOB - Objetos monstro
	BL_PET - Objetos de estimação
	BL_HOM - Objetos homúnculos
	BL_MER - Objetos mercenários
	BL_NPC - Objetos NPC
	BL_ELEM - Objetos elementares

Se <variável_de_matriz> for fornecido:
	- Uma variável int retornará a lista de GID.
	- Uma variável de string retornará a lista de nomes.

Exemplo 1:
	// obtendo a contagem de jogadores e construindo uma matriz de strings com os nomes.
	.@num = getunidades(BL_PC,.@array$[0]);

	mes "o número de usuários conectados ao servidor é " + .@num + " .";
	mes "lista de nomes de jogadores:";
	freeloop(1); // para caso a lista seja muito grande.
	for(.@i=0;.@i<getarraysize(.@array$);.@i++)
		mes (.@i + 1) + " " + .@array$[.@i];
	loop livre(0);
	end;

Exemplo 2:
	// obtendo a contagem de npc em Prontera e construindo uma matriz de strings dos nomes.
	.@num = getmapunits(BL_NPC,"prontera",.@array$[0]);

	mes "o número de NPCs em Prontera é " + .@num + " .";
	mes "lista de nomes de NPCs :";
	freeloop(1); // para caso a lista seja muito grande.
	for(.@i=0;.@i<getarraysize(.@array$);.@i++)
		mes (.@i + 1) + " " + .@array$[.@i];
	loop livre(0);
	end;

Exemplo 3:
	// obtendo a contagem de monstros em Prontera com coordenadas específicas e construindo uma matriz int dos GIDs.
	.@num = getareaunits(BL_MOB,"prontera",154.186.159.182,.@array[0]);

	mes "o número de monstros em Prontera nessas coordenadas é " + .@num + " .";
	mes "lista de monstros GID :";
	freeloop(1); // para caso a lista seja muito grande.
	for(.@i=0;.@i<getarraysize(.@array);.@i++)
		mes (.@i + 1) + " " + .@array[.@i];
	loop livre(0);
	end;

---------------------------------------
\\
2,2.- Comandos relacionados à guilda
\\
---------------------------------------

*getguildname(<id da guilda>)

Esta função retorna o nome de uma guilda dado um número de ID. Se não houver tal
guild, "null" será retornado.

Exemplo:
	mes "A guilda " + getguildname(10007) + " são todas pessoas legais.";

---------------------------------------

*getguildmember <id da guilda>{,<tipo>{,<variável_de_matriz>}};

Este comando encontrará todos os membros de uma guilda especificada e retornará seus nomes
(ou id do personagem ou id da conta dependendo do valor de "tipo") em uma matriz
de variáveis ​​globais temporárias.

Ao executar isso,

$@guildmembername$[] é uma matriz de strings temporária global que contém todos os
                     nomes dos membros da guilda.
                     (definido somente quando o tipo é 0 ou não especificado)

$@guildmembercid[] é uma matriz numérica temporária global que contém o
                     ID do personagem desses membros da guilda.
                     (definido somente quando o tipo é 1)

$@guildmemberaid[] é uma matriz numérica temporária global que contém o
                     ID da conta desses membros da guilda.
                     (definido somente quando o tipo é 2)

$@guildmembercount é o número de membros da guilda que foram encontrados.

Os membros da guilda serão encontrados independentemente de estarem online ou offline.
Observe que os nomes não aparecem em nenhuma ordem específica.

Certifique-se de usar $@guildmembercount para percorrer esta matriz, e não
'getarraysize', porque não é limpo entre execuções de 'getguildmember'.

Se 'array_variable' for definido, o resultado será armazenado nessa variável
usando variável global.

Para exemplos de uso, consulte 'getpartymember'.

---------------------------------------

*getguildmaster(<id da guilda>)

Esta função retorna o nome do mestre da guilda que possui o especificado
Número de ID. Se não houver tal guilda, "null" será retornado.

Exemplo 1:
	// Imprime o mestre da guilda 10007, seja quem for.
	mes getguildmaster(10007) + " runs " + getguildname(10007);

Exemplo 2:
	// Verifica se o personagem é o mestre da guilda especificada.
	.@GID = getcharid(2);
	if (.@GID == 0) {
		mes "Desculpe, você não está em uma guilda.";
		close;
	}
	if (strcharinfo(0) != getguildmaster(.@GID)) {
		mes "Desculpe, você não é dono da guilda em que está.";
		close;
	}
	mes "Bem-vindo, mestre da guilda de " + getguildname(.@GID);
	close;

---------------------------------------

*getguildmasterid(<id da guilda>)

Esta função retornará o número de identificação do personagem do mestre da guilda
guilda especificada pelo ID. 0 se o personagem não for um mestre de guilda de nenhuma guilda.

---------------------------------------

*is_guild_leader({<ID da guilda>})

Este comando retornará verdadeiro se o jogador anexado ao script for o líder
da sua guilda, ou, se um ID de guilda for especificado, daquela guilda.

---------------------------------------

*getcastlename("<nome do mapa>")

Esta função retorna o nome do castelo quando é fornecido o nome do mapa para esse castelo.
castelo. Os dados são lidos de 'db/castle_db.yml'.

---------------------------------------

*getcastledata("<nome do mapa>",<tipo de dado>)
*setcastledata "<nome do mapa>",<tipo de dado>,<valor>;

Esta função retorna as informações de propriedade do castelo para o castelo referenciado
para pelo nome do mapa. As informações do castelo são armazenadas na tabela SQL `guild_castle`.

Os tipos de dados correspondem às colunas da tabela `guild_castle`:

CD_GUILD_ID - ID da guilda.
CD_CURRENT_ECONOMY - Pontuação da Economia do Castelo.
CD_CURRENT_DEFENSE - Pontuação de Defesa do Castelo.
CD_INVESTED_ECONOMY - Número de vezes que a economia foi investida hoje.
CD_INVESTED_DEFENSE - Número de vezes que a defesa foi investida hoje.
CD_NEXT_TIME - não utilizado
CD_PAY_TIME - não utilizado
CD_CREATE_TIME - não utilizado
CD_ENABLED_KAFRA - É 1 se um Kafra foi contratado para este castelo, 0 caso contrário.
CD_ENABLED_GUARDIAN0 - É 1 se o 1º guardião estiver presente (Soldado Guardião)
CD_ENABLED_GUARDIAN1 - É 1 se o 2º guardião estiver presente (Soldado Guardião)
CD_ENABLED_GUARDIAN2 - É 1 se o 3º guardião estiver presente (Soldado Guardião)
CD_ENABLED_GUARDIAN3 - É 1 se o 4º guardião estiver presente (Archer Guardian)
CD_ENABLED_GUARDIAN4 - É 1 se o 5º guardião estiver presente (Archer Guardian)
CD_ENABLED_GUARDIAN5 - É 1 se o 6º guardião estiver presente (Cavaleiro Guardião)
CD_ENABLED_GUARDIAN6 - É 1 se o 7º guardião estiver presente (Cavaleiro Guardião)
CD_ENABLED_GUARDIAN7 - É 1 se o 8º guardião estiver presente (Cavaleiro Guardião)

Todos os tipos de dados têm seu significado determinado pelos scripts da Guerra do Emperium,
com exceção de:
- CD_GUILD_ID que é sempre considerado o ID da guilda dona do castelo,
- CD_CURRENT_DEFENSE que é usado nos cálculos de HP dos Guardiões e do Emperium,
- CD_ENABLED_GUARDIANX que é sempre considerado como detentor de bits de presença do guardião.

O comando 'setcastledata' se comportará de forma idêntica, mas em vez de retornar
valores para os tipos especificados de dados acessíveis, ele os alterará e causará
para que sejam enviados ao servidor char para armazenamento.

Alterar o ID da guilda ou a defesa do castelo desencadeará ações adicionais, como
recalculando o HP dos guardiões.

---------------------------------------

*getgdskilllv(<id da guilda>,<id da habilidade>)
*getgdskilllv(<id da guilda>,"<nome da habilidade>")

Esta função retorna o nível da habilidade <id da habilidade> da guilda <id da guilda>.
Se a guilda não tiver essa habilidade, 0 será retornado.
Se a guilda não existir, -1 será retornado.
Consulte 'db/(pre-)re/skill_db.yml' para obter a lista completa de habilidades. (GD_* são habilidades de guilda)

---------------------------------------

*requestguildinfo <id da guilda>{,"<rótulo do evento>"};

Este comando solicita os dados da guilda do servidor char e continua alegremente
com a execução. Sempre que as informações da guilda estiverem disponíveis (o que
acontece instantaneamente se as informações da guilda já estiverem na memória, ou mais tarde, se
não é e o servidor de mapas tem que esperar a resposta do servidor de char) ele será executado
o evento especificado como em uma chamada 'donpcevent'.

---------------------------------------

*getmapguildusers("<nome do mapa>",<id da guilda>)

Retorna a quantidade de personagens da guilda especificada no mapa fornecido.

Exemplo:

mes "Você tem " + getMapGuildUsers("prontera",getcharid(2)) + " membros da guilda em Prontera.";

---------------------------------------
//
2,2.- Fim dos comandos relacionados à guilda
//
---------------------------------------

*getskilllv(<id da habilidade>)
*getskilllv("<nome da habilidade>")

Esta função retorna o nível da habilidade especificada que a invocadora
personagem tem. Se eles não tiverem a habilidade, 0 será retornado. A lista completa
de habilidades de personagens está disponível em 'db/(pre-)re/skill_db.yml'.

Existem dois usos principais para esta função: ela pode verificar se o caractere
tem uma habilidade ou não, e pode dizer se o nível é alto o suficiente.

Exemplo 1:
	if (getskilllv(152))
		mes "Você tem a habilidade de Atirar Pedra";
	outro
		mes "Você não tem Throw Stone";
	close;

Exemplo 2:
	if (getskilllv(28) >= 5)
		mes "Seu nível de cura é 5 ou mais";
	else if (getskilllv(28) == 10)
		mes "Seu nível de cura foi maximizado";
	outro
		mes "Sua habilidade de cura está abaixo do nível 5";
	close;

---------------------------------------

*getskilllist({<id_char>});

Este comando define um conjunto de matrizes com uma lista completa de habilidades
invocando o personagem tem. Aqui está o que você obtém:

@skilllist_id[] - IDs de habilidades.
@skilllist_lv[] - níveis de habilidade.
@skilllist_flag[] - veja 'skill' para o significado dos sinalizadores de habilidade.
@skilllist_count - número de habilidades nas matrizes acima.

Embora 'getskillv' seja provavelmente mais útil para a maioria das situações, esta é a
maneira mais fácil de armazenar todas as habilidades e fazer do personagem algo diferente para um
enquanto. Trabalho avançado por um dia? Isso também pode ser útil para ver quantos
habilidades que um personagem possui.

Este comando não conta habilidades definidas como sinalizador 4 (permanentemente concedida) (ALL_BUYING_STORE/ALL_INCCARRY)

---------------------------------------

*getrandmobid(<tipo>{,<flag>{,<nível>}})

Este comando retorna um ID de monstro aleatório do grupo de monstros aleatório.
Com <flag> você pode aplicar certas restrições sobre quais monstros do grupo podem ser retornados.
Retorna 0 se um dos parâmetros for inválido ou nenhum monstro puder ser encontrado com os parâmetros fornecidos.

<tipo> válidos são:
	MOBG_RAMO_DE_ÁRVORE_MORTA
	CAIXA_DE_PORAGEM_MOBG
	MOBG_GALHO_MORTO_SANGRENTO
	MOBG_BOLSA_VERMELHA_DE_SURPRESA
	MOBG_CLASSCHANGE
	MOBG_TAEKWON_MISSÃO
	
<flag> válidos são:
	RMF_NONE = 0x00 - Não aplicar sinalizadores
	RMF_DB_RATE = 0x01 - Aplique a chance de sucesso de invocação encontrada na lista (caso contrário, pegue qualquer monstro do banco de dados)
	RMF_CHECK_MOB_LV = 0x02 - Aplicar uma verificação de nível de monstro
	RMF_MOB_NOT_BOSS = 0x04 - O monstro selecionado não deve ser do tipo Boss (padrão)
	                           - (exceto aqueles de MOBG_BLOODY_DEAD_BRANCH)
	RMF_MOB_NOT_SPAWN = 0x08 - O monstro selecionado deve ter spawn normal
	RMF_MOB_NOT_PLANT = 0x10 - O monstro selecionado não deve ser do tipo Planta
	RMF_ALL = 0xFF - Aplicar todos os sinalizadores
	
---------------------------------------

*getmonsterinfo(<ID do mob>,<tipo>)
*getmonsterinfo(<nome do mob>,<tipo>)

Esta função irá procurar o monstro com o <ID do mob> ou <nome do mob> especificado no
banco de dados mob e retornar as informações definidas pelo argumento <tipo>.
Ele retornará -1 se não houver tal monstro (ou o valor do tipo for inválido),
ou "null" se você solicitou o nome do monstro.

Os tipos válidos são:
	MOB_NAME - nome japonês do monstro, se não houver tal monster "null" é retornado
	MOB_LV - nível do monstro
	MOB_MAXHP - hp máximo do monstro
	MOB_BASEEXP - experiência base do monstro
	MOB_JOBEXP - experiência de trabalho do monstro
	MOB_ATK1 - ataque do monstro
	MOB_ATK2 - atk2 do monstro
	MOB_DEF - def do monstro
	MOB_MDEF - mdef do monstro
	MOB_RES - res do monstro
	MOB_MRES - mres do monstro
	MOB_STR - str do monstro
	MOB_AGI - agi do monstro
	MOB_VIT - vit do monstro
	MOB_INT - int do monstro
	MOB_DEX - dex do monstro
	MOB_LUK - sorte do monstro
	MOB_RANGE - alcance do monstro
	MOB_RANGE2 - alcance do monstro2
	MOB_RANGE3 - alcance do monstro3
	MOB_SIZE - tamanho do monstro
	MOB_RACE - corrida de monstros
	MOB_ELEMENT - elemento do monstro (não retorna o nível do elemento, apenas o ID do elemento)
	MOB_MODE - modo monstro
	MOB_MVPEXP - experiência de mvp do monstro
	MOB_ID - ID do monstro

Para mais detalhes, veja o exemplo em 'doc/sample/getmonsterinfo.txt'.

---------------------------------------

*getmobdrops(<id do mob>)

Este comando encontrará todos os drops do mob especificado e retornará os IDs dos itens
e inserir porcentagens em matrizes de variáveis ​​globais temporárias.
'getmobdrops' retorna 1 se for bem-sucedido e 0 se o ID do mob não existir.

Ao executar isso,

$@MobDrop_item[] é uma matriz numérica temporária global que contém o
                 IDs dos itens que o monstro deixa cair.

$@MobDrop_rate[] é uma matriz numérica temporária global que contém o
                 porcentagens de queda de cada item. (1 = 0,01%)

$@MobDrop_nosteal[] é uma matriz numérica temporária global que contém o
                 Sinalizador StealProtected de cada item. (padrão falso)

$@MobDrop_randomopt[] é uma matriz numérica temporária global que contém o
                 ID do grupo de opções aleatórias de cada item. (padrão 0)

$@MobDrop_count é o número de itens encontrados.

Certifique-se de usar $@MobDrop_count para percorrer as matrizes, e não
'getarraysize', porque as matrizes globais temporárias não são limpas entre
execuções de 'getmobdrops'. Se um mob com 7 itens descartados for pesquisado, as matrizes
tem 7 elementos. Mas se outro mob for procurado e ele tiver apenas 5 itens descartados,
o servidor não limpará os arrays para você, substituindo os valores em vez disso. Então
além de retornar os 5 itens descartados, o 6º e o 7º elementos do
a última chamada permanece, e você receberá 5+2 itens descartados, dos quais os 2 últimos não
pertence ao novo mob. $@MobDrop_count sempre conterá o número correto
(5), ao contrário de 'getarraysize()' que retornaria 7 neste caso.

Exemplo:

	// obtém um Mob ID do usuário
	entrada .@mob_id;

	if (getmobdrops(.@mob_id)) { // 'getmobdrops' retorna 1 em caso de sucesso
		// copie imediatamente as variáveis ​​temporárias globais para as variáveis ​​de escopo,
		// já que não sabemos quando 'getmobdrops' será chamado novamente para
		// outro mob, sobrescrevendo suas variáveis ​​temporárias globais
		.@contagem = $@MobDrop_count;
		copyarray .@item[0],$@MobDrop_item[0],.@count;
		copyarray .@rate[0],$@MobDrop_rate[0],.@count;

		mes getmonsterinfo(.@mob_id,MOB_NAME) + " - " + .@count + " gotas encontradas:";
		for( .@i = 0; .@i < .@count; .@i++ ) {
			mes .@item[.@i] + " (" + getitemname(.@item[.@i]) + ") " + .@rate[.@i]/100 + ((.@rate[.@i]%100 < 10) ? ".0":".") + .@rate[.@i]%100 + "%";
		}
	} outro {
		mes "ID do monstro desconhecido.";
	}
	close;

---------------------------------------

*contagem de pontos de habilidade({<char_id>})

Retorna a quantidade total de pontos de habilidade que um personagem possui (SkillPoint+SP's usados ​​em habilidades)
Este comando pode ser usado para verificar a quantidade total de pontos de habilidade dos personagens atualmente conectados.
Isso significa que os pontos de habilidade usados ​​em habilidade são contados e adicionados aos SkillPoints (número de pontos de habilidade não usados).
Este comando não conta habilidades definidas como sinalizador 4 (permanentemente concedida) (ALL_BUYING_STORE/ALL_INCCARRY)

Exemplo 1:
	.@skillPoints = contagem de pontos de habilidade();
	mes "Você tem " + .@skillPoints + " pontos de habilidade no total!";

Exemplo 2:
	if (skillpointcount() > 20)
		mes "Uau, você tem mais de 20 Pontos de Habilidade no total!";

---------------------------------------

*getscrate(<tipo de efeito>,<taxa base>{,<GID>})

Esta função retornará a chance de um efeito de status afetar a invocação
caráter, em porcentagem, modificado pela sua defesa atual contra o dito
status. A 'taxa base' é a chance base do efeito de status ser infligido,
em porcentagem.

    if (rand(100) > getscrate(Eff_Blind, 50)) vá para BlindHimNow;

Você pode ver a lista completa de tipos de efeitos disponíveis que você pode infligir em
'src/map/script_constants.hpp' em 'Eff_'.

---------------------------------------

========================
|3.- Verificação de comandos.|
========================
---------------------------------------

*jogadoranexado()

Retorna o ID do jogador atualmente anexado ao script. Ele retornará
0 se ninguém estiver anexado ou se o jogador anexado não existir mais no mapa
servidor. É aconselhável verificar o player anexado nas funções de script que
lidar com temporizadores, pois não há garantia de que o jogador ainda estará conectado
quando o cronômetro dispara. Observe que o ID de um jogador é, na verdade, seu
ID da conta.

---------------------------------------

*getattachedrid();

Retorna RID do script em execução. O script não pode ser anexado a nenhum RID como
um script ou função flutuante e retornará 0.

---------------------------------------

*isloggedin(<id da conta>{,<id do caractere>})

Esta função retorna 1 se a conta especificada estiver logada e 0 se eles
não são. Você também pode passar o char id para verificar tanto a conta quanto o char id.

---------------------------------------

*checkweight(<id do item>,<quantidade>{,<id do item>,<quantidade>,<id do item>,<quantidade>,...});
*checkweight("<nome do item>",<quantidade>{,"<nome do item>",<quantidade>,"<nome do item>",<quantidade>,...});
*checkweight2(<matriz_id>,<matriz_quantidade>);

Essas funções calcularão e retornarão 1 se o peso total do especificado
número de itens específicos não excede o personagem que os invoca
capacidade e 0 caso contrário. É importante ver se um jogador pode carregar o
itens que você espera dar a eles, deixar de fazer isso pode abrir seu script para
abusar ou criar alguns erros muito injustos.

A segunda função verificará uma série de itens e quantidades, e também
retorna 1 em caso de sucesso e 0 em caso de falha.

As funções, além de verificar se o jogador é capaz de
segurando uma quantidade definida de itens, também garanta que o jogador tenha espaço em seu
inventário dos itens que receberão.

Assim como 'getitem', esta função também aceitará um 'nome em inglês' do
banco de dados como argumento.

Exemplo 1:

	if (checkweight(512,10)) {
		obter item 512,10;
	} outro {
		mes "Desculpe, você não pode segurar essa quantidade de maçãs!";
	}

Exemplo 2:

	setarray .@item[0],512,513,514;
	setarray .@amount[0],10,5,5;
	if (!checkweight2(.@item,.@amount)) {
		mes "Desculpe, você não pode segurar essa quantidade de frutas!";
	}

---------------------------------------

*verificação de habilidades básicas()

Esta função retornará o estado da opção de configuração
'basic_skill_check' em 'battle_athena.conf'. Ele retorna 1 se a opção for
habilitado e 0 se não estiver. Se a opção 'basic_skill_check' estiver habilitada, qual
é por padrão, os personagens devem ter um certo número de níveis de habilidade básicos para
sente-se, solicite uma troca, use emoções, etc. Fazendo seu script se comportar de forma diferente
dependendo se os personagens realmente precisam ter habilidade para fazer tudo isso
coisas podem ser necessárias em alguns casos.

---------------------------------------

*checkoption(<número da opção>{,<char_id>})
*checkoption1(<número da opção>{,<char_id>})
*checkoption2(<número da opção>{,<char_id>})
*setoption <número da opção>{,<flag>{,<char_id>}};

A série de funções 'setoption' verifica se há uma opção definida em
o caractere de invocação. 'Opções' são usadas para armazenar condições de status e muito
de outros dados de caráter não permanentes do tipo sim-não. Para os casos mais comuns,
é melhor usar 'checkcart', 'checkfalcon', 'checkriding' e outros semelhantes
funções, mas há algumas opções que você não pode obter dessa forma. Elas
retorna 1 se a opção estiver definida e 0 se a opção não estiver definida.

Os números de opção válidos para a primeira versão (opcional) deste comando são:

0x1 - Visão em vigor.
0x2 - Ocultar em vigor.
0x4 - Camuflagem em vigor.
0x8 - Carrinho número 1 presente.
0x10 - Falcão presente.
0x20 - Peco Peco presente.
0x40 - GM Perfect Hide em vigor.
0x80 - Carrinho número 2 presente.
0x100 - Carrinho número 3 presente.
0x200 - Carrinho número 4 presente.
0x400 - Carrinho número 5 presente.
0x800 - Cabeça de orc presente.
0x1000 - O personagem está usando um sprite de casamento.
0x2000 - Ruwach está em vigor.
0x4000 - Chasewalk em vigor.
0x8000 - Traje de voo ou de Natal.
0x10000 - Destruidor de visão.
0x100000 - Warg presente.
0x200000 - O personagem está pilotando um warg.

Os números de opção válidos para a segunda versão (opt1) deste comando são:

1 - Petrificado.
2 - Congelado.
3 - Atordoado.
4 - Dormir.
6 - Petrificante (o estado em que você ainda consegue andar)

Os números de opção válidos para a terceira versão (opt2) deste comando são:

0x1 - Envenenado.
0x2 - Amaldiçoado.
0x4 - Silenciado.
0x8 - Signum Crucis (reproduz um efeito sonoro semelhante a um uivo, mas, de outra forma, nenhum efeito visível é exibido)
0x10 - Cego.
0x80 - Envenenado mortalmente.

Os números de opção (exceto opt1) são máscaras de bits - você pode adicioná-los para verificar
para vários estados, mas as funções retornarão verdadeiro se pelo menos um deles
está em vigor.

'setoption' setá opções no caractere invocador. Não há segundos e
terceira versão deste comando, então você só pode alterar os valores na primeira
lista (manto, carrinho, ruwach, etc). se o sinalizador for 1 (padrão quando omitido),
a opção será adicionada ao que o personagem tem atualmente; se 0, a opção será removida.

Esta definitivamente não é uma lista completa de números de sinalizadores de opções disponíveis. Pergunte a um
desenvolvedor principal (ou leia a fonte: src/map/status.hpp) para a lista completa.

---------------------------------------

*setcart {<tipo>{,<id_char>}};
*checkcart({<id_char>});

Se <tipo> for 0, este comando removerá o carrinho do personagem.
Caso contrário, ele dá ao personagem que invoca um carrinho. O carrinho dado será
número do carrinho <tipo> e funcionará independentemente de o personagem ser um
classe mercante ou não.
Nota: o personagem precisa ter a habilidade MC_PUSHCART para ganhar um carrinho

A função que acompanha retornará 1 se o caractere que invoca tiver um carrinho
(qualquer tipo de carrinho) e 0 se não o fizerem.

    if (checkcart()) mes "Mas você já tem um carrinho!";

---------------------------------------

*setfalcon {<bandeira>{,<id_do_caractere>}};
*checkfalcon({<id_char>});

Se <flag> for 0, este comando removerá o falcão do personagem.
Caso contrário, ele dá ao personagem invocador um falcão. O falcão estará lá
independentemente de o personagem ser um caçador ou não. (Provavelmente) não
não tem efeitos úteis para quem não é caçador.
Nota: o personagem precisa ter a habilidade HT_FALCON para ganhar um falcão

A função que acompanha retornará 1 se o caractere que invoca tiver um falcão
e 0 se não o fizerem.

    if (checkfalcon()) mes "Mas você já tem um falcão!";

---------------------------------------

*configurando {<flag>{,<char_id>}};
*checkriding({<id_char>});

Se <flag> for 0, este comando removerá a montaria do personagem.
Caso contrário, ele dá ao personagem que invoca um PecoPeco (se ele for um Cavaleiro
classe da série), um GrandPeco (se forem uma classe da série Crusader) ou
um Gryphon (se eles forem um Royal Guard). Ao contrário de 'setfalcon' e 'setcart'
isso não vai funcionar se eles não forem de uma classe que saiba andar.
Nota: o personagem precisa ter a habilidade KN_RIDING para ganhar uma montaria

A função que acompanha retornará 1 se o personagem que invoca estiver pilotando um
pássaro e 0 se não forem.

    if (checkriding()) mes "POR FAVOR, deixe seu pássaro lá fora! Não monte pássaros no chão aqui!";

---------------------------------------

*setdragon {<cor>{,<id_caractere>}};
*checkdragon({<id_char>});

A função 'setdragon' alterna a montagem de um dragão para o personagem que o invoca.
Retornará 1 se for bem-sucedido, 0 caso contrário.

As cores disponíveis são:
1 - Dragão Verde (padrão)
2 - Dragão Marrom
3 - Dragão Cinzento
4 - Dragão Azul
5 - Dragão Vermelho

Nota: o personagem deve ser um Cavaleiro Rúnico e ter a habilidade RK_DRAGONTRAINING para ganhar uma montaria

A função que acompanha retornará 1 se o personagem que invoca estiver pilotando um
dragão e 0 se não forem.

---------------------------------------

*setmadogear {<bandeira>{,<tipo>{,<id_char>}}};
*checkmadogear({<id_char>});

Se <flag> for falso, este comando removerá a montagem do personagem.
Caso contrário, ele dá ao personagem que invoca um Mado (se ele for um Mecânico e tiver a habilidade NC_MADOLICENCE).

Ao usar a versão do cliente PACKETVER_MAIN_NUM >= 20191120 ou PACKETVER_RE_NUM >= 20191106
o sinalizador <type> pode ser usado para especificar um madogear específico.
Tipos:
	MADO_ROBOT (padrão)
	TERNO MADO

A função que acompanha retornará 1 se o caractere de chamada tiver um
Mado e 0 se não o fizerem.

---------------------------------------

*setmounting {<id_char>};
*está montando({<char_id>});

A função 'setmounting' alterna a quantia de dinheiro para o personagem que o invoca.
Retornará 1 se for bem-sucedido, 0 caso contrário.

Observação: o personagem não pode estar montando uma montaria que não seja dinheiro (por exemplo, dragão, peco, wug, etc.)

A função que acompanha retornará 1 se o caractere de chamada tiver um
dinheiro e 0 se não o fizerem.

---------------------------------------

*checkwug({<id_char>});

Esta função retornará 1 se o caractere de chamada tiver um
warg e 0 se não o fizerem.

---------------------------------------

*checkvending({"<Nome do jogador>"})

Verifica se o jogador está vendendo ou tem uma loja de compras. Adicionalmente
Ele fornece informações sobre se o jogador usa autotrade ou não.
O nome é opcional e, se omitido, o padrão é o do player anexado.

O valor retornado é a máscara de bits de.
  0 = não tem uma loja de venda ou compra (o que também significa que ele não pode usar o autotrade)
  1 = venda normal
  2 = usando @autotrade
  4 = tem uma loja de compras

Exemplos:
	//Isso verificará o estado de Aaron
	.@state = checkvending("Aaron");
	if (.@estado&1)
		mes "Aaron está vendendo no momento!";
	if (.@estado&4)
		mes "Aaron tem uma loja de compras!";
	if (.@estado&2)
		mes "Aaron está fazendo autotrading!";

---------------------------------------

*checkchatting({"<Nome do jogador>"})

Verifica se o jogador está em uma sala de bate-papo.
O nome é opcional e, se omitido, o padrão é o do player anexado.
Retorna 1 se estiverem em uma sala de bate-papo, 0 se não estiverem.

Exemplos:
	//Isso verificará se o jogador anexado está em uma sala de bate-papo ou não.
	if (verificarconversando())
		mes "Você está atualmente em uma sala de bate-papo!";

---------------------------------------

*checkidle({"<Nome do Jogador>"})

Retorna o tempo, em segundos, que o jogador especificado ficou ocioso.
O nome é opcional e, se omitido, o padrão é o do player anexado.

---------------------------------------

*checkidlehom({"<Nome do Jogador>"})

Retorna o tempo, em segundos, que o jogador especificado ficou ocioso para compartilhamento de item/exp do homúnculo.
O nome é opcional e, se omitido, o padrão é o do player anexado.
Isso só funcionará se 'hom_idle_no_share' e 'idletime_hom_option' estiverem habilitados (veja '/conf/battle/homunc.conf').

---------------------------------------

*checkidlemer({"<Nome do jogador>"})

Retorna o tempo, em segundos, que o jogador especificado ficou ocioso para compartilhamento de itens de mercenário.
O nome é opcional e, se omitido, o padrão é o do player anexado.
Isso só funcionará se 'mer_idle_no_share' e 'idletime_mer_option' estiverem habilitados (veja '/conf/battle/drops.conf').

---------------------------------------

*verificação de agitação()
*agitcheck2()
*agitcheck3()

Essas funções permitirão que você verifique se o servidor está atualmente no modo WoE:FE
(agitcheck()), modo WoE:if (agitcheck2()) ​​ou modo WoE:TE (agitcheck3()) e irá
retorna verdadeiro se a Guerra do Emperium estiver ativada e falso se não estiver.

---------------------------------------

*énoite()
*é dia()

Essas funções retornarão 1 ou 0 dependendo se o servidor está no modo noturno
modo ou modo diurno. 'isnight' retorna 1 se for noite e 0 se não for, 'isday'
o contrário. Eles podem ser usados ​​de forma intercambiável, escolha o que você gosta
mais:

    // Esses dois são equivalentes:
    if (isday()) mes "Eu só ando à noite.";
    if (isnight() != 1) mes "Eu só ando à noite.";

---------------------------------------

*checkre(<tipo>)

Verifica se um recurso de renovação está habilitado ou não em renewal.hpp e retorna 1 se
habilitado e 0 para desabilitado.

O recurso de renovação a ser verificado é determinado pelo número <tipo>.
0 - RENOVAÇÃO habilitada (modo de servidor de renovação do jogo)
1 - RENEWAL_CAST (tempo de renovação do cast)
2 - RENEWAL_DROP (algoritmos de taxa de queda de renovação)
3 - RENEWAL_EXP (algoritmos de taxa de renovação de exp)
4 - RENEWAL_LVDMG (modificador de nível de renovação em dano)
5 - RENEWAL_ASPD (ASPD de renovação)

---------------------------------------
\\
3,1.- Comandos relacionados a itens
\\
---------------------------------------

*estáequipado(<id>{,<id>{,..}})

Esta função retornará 1 se o caractere que invoca tiver todos os itens
IDs fornecidos equipados (se os IDs dos itens/cartas forem passados, ele verifica se os itens/cartas estão
inseridos em slots no equipamento que estão usando no momento). Teoricamente
não há limite para o número de itens que podem ser testados ao mesmo tempo.
Se pelo menos um dos itens fornecidos não estiver equipado, 0 será retornado.

    // (Poring, Santa Poring, Poporing, Marin)
    if (isavailable(4001,4005,4033,4196)) mes "Uau! Você está usando um conjunto completo de possíveis cartas de poring!";
    // (Examinando)
    if (isavailable(4001)) mes "Um cartão de poring é útil, você não acha?";

A função foi criada para scripts de itens para dar suporte aos cartões lançados pela Gravity
em fevereiro de 2005, mas funcionará perfeitamente em scripts normais de NPCs.

---------------------------------------

*isequipadocnt(<id>{,<id>{,..}})

Esta função é semelhante a 'isequipado', mas em vez de 1 ou 0, ela retornará
a quantidade de itens/cartas equipados que foram encontrados no personagem invocador da lista fornecida.

Exemplo:
    if (isequipadocnt(4001,4005,4033,4196) == 5)
		mes "Finalmente conseguiu 5 cartas do tipo monstros poring?";

---------------------------------------

*checkequipedcard(<id do item>)

Esta função retornará 1 se o item/cartão especificado pelo seu número de ID do item for
inserido em qualquer equipamento que eles tenham em seu inventário, atualmente equipado ou
não.

---------------------------------------
//
3,1.- Fim dos comandos relacionados a itens
//
---------------------------------------

==============================
|4.- Comandos relacionados ao jogador.|
==============================
---------------------------------------

*attachrid(<ID da conta>{,force})
*desanexar;

Esses comandos permitem a manipulação do player atualmente anexado ao script.
Enquanto 'attachrid' permite anexar um jogador diferente usando seu ID de conta
para o parâmetro RID, 'detachrid' faz com que os seguintes comandos sejam executados como se o
o script nunca foi invocado por um jogador.

O comando retorna falso se o jogador não puder ser anexado (se a conta estiver offline
ou não existe) e verdadeiro em caso de sucesso.

Por padrão o comando é executado com força, o que faz com que o jogador seja anexado
mesmo que ele esteja atualmente vinculado a outro script. Como nem sempre é esse o caso
comportamento desejado você também pode especificar falso para o comando e ele retornará apenas
verdadeiro se o player estiver online e não estiver anexado a outro script.

---------------------------------------

*addrid(<tipo>{,<sinalizador>{,<parâmetros>}});

Este comando anexará outros RIDs ao script atual sem desanexar o
invocando RID. Ele retorna 1 se bem-sucedido e 0 em caso de falha.

<type> determina quais RIDs são anexados:
0: Todos os jogadores no servidor.
1: Todos os jogadores no mapa do jogador invocador, ou do NPC invocador, se nenhum jogador estiver anexado.
2: Membros do grupo com uma ID de grupo específica.
    [ Parâmetros: <id da parte> ]
3: Membros da guilda com uma ID de guilda específica.
    [ Parâmetros: <id da guilda> ]
4: Todos os jogadores em uma área específica do mapa do jogador invocador (ou NPC).
    [ Parâmetros: <x0>,<y0>,<x1>,<y1> ]
5: Todos os jogadores no mapa.
    [ Parâmetros: "<nome do mapa>" ]
6: Membros do campo de batalha de uma ID de campo de batalha especificada.
    [ Parâmetros: <id do campo de batalha> ]
7: Membros de clã de um ID de clã especificado.
    [ Parâmetros: <id do clã> ]
ID da conta: se o tipo for ID da conta, anexe o ID da conta especificado.

<flag> pode impedir que certos jogadores sejam anexados:
0: Os jogadores estão sempre anexados. (padrão)
1: Jogadores que estejam executando outro script não serão anexados.

---------------------------------------

*rid2name(<rid>)

Converte rid para nome. Nota: O jogador/monstro/NPC deve estar online/habilitado.
Bom para PCKillEvent, onde você pode converter 'killedrid' para o nome do jogador.

Observação: rid2name pode não produzir nomes de personagens corretos, pois rid = id da conta.
      Ele retornará apenas o caractere online atual da conta.

---------------------------------------

*mensagem "<nome do personagem>","<mensagem>";

Esse comando enviará uma mensagem para a janela de bate-papo do personagem especificado
pelo nome. O texto também aparecerá acima da cabeça desse personagem. Não será
ser visto por mais ninguém.

---------------------------------------

*dispbottom "<mensagem>"{,<cor>{,<id_caractere>}};

Este comando enviará a mensagem fornecida com cor para o chat do personagem que a invoca.
janela. O formato da cor é RGB (0xRRGGBB). A cor é
por padrão verde

---------------------------------------

*showscript "<mensagem>"{,<GID>, <sinalizador>};

Faz com que o jogador ou GID anexado diga uma mensagem como se estivesse gritando o nome de uma habilidade, a mensagem
será visto por todos ao redor, mas não na janela de bate-papo.
flag: Especificar alvo
   ÁREA - A mensagem é enviada aos jogadores nas proximidades da fonte (padrão).
   SELF - A mensagem é enviada somente para o jogador anexado.

---------------------------------------

*warp "<nome do mapa>",<x>,<y>{,<id do caractere>};

Este comando levará o caractere de invocação ou <char id>, se especificado, para o mapa especificado e, se
desejado, coordenadas especificadas também, mas estas podem ser aleatórias.

	warp "lugar",50,55;

Isso os levaria para X 50 Y 55 no mapa chamado "lugar". Se seu X e Y
coordenadas pousam em um quadrado do mapa intransponível, ele enviará o personagem distorcido
para um lugar aleatório. O mesmo acontecerá se ambos forem zero:

	warp "lugar",0,0;

Observe que, embora teletransportar as pessoas para as coordenadas 0,0 normalmente as levará para
um lugar aleatório, não é certo que sempre será assim. Droga se eu sei onde é isso
na verdade codificado, pode ser que isso aconteça porque o quadrado 0,0 é intransitável
em todos os mapas oficiais. Se você estiver usando mapas personalizados, cuidado.

Há também três 'nomes de mapas' especiais que você pode usar.

"Aleatório" teletransportará o jogador aleatoriamente no mapa atual.
"Salvar" e "Ponto de salvamento" levarão o jogador de volta ao seu ponto de salvamento.

---------------------------------------

*areawarp "<do nome do mapa>",<x1>,<y1>,<x2>,<y2>,"<para o nome do mapa>",<x3>,<y3>{,<x4>,<y4>};

Este comando é semelhante ao 'warp', no entanto, não fará referência à invocação
personagem, mas sim todos os personagens dentro de uma área específica, definida pelo
quadrado x1/y1-x2/y2, será distorcido. Ninguém fora da área será afetado,
incluindo o personagem ativador, se estiverem fora da área.

	areawarp "lugar",10,10,120,120,"lugar2",150,150;

Todos que estão na área entre X 10 Y 10 e X 120 Y 120, em um quadrado
a forma, no mapa chamada "lugar", será afetada e distorcida para "lugar2" X 150
E 150

	areawarp "lugar",10,10,120,120,"lugar2",0,0;

Ao usar ,0,0; como coordenadas de destino, ele pegará todos os caracteres em
a área afetada para um conjunto aleatório de coordenadas em "place2".

	areawarp "lugar",10,10,120,120,"lugar2",150,150,200,200;

Ao utilizar os parâmetros opcionais x4 e y4, as coordenadas de destino serão um
lugar aleatório dentro do quadrado x3/y3-x4/y4 definido.

Assim como 'warp', areawarp também irá warp explicitamente os personagens aleatoriamente para o
mapa atual se você der o 'nome do mapa' como "Aleatório".

Veja também 'warp'.

---------------------------------------

*warpparty "<para_nome_do_mapa>",<x>,<y>,<id_da_parte>,{"<de_nome_do_mapa>",<intervalo x>,<intervalo y>};

Teleporta um grupo para um mapa e coordenada específicos, dado o ID do grupo, que você pode obter com
getcharid(1). Você também pode solicitar outro ID de grupo dado o nome de um membro com getcharid(1,<player_name>).

Você pode usar os seguintes "nomes de mapa" para comportamento de distorção especial:
Aleatório: Todos os membros do grupo são aleatoriamente distorcidos em seu mapa atual (como se eles
              todos usaram uma asa de mosca)
SavePointAll: Todos os membros do grupo são teletransportados para seus respectivos pontos de salvamento.
SavePoint: Todos os membros do grupo são teletransportados para o ponto de salvamento do grupo atual.
              jogador anexado (falhará se não houver nenhum jogador anexado).
Líder: Todos os membros do grupo são teletransportados para a posição do líder. O líder deve
              esteja online e no servidor de mapas atual para que isso funcione.
RandomAll: Todos os membros do grupo são teletransportados para a mesma posição aleatória em seu mapa atual

Se você especificar um from_mapname, 'warpparty' afetará apenas aqueles naquele mapa.

Os valores opcionais <range x> e <range y> permitem uma randomização com o
ponto de dobra do jogador. Os valores serão adicionados ou subtraídos aleatoriamente do <x> fornecido
e coordenadas <y>.

Exemplo:
	mes "[Party Warper]";
	mes "Aqui está!";
	close2;
	.@party_id = getcharid(1);
	warpparty "prontera",150,100,.@party_id;
	close;

---------------------------------------

*warpguild "<nome do mapa>",<x>,<y>,<id_da_guild>;

Teleporta uma guilda para um mapa e coordenada específicos, dado o ID da guilda, que você pode obter com
getcharid(2). Você também pode solicitar outro id de guilda dado o nome do membro com getcharid(2,<player_name>).

Você pode usar os seguintes "nomes de mapa" para comportamento de distorção especial:
Aleatório: Todos os membros da guilda são aleatoriamente distorcidos em seu mapa atual (como se eles
              todos usaram uma asa de mosca)
SavePointAll: Todos os membros da guilda são teletransportados para seus respectivos pontos de salvamento.
SavePoint: Todos os membros da guilda são teletransportados para o ponto de salvamento do jogador atual.
              jogador anexado (falhará se não houver nenhum jogador anexado).

Exemplo:

warpguild "prontera",x,y,Guild_ID;

---------------------------------------

*warppartner("<nome do mapa>",<x>,<y>);

Esta função encontrará o parceiro de casamento do personagem que faz a invocação, se houver, e
teletransportá-los para o mapa e as coordenadas fornecidas. Ele retornará 1 em caso de sucesso e
0 se o parceiro não estiver online, o personagem não for casado ou se não houver
invocando caractere (sem RID). 0,0, como de costume, normalmente será traduzido em coordenadas aleatórias.

---------------------------------------

*savepoint "<nome do mapa>",<x>,<y>{,{<intervalo x>,<intervalo y>,}<char_id>};
*salvar "<nome do mapa>",<x>,<y>{,{<intervalo x>,<intervalo y>,}<char_id>};

Esses comandos salvam para onde o personagem invocador retornará ao clicar
"Retornar ao ponto de salvamento", após a morte e em alguns outros casos. As duas versões são
equivalente. Eles ignoram todos e quaisquer mapflags e podem fazer um personagem reaparecer onde
nenhum teletransporte é possível de outra forma.

Os valores opcionais <range x> e <range y> permitem uma randomização com o
ponto de salvamento do jogador. Os valores serão adicionados ou subtraídos aleatoriamente do <x> fornecido
e coordenadas <y>.

	ponto de salvamento "local",350,75;
	savepoint "place",350,75,2,2; // Salva aleatoriamente o personagem entre 348,73 e 352,77

---------------------------------------

*curar <hp>,<sp>{,<char_id>};

Este comando curará uma quantidade definida de HP e/ou SP no personagem que o invoca.

	heal 30000,0; // Isso vai curar 30.000 HP
	curar 0,30000; // Isso vai curar 30.000 SP
	curar 300.300; // Isso curará 300 HP e 300 SP

Este comando apenas altera os pontos de vida e pontos de magia do invocador
personagem e não produz nenhuma outra saída.

---------------------------------------

*healap <ap>{,<id_char>};

Este comando curará uma quantidade definida de PA no personagem que o invoca.

	healap 10; // Isso dará 10 AP
	healap -10; // Isso removerá 10 AP

Este comando apenas altera os pontos de atividade do invocador
personagem e não produz nenhuma outra saída.

---------------------------------------

*itemheal <hp>,<sp>{,<char_id>};

Este comando cura quantidades relativas de HP e/ou SP no personagem que o invoca.
Ao contrário de heal, este comando é destinado ao uso em scripts de itens. Ele se aplica
bônus relacionados a poções, como classificação de alquimista, cartas e mudanças de status.
Quando usado dentro de um script de NPC, certos bônus são omitidos.

O comando também aplica um bônus relacionado a SP/VIT:
	curar = curar * [(100 + STATUS*2) / 100]

Exemplo:
	// Se o jogador tiver 50 vit e nenhum bônus, isso irá curar
	// qualquer coisa entre 200 e 300 HP e 5 SP
	itemcurar rand(100,150),5;

---------------------------------------

*percentual de cura <hp>,<sp>{,<char_id>};

Este comando curará o personagem invocador. Ele cura o personagem, mas não
por um valor definido - adiciona uma porcentagem do seu HP/SP máximo.

	percentheal 100,0; // Isso curará 100% do HP
	percentheal 0,100; // Isso curará 100% SP
	percentheal 50,50; // Isso curará 50% HP e 50% SP

Então a quantidade que isso irá curar dependerá da quantidade total de HP ou SP
você tem o máximo. Assim como 'heal', isso não vai chamar nenhuma animação ou efeito.

---------------------------------------

*recovery <tipo>{,<opção>,<sinalizador_de_recuperação>{,<nome do mapa>}};

Este comando irá reviver e restaurar completamente o HP/SP dos personagens selecionados.
Retorna 1 após uso bem-sucedido.

<type> é o alvo e determina o parâmetro <option>:
0: Jogador -> Número de ID do personagem
1: Parte -> Número de identificação da parte
2: Guilda -> Número de ID da guilda
3: Mapa -> Nome do mapa (uma string)
4: Todos -> Nenhum (aceita <revive_flag> como opção)

Se nenhuma opção for especificada, o ID do personagem do jogador que invoca, o ID do grupo, o ID da guilda,
ou mapa será usado.

<revive_flag> determina a ação:
1: Reviva e cure todos os jogadores (padrão)
2: Cure apenas jogadores vivos
4: Reviva apenas jogadores mortos

<nome do mapa> pode ser usado opcionalmente para set um único mapa para executar o comando
para os tipos 1 (partido) e 2 (guilda).

Exemplos:
	// Apenas reviva personagens no grupo de invocação no mapa "morocc"
	recuperação 1,getcharid(1),4,"morocc";

	// Cura completamente (não revive) todos os membros da guilda do personagem invocador
	recuperação 2,getcharid(2),2;

	// Reviva e cure completamente todos no mapa "prontera"
	recuperação 3,"prontera";

	// Apenas reviva todos os personagens mortos no servidor
	recuperação 4,4;

---------------------------------------

*jobchange <número do trabalho>{,<sinalizador superior>,<id_do_caractere>};

Este comando mudará a classe de trabalho do personagem que o invoca.

	jobchange 1; // Isso transformaria seu jogador em um Espadachim
	jobchange 4002; // Isso transformaria seu jogador em um Espadachim Alto

Este comando funciona com números, mas você também pode usar nomes de trabalho. O comando completo
a lista de nomes de cargos e os números aos quais correspondem pode ser encontrada em
'src/map/script_constants.hpp'.

	// Isso transformaria seu jogador em um Espadachim
	mudança de emprego Job_Swordman;
	// Isso transformaria seu jogador em um Espadachim Alto
	mudança de emprego Job_Swordman_High;

'flag superior' pode ser usado alternativamente para especificar o tipo de trabalho que se altera
para. Por exemplo, jobchange Job_Swordman,1; mudará o personagem para um alto
espadachim. Os valores superiores são:
-1 (ou quando omitido): preserva o tipo de trabalho atual.
0: Classes normais/padrão
1: Classes avançadas/altas
2: Aulas para bebês

Este comando também setá uma variável permanente baseada em caracteres
'jobchange_level' que conterá o nível do trabalho no momento imediatamente anterior
alterando empregos, o que pode ser verificado posteriormente em scripts.

---------------------------------------

*jobname(<número do trabalho>)

Este comando recupera o nome do trabalho fornecido usando as entradas map_msg 550->655.

	mes "[Criança]";
	mes "Eu nunca pensei que encontraria um " + jobname(Class) + " aqui de todos os lugares.";
	close;

---------------------------------------

*eaclass({<número do trabalho>,<char_id>})

Este comando retorna o "número de trabalho eA" correspondente à classe fornecida e
usa a classe do jogador que invoca se nenhuma for fornecida. O número de trabalho eA também é um
sistema de numeração de classe, mas é um que vem com constantes que o tornam fácil
para converter entre classes. O comando retornará -1 se você passar um número de trabalho
que não tem um número de trabalho eA equivalente.

	.@eac = eaclass();
	if ((.@eac&EAJ_BASEMASK) == EAJ_SWORDMAN)
		mes "Seu trabalho base é Espadachim.";
	if (.@eac&EAJL_UPPER)
		mes "Você é um trabalho de renascimento.";
	if ((.@eac&EAJ_UPPERMASK) == EAJ_SWORDMAN)
		mes "Você deve ser um Espadachim, Espadachim Bebê ou Espadachim Alto.";

Para mais informações sobre o eA Job System, consulte o arquivo docs/ea_job_system.txt.

---------------------------------------

*roclass(<número do trabalho>{,<gênero>})

Faz o oposto de eaclass. Ou seja, dado um número de trabalho eA, ele retorna o
número de classe RO correspondente. Um gênero é necessário porque tanto Bardo quanto Dançarinos
compartilham o mesmo número de trabalho eA (EAJ_BARDDANCER) e usam o jogador que o invoca
gênero se nenhum for fornecido (se nenhum jogador estiver vinculado, masculino será usado por padrão).
O comando retornará -1 se não houver uma classe válida para representar o especificado
trabalho (por exemplo, se você tentar obter a versão bebê de uma aula de Taekwon).

	.@eac = eaclass();
	//Verifique se a classe já foi renascida
	if (.@eac&EAJL_UPPER) {
		mes "Você parece forte.";
		close;
	}
	.@eac = roclass(.@eac|EAJL_UPPER);
	//Verifique se a classe tem uma versão rebirth
	if (.@eac != -1) {
		mes "Aposto que você mal pode esperar para se tornar um " + jobname(.@eac) + "!";
		close;
	}

---------------------------------------

*changebase <número de ID do trabalho>{,<ID da conta>};

Este comando mudará a aparência de um personagem para a do trabalho especificado
classe. Nada além da aparência mudará.

O comando será executado para o personagem que o invoca, a menos que um ID de conta seja fornecido.

	changebase Job_Novice; // Altera o jogador para sprite Novato.
	changebase Class; // Altera o jogador de volta para o sprite padrão.

---------------------------------------

*classchange(<id da visualização>{,"<nome do NPC>","<sinalizador>"});

Este comando é muito antigo e suas origens são envoltas em mistério.
Ele enviará um pacote de 'alteração de ID de exibição' para todos na área imediata de
o objeto NPC, que supostamente fará o NPC parecer um sprite diferente,
um ID de sprite de NPC ou um ID de monstro. Este efeito não é armazenado em nenhum lugar e irá
não persistir (o que é estranho, porque seria relativamente fácil fazer isso)
e o mais importante, não funcionará de forma alguma, pois esse comando foi quebrado com
a introdução de classes avançadas. O código é escrito com a suposição
que os IDs de sprite mais baixos são os sprites de trabalho e qualquer coisa além deles é
monstros e sprites NPC, mas desde que as classes avançadas chegaram, eles conseguiram
Números de identificação na outra extremidade do conjunto de números onde os sprites dos monstros flutuam.

Como resultado, atualmente é impossível chamar este comando com uma visualização válida
id. Ele não fará nada se o ID da visualização for inferior a 4047. Fazendo com que ele
executar irá, na verdade, travar o cliente.

Poderia ser uma verdadeira jóia se pudesse realmente fazer o que deveria
fazer, mas isso só acontecerá em uma revisão posterior do SVN.

<Nome do NPC> vazio significa NPC anexado.

Alvo para <flag>:
- bc_area: O sprite é enviado aos jogadores nas proximidades da fonte (valor padrão).
- bc_self: O sprite é enviado apenas para o jogador anexado.

---------------------------------------

*changesex({<id_char>});

Este comando mudará o gênero da conta do personagem anexado. Se for
era macho, se tornará fêmea, se era fêmea, se tornará macho. O
a mudança será escrita no servidor de personagens, o jogador receberá o
mensagem: "Precisa de desconexão para executar solicitação de mudança de sexo..." e o jogador
serão imediatamente chutados para a tela de login. Quando eles fizerem login novamente, eles
ser do sexo oposto.

Se houver algum personagem Dançarino/Cigano ou Bardo/Palhaço na conta,
elas também terão suas habilidades redefinidas em 'changesex'.

---------------------------------------

*changecharsex({<id_char>});

Este comando mudará o gênero do personagem anexado. Se for
era macho, se tornará fêmea, se era fêmea, se tornará macho. O
a mudança será escrita no servidor de personagens, o jogador receberá o
mensagem: "Precisa de desconexão para executar solicitação de mudança de sexo..." e o jogador
serão imediatamente chutados para a tela de login. Quando eles fizerem login novamente, eles
ser do sexo oposto.

Se o personagem que está sendo alterado for do tipo Dançarino/Cigano ou Bardo/Palhaço,
o personagem também terá suas habilidades reiniciadas em 'changecharsex'.

---------------------------------------

*getexp <exp_base>,<exp_job>{,<id_char>};

Este comando dará ao personagem que invoca um número especificado de base e trabalho
pontos de experiência. Usado para uma recompensa de missão. Valores negativos não funcionarão.

Os valores de EXP são ajustados pelo valor de configuração 'quest_exp_rate', bônus VIP, Guilda
Itens com impostos e aumento de EXP, como Manual de Batalha, Chiclete ou itens que tenham
SC_EXPBOOST ou SC_ITEMBOOST.

	obterexp 10000,5000;

---------------------------------------

*getexp2 <exp_base>,<exp_job>{,<id_char>};

Este comando é uma versão de segurança do comando 'set' para BaseExp e JobExp. Se estiver usando
'set' enquanto o valor BaseExp ou JobExp for maior que 2.147.483.647 (INT_MAX) irá
causando erro de estouro.

Ao contrário de 'getexp', este comando ignora os fatores de ajuste!

---------------------------------------

*getbaseexp_ratio(<porcentagem>{,<nível_base>{,id_caractere});

Retorna a quantidade de experiência base que representa o <porcentual> fornecido do
experiência básica necessária em <base_level>. Se nenhum nível básico for especificado, a base
nível do personagem anexado será usado.

---------------------------------------

*getjobexp_ratio(<porcentagem>{,<nível_de_trabalho>{,char_id});

Retorna a quantidade de experiência de trabalho que representa o <porcentual> fornecido do
experiência de trabalho necessária em <job_level>. Se nenhum nível de trabalho for especificado, o trabalho
nível do personagem anexado será usado.

---------------------------------------

*setlook <tipo de aparência>,<valor da aparência>{,<char_id>};
*changelook <tipo de aparência>,<valor da aparência>{,<char_id>};

'setlook' alterará os dados de aparência para o caractere invocador. É usado
principalmente para mudar a paleta usada em cabelos e roupas: você especifica qual visual
tipo que você deseja alterar e, em seguida, a paleta que deseja usar. Certifique-se de especificar
um número de paleta que existe/pode ser usado pelo cliente que você usa.
'changelook' funciona da mesma forma, mas é apenas do lado do cliente (não salva o valor da aparência).

	// Isso mudará a cor do seu cabelo, para que ele use a paleta 8, seja qual for a sua cor.
	// paleta 8 é, seu cabelo vai usar essa cor

	set look COR_DO_CABELO,8;

	// Isso mudará a cor das suas roupas, então elas estão usando a paleta 1, tanto faz
	// sua paleta 1 é, suas roupas usarão esse conjunto de cores.

	setlook COR_DAS_ROUPAS_OLHAR,1;

Aqui estão os possíveis tipos de aparência:

LOOK_BASE - Sprite base
LOOK_HAIR - Penteado
LOOK_WEAPON - Arma
LOOK_HEAD_BOTTOM - Cabeça inferior
LOOK_HEAD_TOP - Cabeça superior
LOOK_HEAD_MID - Cabeça no meio
LOOK_HAIR_COLOR - Cor do cabelo
LOOK_CLOTHES_COLOR - Cor da roupa
LOOK_SHIELD - Escudo
LOOK_SHOES - Sapatos
LOOK_BODY2 - Estilo de corpo

O que significa "sapatos" é uma incógnita, pergunte à Gravity - o cliente não faz nada
com esse valor. Ele ainda quer isso do servidor, então ele é mantido, mas
normalmente não faz nada.

Apenas os dados de aparência para penteado, cor do cabelo e cor da roupa são salvos no
banco de dados do servidor char e persistirá. O estilo do corpo também persistirá se 'save_body_style'
a configuração está habilitada em '/conf/battle/client.conf'. O resto muda livremente conforme o personagem
coloca e remove equipamentos, altera mapas, faz login e logout e de outra forma você
não deve esperar configurá-los. Na verdade, mexer com eles geralmente é
perigoso, faça por sua conta e risco, não foi testado o que isso realmente fará -
não causará corrupção do banco de dados e provavelmente não causará uma falha no servidor, mas
é fácil travar o cliente com qualquer coisa incomum.

No entanto, pode ser uma maneira fácil de verificar rapidamente se há IDs de exibição vazias para
sprites, o que é essencial para fazer chapéus personalizados.

Como muitas pessoas têm paletas diferentes para cabelos e roupas, é
impossível dizer a você quais são todos os números de cores. Se você quer um sério
por exemplo, há um script Stylist dentro da instalação padrão do brHades que
você pode olhar em: 'npc/custom/stylist.txt'

---------------------------------------

*pushpc <direção>,<células>;

Este comando empurrará o jogador atualmente conectado para a direção fornecida
quantidade de células quadradas. A direção é a mesma usada ao declarar NPCs, e
pode ser especificado usando uma das constantes DIR_* (src/map/script_constants.hpp).

O knock-back não é restringido por itens ou bandeiras do mapa, apenas obstáculos são levados
em consideração. Se não houver espaço suficiente para executar o push (por exemplo, devido a um
parede), o personagem é empurrado apenas até o obstáculo.

	// empurra o personagem 5 células na direção das 3 horas a partir de seu
	// posição atual.
	pushpc DIR_EAST, 5;

---------------------------------------

*recalculatestat;

Este comando forçará um recálculo de estatísticas para o jogador anexado.

---------------------------------------

*needed_status_point(<tipo>,<val>{,<id do caractere>});

Retorna o número de pontos de estatística necessários para alterar a estatística especificada <tipo> por <val>.
Se <val> for negativo, retorna o número de pontos de estatísticas que seriam necessários para
aumenta a estatística especificada de (valor atual - <val>) para o valor atual.

---------------------------------------

*jobcanentermap("<nome do mapa>"{,<JobID>});

Retorna verdadeiro se o jogador (decidido pelo trabalho) puder entrar no mapa, falso caso contrário.

Para 'JobID' opcional, veja a constante de Job_*, ou use a classe do jogador, BaseJob,
e BaseClass. Se nenhum jogador estiver anexado, este parâmetro deve ter um valor.

Veja também db/[pre-]re/job_noenter_map.txt

---------------------------------------

*obter_revisão()

Este comando retornará o número de revisão do SVN que o servidor está atualmente
continuando.

	if (obter_revisão() >= 15000)
		mes "Bem-vindo a brHades!";

---------------------------------------

*obter_githash()

Este comando retornará o Git Hash no qual o servidor está sendo executado no momento.

	mes "Bem-vindo ao brHades! Hash do Git: " + get_githash();

---------------------------------------
\\
4,1.- Comandos relacionados a itens
\\
---------------------------------------

*getitem <id do item>,<valor>{,<ID da conta>};
*getitem "<nome do item>",<quantidade>{,<ID da conta>};

Este comando dará uma quantidade de itens especificados ao personagem que o invoca.
Se uma ID de conta opcional for especificada e o personagem alvo estiver atualmente
online, os itens serão criados em seu inventário. Se não forem
online, nada vai acontecer.

Na primeira e mais comumente usada versão deste comando, os itens são
referenciado pelo número de ID do banco de dados encontrado em 'db/item_db.yml'.

	getitem 502,10 // A pessoa receberá 10 maçãs
	getitem 617,1 // A pessoa receberá 1 Caixa Violeta Velha

Esta transação será registrada se a opção de transações geradas pelo script de log for
habilitado.

Você também pode criar um item pelo seu nome no campo 'nome em inglês' no
banco de dados de itens:

	obteritem "POÇÃO_VERMELHA",10;

Que fará o que você espera. Se não conseguir encontrar esse nome no banco de dados,
maçãs serão criadas de qualquer forma. Muitas vezes é uma IDEIA MUITO BOA usar assim.

Isso é usado em praticamente todos os scripts de NPC que têm a ver com itens e
vários scripts de itens. Para mais exemplos, confira qualquer script oficial.

---------------------------------------

*getitem2 <id do item>,<quantidade>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>{,<ID da conta>};
*getitem2 "<nome do item>",<quantidade>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>{,<ID da conta>};
*getitem3 <id do item>,<quantidade>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<ID da conta>};
*getitem3 "<nome do item>",<quantidade>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<ID da conta>};
*getitem4 <id do item>,<quantidade>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<nota>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<ID da conta>};
*getitem4 "<nome do item>",<quantidade>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<nota>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<ID da conta>};

Este comando dará uma quantidade de itens especificados ao personagem que o invoca.
Se uma ID de conta opcional for especificada e o personagem alvo estiver atualmente
online, os itens serão criados em seu inventário. Se não forem
online, nada vai acontecer. Funciona essencialmente da mesma forma que 'getitem', mas é
muito mais flexível.

Os parâmetros que são diferentes de 'getitem' são:

identificar - Se você deseja que o item seja identificado (1) ou não (0).
refinar - Por quantos pontos positivos ele será refinado.
              Ele não permitirá que você refine um item acima do refinamento máximo.
atributo - Se o item está quebrado (1) ou não (0).
card1,2,3,4 - Se você quiser um composto de cartão, coloque o número de identificação do cartão em
              o slot de cartão específico.

Os valores Card1-card4 também são usados ​​para armazenar informações de nome para itens nomeados, como
bem como a propriedade elemental de armas e armaduras. Você pode criar um item nomeado
desta forma, no entanto, se você só precisa de uma peça nomeada de equipamento padrão,
é muito mais fácil usar a função 'getnameditem'.

Você precisará manter esses valores se quiser destruir e então perfeitamente
recriar um item nomeado, para isso veja 'getinventorylist'.

Se você ainda quiser tentar criar um item nomeado com este comando porque
'getnameditem' não fará isso por você porque é muito limitado, você pode fazer assim
isto. Cuidado, pequena mágica à frente.

	// Primeiro, vamos obter o ID de um personagem cujo nome estará no item.
	// Somente o nome de um personagem existente pode estar lá.
	// Vamos supor que nosso personagem seja 'Adam' e descobrir sua identidade.
	.@charid = getcharid(0,"Adão");

	// Agora dividimos o número de ID do personagem em duas partes com um binário
	// operação shift. Se você não entende o que isso faz, apenas copie.
	.@card3 = .@charid & 65535;
	.@card4 = .@charid >> 16;

	// Se você estiver inscrevendo algo que não seja equipamento, .@card1 deve ser 254.
	// Flechas também não são equipamentos.
	.@cartão1 = 254;

	// Para equipamentos nomeados, card2 significa Star Crumbs e elemental
	// cristais usados ​​para fazer este equipamento. Para todo o resto, é 0.
	.@cartão2 = 0;

	// Agora, vamos dar ao personagem que invocou o script alguma
	// Maçãs de Adão:
	getitem2 512,1,1,0,0,.@cartão1,.@cartão2,.@cartão3,.@cartão4;

Isso não foi testado com todos os itens possíveis, então não posso prometer nada.
experimente primeiro antes de confiar nele.

Para criar o equipamento, continue este exemplo assim:

	// Já temos card3 e card4 carregados com os valores corretos
	// valores então vamos apenas configurar card1 e card2 com dados
	// para um Ice Stiletto.

	// Se você estiver inscrevendo equipamento, .@card1 deve ser 255.
	.@cartão1 = 255;

	// Esse é o número de migalhas de estrelas em uma arma.
	.@sc = 2;

	// Esse é o número de propriedades elementais da arma.
	.@ele = 1;

	// E essa é a fórmula maluca que os torna
	// um único número.
	.@cartão2 = .@ele+((.@sc*5)<<8);

	// Isso nos tornará um Adam's +2 VVS Ice Stiletto:
	getitem2 1216,1,1,2,0,.@cartão1,.@cartão2,.@cartão3,.@cartão4;

Experimente com o número de migalhas de estrelas - não tenho certeza de quanto será
funciona mais e do que depende. Os números de elementos válidos são:

1 - Gelo, 2 - Terra, 3 - Fogo, 4 - Vento.

Você pode, aparentemente, até mesmo criar duplicatas do mesmo ovo de estimação com isso
comando, criando um animal de estimação que é o mesmo, mas existe simultaneamente em dois
ovos, e podem eclodir de qualquer um deles, embora eu não tenha certeza de que tipo de bagunça isso vai causar.
isso realmente causa.

'getitem3' é uma versão avançada de 'getitem2' que também usa a Opção Aleatória de Item como valores adicionais.
<RandomIDArray> : Variável de matriz de ID para opção aleatória de item, veja db/[pre-]re/item_randomopt_db.yml
<RandomValueArray> : Variável de matriz do valor da opção aleatória do item.
<RandomParamArray> : Variável de matriz do parâmetro da opção aleatória do item.

'getitem4' é uma versão avançada de 'getitem3' que também usa a nota como valores adicionais.
As notas válidas são:
	ENCHANTGRADE_NONE - Sem nota
	ENCHANTGRADE_D - Grau D
	ENCHANTGRADE_C - Grau C
	ENCHANTGRADE_B - Grau B
	ENCHANTGRADE_A - Grau A

Exemplo para obter Arma Carmesim com propriedade Fantasma:
	// +9 Adaga Carmesim [2]
	setarray .@OptID[0],RDMOPT_WEAPON_ATTR_TELEKINESIS;
	setarray .@OptVal[0],0;
	setarray .@OptParam[0],0;
	getitem3 28705,1,1,9,0,0,0,0,0,.@OptID,.@OptVal,.@OptParam;

---------------------------------------

*getitembound <id do item>,<quantidade>,<tipo de limite>{,<ID da conta>};
*getitembound "<nome do item>",<quantidade>,<tipo de limite>{,<ID da conta>};

Este comando se comporta de forma idêntica ao 'getitem', mas os itens criados serão
vinculado ao caractere de destino conforme especificado pelo tipo vinculado. Todos os itens criados
desta forma não pode ser descartado, vendido, leiloado ou enviado pelo correio, e em
alguns casos não podem ser negociados ou armazenados.

Os tipos de limites válidos são:
Bound_Account: Item vinculado à conta
Bound_Guild: Item vinculado à guilda
Bound_Party: Item vinculado à festa
Bound_Char: Item vinculado ao personagem

---------------------------------------

*getitembound2 <id do item>,<quantidade>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<tipo de limite>{,<ID da conta>};
*getitembound2 "<nome do item>",<quantidade>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<tipo de limite>{,<ID da conta>};
*getitembound3 <id do item>,<quantidade>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<tipo de limite>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<ID da conta>};
*getitembound3 "<nome do item>",<quantidade>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<tipo de limite>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<ID da conta>};
*getitembound4 <id do item>,<quantidade>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<tipo de limite>,<nota>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<ID da conta>};
*getitembound4 "<nome do item>",<quantidade>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<tipo de limite>,<nota>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<ID da conta>};

Este comando se comporta de forma idêntica ao 'getitem2', mas os itens criados serão
vinculado ao caractere de destino conforme especificado pelo tipo vinculado. Todos os itens criados
desta forma não pode ser descartado, vendido, leiloado ou enviado pelo correio, e em
alguns casos não podem ser negociados ou armazenados.

Para uma lista de tipos vinculados, consulte 'getitembound'.

'getitembound3' é uma versão avançada de 'getitembound2' que também usa a Opção Aleatória de Item como valores adicionais.
<RandomIDArray> : Variável de matriz de ID para opção aleatória de item, veja db/[pre-]re/item_randomopt_db.yml
<RandomValueArray> : Variável de matriz do valor da opção aleatória do item.
<RandomParamArray> : Variável de matriz do parâmetro da opção aleatória do item.

'getitembound4' é uma versão avançada de 'getitembound3' que também usa a nota como valores adicionais.
As notas válidas são:
	ENCHANTGRADE_NONE - Sem nota
	ENCHANTGRADE_D - Grau D
	ENCHANTGRADE_C - Grau C
	ENCHANTGRADE_B - Grau B
	ENCHANTGRADE_A - Grau A

Exemplo para obter Arma Carmesim com propriedade Fantasma:
	// +9 Adaga Carmesim [2]
	setarray .@OptID[0],RDMOPT_WEAPON_ATTR_TELEKINESIS;
	setarray .@OptVal[0],0;
	setarray .@OptParam[0],0;
	getitembound3 28705,1,1,9,0,0,0,0,0,BOUND_CHAR,.@OptID,.@OptVal,.@OptParam;

---------------------------------------

*getnameditem <id do item>,<nome do personagem|ID do personagem>;
*getnameditem "<nome do item>",<nome do personagem|ID do personagem>;

Crie um item assinado com o nome do personagem fornecido.

O comando retorna 1 quando o item é criado com sucesso, ou 0 se falha.
A falha ocorre quando:
- Não há nenhum jogador vinculado.
- O nome ou ID do item não é válido.
- O ID/nome do personagem fornecido está offline.

Exemplo:

//Isso dará ao jogador atualmente conectado uma Maçã de Aaron (se Aaron estiver online).
	obter nome do item "Maçã", "Aaron";

//Autoexplicativo (espero).
	if (getnameitem("Apple","Aaron")) {
		mes "Agora você tem uma Maçã de Aaron!";
	}

---------------------------------------

*rentitem <id do item>,<hora>{,<id_da_conta>};
*rentitem "<nome do item>",<hora>{,<id_da_conta>};

Cria um item de aluguel no inventário do personagem anexado. O item irá expirar
em <tempo> segundos e será excluído automaticamente. Ao receber um item alugado,
o personagem receberá uma mensagem na janela de bate-papo. O personagem irá
também recebem mensagens de aviso na janela de bate-papo antes que o item desapareça.

Quando os aluguéis expirarem, ele chamará o UnEquipScript do item. Isso pode ser usado
para casos especiais, como remover uma mudança de status ou reset uma variável ou estado
do jogador.

Este comando não pode ser usado para alugar itens empilháveis. Os itens de aluguel não podem ser
descartado, negociado ou colocado no armazenamento da guilda. (ou seja, máscara de troca 67)
Observação: 'delitem' em um script de NPC ainda pode remover itens alugados.
Nota: 'countitem' não contará nenhum item com um timer de aluguel. Use 'rentalcountitem' em vez disso.

---------------------------------------

*rentitem2 <id do item>,<hora>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>{,<id_da_conta>};
*rentitem2 "<nome do item>",<hora>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>{,<id_da_conta>};
*rentitem3 <id do item>,<hora>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<id_da_conta>};
*rentitem3 "<nome do item>",<hora>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<id_da_conta>};
*rentitem4 <id do item>,<hora>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<nota>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<id_da_conta>};
*rentitem4 "<nome do item>",<hora>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<nota>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<id_da_conta>};

Cria um item de aluguel no inventário do personagem anexado. O item irá expirar
em <tempo> segundos e será automaticamente excluído. Veja 'rentitem' para mais detalhes.

Veja 'getitem2' para uma explicação dos parâmetros expandidos.

'rentitem3' é uma versão avançada de 'rentitem2' que também usa a Opção Aleatória de Item como valores adicionais.
<RandomIDArray> : Variável de matriz de ID para opção aleatória de item, veja db/[pre-]re/item_randomopt_db.yml
<RandomValueArray> : Variável de matriz do valor da opção aleatória do item.
<RandomParamArray> : Variável de matriz do parâmetro da opção aleatória do item.

'rentitem4' é uma versão avançada de 'rentitem3' que também usa a nota como valores adicionais.
As notas válidas são:
	ENCHANTGRADE_NONE - Sem nota
	ENCHANTGRADE_D - Grau D
	ENCHANTGRADE_C - Grau C
	ENCHANTGRADE_B - Grau B
	ENCHANTGRADE_A - Grau A

Exemplo para obter Arma Carmesim com propriedade Fantasma:
	// +9 Adaga Carmesim [2]
	setarray .@OptID[0],RDMOPT_WEAPON_ATTR_TELEKINESIS;
	setarray .@OptVal[0],0;
	setarray .@OptParam[0],0;
	rentitem3 28705,(24*60*60),1,9,0,0,0,0,0,.@OptID,.@OptVal,.@OptParam;

---------------------------------------

*makeitem <id do item>,<quantidade>,"<nome do mapa>",<X>,<Y>{,<canShowEffect>};
*makeitem "<nome do item>",<quantidade>,"<nome do mapa>",<X>,<Y>{,<canShowEffect>};

Este comando criará um item na célula especificada de um mapa.

Como acontece com qualquer item descartado, os itens criados com este comando desaparecerão após
um período de tempo. Usar um valor maior que 1 criará uma única pilha de
quantidade dada, não múltiplas pilhas de 1.

Assim como 'getitem', ele também aceita um campo 'nome em inglês' do banco de dados e cria
Maçãs se o nome não for encontrado.
Se o nome do mapa for fornecido como "this", o mapa em que o personagem invocador está será usado.
Se o sinalizador <canShowEffect> estiver definido como verdadeiro, ele mostrará um efeito de pilar no chão quando for solto, dependendo do sinalizador DropEffect do banco de dados do item.

---------------------------------------

*makeitem2 <id do item>,<quantidade>,"<nome do mapa>",<X>,<Y>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>{,<canShowEffect>};
*makeitem2 "<nome do item>",<quantidade>,"<nome do mapa>",<X>,<Y>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>{,<canShowEffect>};
*makeitem3 <id do item>,<quantidade>,"<nome do mapa>",<X>,<Y>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<canShowEffect>};
*makeitem3 "<nome do item>",<quantidade>,"<nome do mapa>",<X>,<Y>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<canShowEffect>};
*makeitem4 <id do item>,<quantidade>,"<nome do mapa>",<X>,<Y>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<nota>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<canShowEffect>};
*makeitem4 "<nome do item>",<quantidade>,"<nome do mapa>",<X>,<Y>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<nota>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<canShowEffect>};

Este comando criará um item na célula especificada de um mapa. Veja 'makeitem' para
mais detalhes.

Veja 'getitem2' para uma explicação dos parâmetros expandidos.

'makeitem3' é uma versão avançada de 'makeitem2' que também usa a Opção Aleatória de Item como valores adicionais.
<RandomIDArray> : Variável de matriz de ID para opção aleatória de item, veja db/[pre-]re/item_randomopt_db.yml
<RandomValueArray> : Variável de matriz do valor da opção aleatória do item.
<RandomParamArray> : Variável de matriz do parâmetro da opção aleatória do item.

'makeitem4' é uma versão avançada de 'makeitem3' que também usa a nota como valores adicionais.
As notas válidas são:
	ENCHANTGRADE_NONE - Sem nota
	ENCHANTGRADE_D - Grau D
	ENCHANTGRADE_C - Grau C
	ENCHANTGRADE_B - Grau B
	ENCHANTGRADE_A - Grau A

Exemplo para obter Arma Carmesim com propriedade Fantasma:
	// 0,5% de chance de obter +0 Escudo de Valquíria [1]
	// com Resistência Neutra +10% e 5% de redução de dano de Demi-Humano ou Jogador
	// quando Valkyrie Randgris matou
	OnNPCKillEvent:
		if (killedrid == 1751 && rand(0,10000) > 9950) { // Valquíria Randgris
			obtermapxy(.@map$,.@x,.@y,BL_PC);
			setarray .@OptID[0],RDMOPT_ATTR_TOLERACE_NADA,RDMOPT_RACE_TOLERACE_HUMAN;
			setarray .@OptVal[0],10,5;
			setarray .@OptParam[0],0;
			makeitem3 2115,1,.@mapa$,.@x,.@y,0,0,0,0,0,0,0,.@OptID,.@OptVal,.@OptParam;
		}
		end;

---------------------------------------

*cleanarea "<nome do mapa>",<x1>,<y1>,<x2>,<y2>;
*cleanmap "<nome do mapa>";

Esses comandos limparão todos os itens que estão no chão no mapa especificado, seja
dentro do retângulo x1/y1-x2/y2 ou em todo o mapa.

---------------------------------------

*searchitem <nome do array>,"<nome do item>";

Este comando preencherá a matriz fornecida com o ID dos itens cujo nome corresponde
o dado. Ele retorna o número de itens encontrados. Por razões de desempenho,
a matriz de resultados é limitada a 10 itens.

	mes "Que item você está procurando?";
	entrada .@nome$;
	.@qty = item de pesquisa(.@corresponde[0],.@nome$);
	mes "Eu encontrei " + .@qty + " itens:";
	para (.@i = 0; .@i < .@qty; .@i++)
		// Nome de exibição (por exemplo: "Apple[0]")
		mes getitemname(.@matches[.@i]) + "[" + getitemslots(.@matches[.@i]) + "]";

---------------------------------------

*delitem <id do item>,<valor>{,<ID da conta>};
*delitem "<nome do item>",<quantidade>{,<ID da conta>};

Este comando removerá uma quantidade específica de itens do personagem invocador/alvo.
Como todos os comandos de item, ele usa o ID do item encontrado em 'db/item_db.yml'.

    delitem 502,10; // A pessoa perderá 10 maçãs
    delitem 617,1; // A pessoa perderá 1 Caixa Violeta Velha

É sempre uma boa ideia verificar se o jogador realmente possui os itens antes de excluí-los.
Se você tentar excluir mais itens que o jogador possui, o jogador perderá os que ele/ela possui
e o script será encerrado com um erro.

Assim como 'getitem', este comando também aceitará um campo 'nome em inglês' do
banco de dados. Se o nome não for encontrado, nada será excluído.

---------------------------------------

*cartdelitem <id do item>,<valor>{,<ID da conta>};
*cartdelitem "<nome do item>",<valor>{,<ID da conta>};
*storagedelitem <id do item>,<quantidade>{,<ID da conta>};
*storagedelitem "<nome do item>",<quantidade>{,<ID da conta>};
*guildstoragedelitem <id do item>,<quantidade>{,<ID da conta>};
*guildstoragedelitem "<nome do item>",<quantidade>{,<ID da conta>};

Este comando se comporta de forma idêntica ao 'delitem', mas exclui itens do jogador
carrinho, armazenamento ou armazenamento de guilda.

Se nenhum carrinho for montado, 'cartdelitem' retornará -1.
Se o jogador não estiver em uma guilda ou o armazenamento estiver aberto, 'guildstoragedelitem' retornará -1.

---------------------------------------

*delitem2 <id do item>,<quantidade>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>{,<ID da conta>};
*delitem2 "<nome do item>",<quantidade>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>{,<ID da conta>};
*delitem3 <id do item>,<quantidade>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<ID da conta>};
*delitem3 "<nome do item>",<quantidade>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<ID da conta>};
*delitem4 <id do item>,<quantidade>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<nota>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<ID da conta>};
*delitem4 "<nome do item>",<quantidade>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<nota>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<ID da conta>};

Este comando removerá uma quantidade específica de itens do personagem invocador/alvo.
Veja 'getitem2' para uma explicação dos parâmetros expandidos.

'delitem3' é uma versão avançada do 'delitem2' que também usa a Opção Aleatória de Item como critério.
<RandomIDArray> : Variável de matriz de ID para opção aleatória de item, veja db/[pre-]re/item_randomopt_db.yml
<RandomValueArray> : Variável de matriz do valor da opção aleatória do item.
<RandomParamArray> : Variável de matriz do parâmetro da opção aleatória do item.

'delitem4' é uma versão avançada de 'delitem3' que também usa a nota como critério.

---------------------------------------

*delitemidx <índice>{,<quantidade>{,<id do caractere>}}

Este comando removerá um item no índice de inventário fornecido.

Se <quantidade> não for especificado, isso removerá todos os itens no índice especificado.

A única maneira de obter o índice de inventário é usando 'getinventorylist()'. Após excluir
um item no índice fornecido, esse índice pode permanecer vazio até que o jogador faça login novamente, exigindo
'getinventorylist()' seja chamado novamente. Se um item for excluído com um índice inválido, o
o script terminará com um erro.

Este comando retorna verdadeiro em caso de sucesso e falso se o item no índice fornecido não puder ser excluído ou se
não havia itens suficientes disponíveis no índice fornecido.

Exemplo:

	// Isso removerá todas as Poções Vermelhas do inventário do jogador
	obterlistadeinventário();
	para (.@i = 0; .@i < @inventorylist_count; ++.@i)
		if (@inventorylist_id[.@i] == 501)
			delitemidx @inventorylist_idx[.@i];

---------------------------------------

*cartdelitem2 <id do item>,<quantidade>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>{,<ID da conta>};
*cartdelitem2 "<nome do item>",<quantidade>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>{,<ID da conta>};
*storagedelitem2 <id do item>,<quantidade>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>{,<ID da conta>};
*storagedelitem2 "<nome do item>",<quantidade>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>{,<ID da conta>};
*guildstoragedelitem2 <id do item>,<quantidade>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>{,<ID da conta>};
*guildstoragedelitem2 "<nome do item>",<quantidade>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>{,<ID da conta>};

Este comando se comporta de forma idêntica ao 'delitem2', mas exclui itens do jogador
carrinho, armazenamento ou armazenamento de guilda.

Se nenhum carrinho for montado, 'cartdelitem2' retornará -1.
Se o jogador não estiver em uma guilda ou o armazenamento estiver aberto, 'guildstoragedelitem2' retornará -1.

---------------------------------------

*countitem(<id do item>{,<ID da conta>})
*countitem("<nome do item>"{,<IDdaconta>})

Esta função retornará o número de itens para o ID do item especificado que o
o personagem invocador tem no inventário.

	mes "[Verificador de Itens]";
	mes "Hmmm, parece que você tem " + countitem(502) + " maçãs";
	close;

Assim como 'getitem', esta função também aceitará um 'nome em inglês' do
banco de dados como argumento.

Se você quiser indicar o número no final de uma frase, você pode fazê-lo por
somando strings:

	mes "[Verificador de Itens]";
	mes "Hmmm, o número total de maçãs que você está segurando é " + countitem("APPLE");
	close;

---------------------------------------

*cartcountitem(<id do item>{,<id da conta>})
*cartcountitem("<nome do item>"{,<IDdaconta>})
*storagecountitem(<id do item>{,<id da conta>})
*storagecountitem("<nome do item>"{,<ID da conta>})
*guildstoragecountitem(<nomeID>{,<contaID>})
*guildstoragecountitem("<nome do item>"{,<ID da conta>})

Este comando se comporta de forma idêntica ao 'countitem', mas conta os itens do jogador
carrinho, armazenamento ou armazenamento de guilda.

Se nenhum carrinho for montado, 'cartcountitem' retornará -1.
Se o jogador não estiver em uma guilda ou o armazenamento estiver aberto, 'guildstoragecountitem' retornará -1.

---------------------------------------

*countitem2(<id do item>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>{,<IDdaconta>})
*countitem2("<nome do item>",<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>{,<IDdaconta>})
*countitem3(<id do item>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<accountID>})
*countitem3("<nome do item>",<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<accountID>})
*countitem4(<id do item>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<nota>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<accountID>})
*countitem4("<nome do item>",<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<nota>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<accountID>})

Versão expandida da função 'countitem', usada para itens criados/cardados/forjados.

Esta função retornará o número de itens para o ID do item especificado e
outros parâmetros que o personagem invocador tem no inventário.
Veja 'getitem2' para uma explicação dos parâmetros expandidos.

'countitem3' é uma versão avançada de 'countitem2' que também usa a Opção Aleatória de Item como critério.
<RandomIDArray> : Variável de matriz de ID para opção aleatória de item, veja db/[pre-]re/item_randomopt_db.yml
<RandomValueArray> : Variável de matriz do valor da opção aleatória do item.
<RandomParamArray> : Variável de matriz do parâmetro da opção aleatória do item.

'countitem4' é uma versão avançada de 'countitem3' que também usa a nota como critério.

---------------------------------------

*cartcountitem2(<id do item>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>{,<IDdaconta>})
*cartcountitem2("<nome do item>",<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>{,<IDdaconta>})
*storagecountitem2(<id do item>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>{,<IDdaconta>})
*storagecountitem2("<nome do item>",<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>{,<IDdaconta>})
*guildstoragecountitem2(<nomeID>,<Identificado>,<Refinar>,<Atributo>,<Cartão0>,<Cartão1>,<Cartão2>,<Cartão3>{,<IDdaconta>})
*guildstoragecountitem2("<nome do item>",<Identificado>,<Refinar>,<Atributo>,<Cartão0>,<Cartão1>,<Cartão2>,<Cartão3>{,<IDdaconta>})

Este comando se comporta de forma idêntica ao 'countitem2', mas conta os itens do jogador
carrinho, armazenamento ou armazenamento de guilda.

Se nenhum carrinho estiver montado, 'cartcountitem2' retornará -1.
Se o jogador não estiver em uma guilda ou o armazenamento estiver aberto, 'guildstoragecountitem2' retornará -1.

---------------------------------------

*rentalcountitem(<id do item>{,<id da conta>})
*rentalcountitem("<nome do item>"{,<IDdaconta>})

Esta função retornará o número de itens de aluguel para o ID do item especificado que o
o personagem invocador tem no inventário.

---------------------------------------

*rentalcountitem2(<id do item>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>{,<IDdaconta>})
*rentalcountitem2("<nome do item>",<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>{,<IDdaconta>})
*rentalcountitem3(<id do item>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<accountID>})
*rentalcountitem3("<nome do item>",<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<accountID>})
*rentalcountitem4(<id do item>,<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<nota>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<accountID>})
*rentalcountitem4("<nome do item>",<identificar>,<refinar>,<atributo>,<cartão1>,<cartão2>,<cartão3>,<cartão4>,<nota>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<accountID>})

Versão expandida da função 'rentalcountitem', usada para itens criados/cardados/falsificados.

Esta função retornará o número de itens de aluguel para o ID do item especificado e
outros parâmetros que o personagem invocador tem no inventário.
Veja 'getitem2' para uma explicação dos parâmetros expandidos.

'rentalcountitem3' é uma versão avançada de 'rentalcountitem2' que também usa a Opção Aleatória de Item como critério.
<RandomIDArray> : Variável de matriz de ID para opção aleatória de item, veja db/[pre-]re/item_randomopt_db.yml
<RandomValueArray> : Variável de matriz do valor da opção aleatória do item.
<RandomParamArray> : Variável de matriz do parâmetro da opção aleatória do item.

'rentalcountitem4' é uma versão avançada de 'rentalcountitem3' que também usa a nota como critério.

---------------------------------------

*countbound({<tipo de limite>{,<id_char>}})

Esta função retornará o número de itens delimitados diferentes no caractere
inventário e define as matrizes @bound_items[] e @bound_amount[] contendo todos os IDs de itens do
itens contados e suas respectivas quantidades. Se um tipo vinculado for especificado, somente esses itens serão contados.

Para uma lista de tipos vinculados, consulte 'getitembound'.

Exemplo:
	.@total_type = contagemlimitada();
	mes "Você atualmente tem " + .@total_type + " diferentes tipos de itens delimitados.";
	next;
	mes "A lista de itens delimitados inclui:";
	for(.@i = 0; .@i < .@total_type; .@i++)
		mes "x" + @bound_amount[.@i] + " " + getitemname(@bound_items[.@i]);
	close;

---------------------------------------

*groupranditem <id do grupo>{,<sub_grupo>};

Retorna o item_id de um item aleatório escolhido do grupo especificado. O
diferentes grupos e seus números de grupo são especificados em 'db/(pre-)re/item_group_db.yml'.

Quando usado em conjunto com outras funções, você pode obter um item aleatório. Para
exemplo, para uma isca de animal de estimação aleatória:

getitem groupranditem(IG_Taming),1;

'sub_group' é usado para obter os itens aleatórios disponíveis do grupo de itens de um grupo aleatório especificado
grupo. 0 para grupo de itens 'obrigatórios' e grupo de itens aleatórios é de 1 a 5 (MAX_ITEMGROUP_RANDGROUP+1).

Mais informações, veja doc/item_group.txt.

---------------------------------------

*getrandgroupitem <id_grupo>{,<quantidade>{,<sub_grupo>{,<identificar>{,<id_caractere>}}}};

Semelhante ao exemplo acima, este comando permite que os jogadores obtenham o especificado
quantidade de um item aleatório do grupo "<id do grupo>". Os diferentes grupos e
o número do grupo é especificado em db/(pre-)re/item_group_db.yml

Se 'quantidade' não for definida ou for 0, será usada a quantidade definida na lista de Grupos de Itens.

Se 'sub_group' não for definido, o valor será 1 (já que o grupo aleatório é 1 ~ 5 e 0 é
grupo de itens 'obrigatórios').

Para itens com tipo IT_WEAPON, IT_ARMOR, IT_PETARMOR e IT_SHADOWGEAR serão fornecidos
como item não identificado (conforme definido por itemdb_isidentified em src/map/itemdb.cpp), exceto
se 'identificar' for definido com valor 1.

Mais informações, veja doc/item_group.txt.

---------------------------------------

*getgroupitem <id_do_grupo>{,<identificar>{,<id_do_caractere>}};

Dá item(ns) ao jogador anexado com base no conteúdo do grupo de itens.
Isso não funciona como 'getrandgroupitem' que fornece apenas 1 item para o especificado
grupo de itens e subgrupo.

Para itens com tipo IT_WEAPON, IT_ARMOR, IT_PETARMOR e IT_SHADOWGEAR serão fornecidos
como item não identificado (conforme definido por itemdb_isidentified em src/map/itemdb.cpp), exceto
se 'identificar' for definido com valor 1.

Mais informações, veja doc/item_group.txt.

---------------------------------------

*habilitar_itens;
*desabilitar_itens;

Esses comandos alternam a capacidade de alterar o equipamento ao interagir com
um NPC. Para evitar possíveis explorações, os comandos afetam o script específico
somente instância. Observe que se um script diferente também chamar enable_items, ele
irá substituir a última chamada (então você pode querer chamar este comando no início
do seu script sem assumir que ele ainda está em vigor).

A configuração padrão, 'item_enabled_npc', é definida em 'conf/battle/items.conf'.

---------------------------------------

*itemskill <id da habilidade>,<nível da habilidade>{,<manter requisito>};
*itemskill "<nome da habilidade>",<nível da habilidade>{,<manter requisito>};

Este comando é destinado a scripts de itens para replicar habilidades de uso único em utilizáveis
itens. Não funcionará corretamente se houver uma janela de diálogo ou menu visível ou se o item não for do tipo 'Delayconsume'.
Se a habilidade for de auto-alvo ou de auto-alvo, ela será usada imediatamente; caso contrário, uma
o cursor de destino é exibido.

Se o parâmetro <manter requisito> for definido como verdadeiro, os requisitos da habilidade serão verificados.
Por padrão, os requisitos para habilidades de itens não são verificados e, portanto, o valor padrão é falso.

// Quando Anodyne é usado, ele lançará Endure (8), Nível 1, como se a habilidade real tivesse sido usada da árvore de habilidades.
  - Identidade: 605
    AegisNome: Anodyne
    Nome: Anodyne
    Tipo: Atraso no consumo
    Comprar: 2000
    Peso: 100
    Bandeiras:
      BuyingStore: verdadeiro
    Roteiro: |
      itenskill "SM_ENDURE",1;

// Quando Sienna_Execrate_Scroll_1_5 é usado, ele lançará Sienna Execrate Nível 5 e consumirá 2 Red_Gemstones.
  - Identidade: 23194
    Nome da Égide: Sienna_Execrate_Scroll_1_5
    Nome: Nível 5 Sienna Execrate
    Tipo: Atraso no consumo
    Comprar: 10
    Peso: 10
    Roteiro: |
      itenskill "WL_SIENNAEXECRATE",5,verdadeiro;

---------------------------------------

*consumoitem <id do item>{,<char_id>};
*consumeitem "<nome do item>"{,<char_id>};

Este comando executará o script do item especificado na chamada
personagem. O personagem não precisa possuir o item, e o item irá
não pode ser excluído. Embora este comando seja destinado a itens utilizáveis, ele será executado
para qualquer tipo de item.

Este comando não funciona atualmente com o comando de script 'itemskill'.

---------------------------------------

*produzir <nível do item>;

Este comando abrirá uma janela de criação no cliente conectado ao invocador
personagem. O 'nível do item' é um número que determina que tipo de criação
uma janela aparecerá.

Você pode ver a lista completa desses níveis de itens em 'db/produce_db.txt' que determina
o que pode realmente ser produzido. A janela não estará vazia somente se a invocação
personagem pode realmente produzir itens desse tipo e tem a matéria-prima apropriada
materiais em seu inventário.

A taxa de sucesso para produzir o item é a mesma que a taxa de sucesso da habilidade
associado ao nível do item. Se não houver id de habilidade, a taxa de sucesso será de 50%.

Os níveis de itens válidos são:

1 - Armas de nível 1
2 - Armas de nível 2
3 - Armas de nível 3
21 - Pedras e Metais de Ferreiro
22 - Poções do Alquimista, Água Benta, Veneno Mortal da Cruz Assassina
23 - Conversores Elementares

---------------------------------------

*cozinhar <nível do prato>;

Este comando abrirá uma janela de produção no cliente conectado ao invocador
personagem. O 'nível do prato' é o número que determina que tipo de prato
nível que você pode produzir. Você pode ver a lista completa de pratos que podem ser produzidos em
'db/produce_db.txt'.

A janela será mostrada vazia se o caractere de invocação não tiver o suficiente
os ingredientes necessários para cozinhar um prato.

Os níveis de pratos válidos são:

11 - Prato Nível 1
12 - Prato Nível 2
13 - Prato Nível 3
14 - Prato Nível 4
15 - Prato Nível 5
16 - Prato Nível 6
17 - Prato Nível 7
18 - Prato Nível 8
19 - Prato Nível 9
20 - Prato Nível 10

Embora seja necessário set um nível de prato, não importa se você o define como 1
e você quer cozinhar um prato de nível 10, desde que tenha os ingredientes necessários
para cozinhar o prato o comando funciona.

---------------------------------------

*makerune <% bônus de sucesso>{,<char_id>};

Este comando abrirá uma janela de criação de runas no cliente conectado ao
invocando personagem. Como esse comando é usado oficialmente em minérios rúnicos, um bônus
a taxa de sucesso deve ser especificada (o que é adicionado à fórmula base).

Você pode ver a lista completa de runas que podem ser produzidas em 'db/produce_db.txt'.
A janela não estará vazia somente se o caractere de invocação puder realmente produzir
uma runa e tem as matérias-primas apropriadas em seu inventário.

---------------------------------------

*successremovecards <slot de equipamento>;

Este comando removerá todos os cartões dos slots de cartões definidos em db/item_db.yml
do item encontrado no slot de equipamento especificado do personagem invocador,
crie novos itens de carta e dê-os ao personagem.
Se alguma carta for removida dessa maneira, também será mostrado um efeito de sucesso.

---------------------------------------

*failedremovecards <slot de equipamento>,<tipo>;

Este comando removerá todas as cartas do item encontrado no local especificado
slot de equipamento do personagem invocador. 'tipo' determina o que acontece com o
item e as cartas:

0 - destruirá tanto o item quanto as cartas.
1 - manterá o item, mas destruirá as cartas.
2 - manterá as cartas, mas destruirá o item.

Seja qual for o tipo, ele também mostrará um efeito de falha na tela.

---------------------------------------

*reparar <número do item quebrado>{,<char_id>};

Este comando repara um equipamento quebrado, usando a mesma lista de peças quebradas
itens disponíveis através de 'getbrokenid'.

---------------------------------------

*reparar todos {<char_id>};

Este comando repara todos os equipamentos quebrados no inventário do jogador anexado.
Um efeito de reparo será mostrado se algum item for reparado, caso contrário, o comando irá
terminar silenciosamente.

---------------------------------------

*successrefitem <slot de equipamento>{,<contagem>{,<id_char>}};

Este comando refinará um item no slot de equipamento especificado do invocador
personagem por +1, ou uma contagem se fornecida. Para uma lista de slots de equipamento, veja 'getequipid'.
Este comando também exibirá um efeito de 'refinamento de sucesso' no personagem e colocará
mensagens apropriadas em sua janela de bate-papo. Isso também dará fama ao personagem
pontos se uma arma atingir +10 dessa forma, mesmo que estes só tenham efeito por
ferreiro que mais tarde forjará uma arma.

---------------------------------------

*failedrefitem <slot de equipamento>{,<char_id>};

Este comando falhará ao refinar um item no slot de equipamento especificado do
invocando o personagem. O item será destruído. Isso também exibirá um 'refine
efeito de falha no personagem e colocar mensagens apropriadas em seu bate-papo
janela.

---------------------------------------

*downrefitem <slot de equipamento>{,<contagem>{,<id_char>}};

Este comando irá rebaixar um item no slot de equipamento especificado do invocador
caractere por -1, ou uma contagem se fornecido. Para uma lista de slots de equipamento, veja 'getequipid'.
Este comando também exibirá um efeito de 'falha de refino' no personagem e colocará
mensagens apropriadas na janela de bate-papo.

---------------------------------------

*unequip <slot de equipamento>{,<char_id>};

Este comando desequipará o que estiver equipado no momento na invocação
slot de equipamento especificado do personagem. Para uma lista completa de equipamentos possíveis
slots veja 'getequipid'.

Se um item ocupar vários espaços de equipamento, ele será desequipado de todos eles.
eles.

---------------------------------------

*delequip <slot de equipamento>{,<char_id>};

Este comando destruirá tudo o que estiver equipado no invocador
slot de equipamento especificado do personagem. Para uma lista completa de equipamentos possíveis
slots veja 'getequipid'.

Este comando retornará 1 se um item foi excluído e 0 caso contrário.

---------------------------------------

*breakequip <slot de equipamento>{,<char_id>};

Este comando quebrará e desequipará tudo o que estiver equipado no momento.
invocando o slot de equipamento especificado do personagem. Para uma lista completa de possíveis
slots de equipamento veja 'getequipid'.

Este comando retornará 1 se um item estiver quebrado e 0 caso contrário.

---------------------------------------

*limpar item {<char_id>};

Este comando destruirá todos os itens que o personagem invocador tem em seu
inventário (incluindo itens equipados). Não afetará nada mais, como
armazenamento ou carrinho.

---------------------------------------

*equipar <id do item>{,<id_do_caractere>};
*autoequip <id do item>,<opção>;

Esses comandos servem para equipar um equipamento no personagem anexado.
A função equipar equipará o ID do item fornecido quando o jogador tiver
este item em seu inventário, enquanto a função de autoequipamento irá
equipar o ID do item fornecido quando este for saqueado. O parâmetro de opção de
o autoequip é 1 ou 0, 1 para ligá-lo e 0 para desligá-lo.

Exemplos:

//Isso equipará um 1104 (falchion) no personagem, se estiver no inventário.
	equipar 1104;

//O personagem invocado agora equipará automaticamente uma cimitarra quando ela for saqueada.
	autoequipamento 1104,1;

//O personagem invocado não equipará mais uma cimitarra automaticamente.
	autoequipamento 1104,0;

---------------------------------------

*buyingstore <slots>;

Invoca a janela de preparação da loja de compras, como a habilidade 'Abrir loja de compras',
sem o requisito do item. A quantidade de slots é limitada pelo servidor para
um máximo de 5 slots por padrão.

Exemplo:
	// Dá ao jogador a oportunidade de comprar 4 tipos diferentes de itens.
	comprandoloja 4;

---------------------------------------

*searchstores <usos>,<efeito>{,"<nome do mapa>"};

Invoca a janela de pesquisa da loja, que permite pesquisar tanto por vendas
e comprar lojas.

O parâmetro <uses> indica quantas pesquisas podem ser iniciadas
antes que a janela tenha que ser reaberta.

O parâmetro <efeito> afeta o que acontece quando um item de resultado é clicado duas vezes
e pode ser um dos seguintes:

	SEARCHSTORE_EFFECT_NORMAL: Mostra a posição da loja no minimapa e destaca a
								placa de loja com cor amarela, quando a loja está no mesmo mapa
								como o jogador que invoca.
	SEARCHSTORE_EFFECT_REMOTE: Abre a loja diretamente, independentemente da distância.
	
O parâmetro opcional <nome do mapa> indica o nome do mapa onde as lojas serão pesquisadas.
Se não for definido, a busca será feita no mapa em que o personagem que o invoca está atualmente.
Valores especiais para <nome do mapa> são:

	"this": pesquisará lojas no mapa onde o personagem invocador está atualmente. (padrão)
	"all": pesquisará lojas em todos os mapas.

Exemplos:
	// Item Vending_Search_Scroll (10 usos, efeito: mostrar marca no minimapa, mapa atual)
	lojas de pesquisa 10, SEARCHSTORE_EFFECT_NORMAL;
	
	// Pesquisar lojas (1 uso, efeito: abrir loja, todos os mapas no servidor)
	searchstores 1, SEARCHSTORE_EFFECT_REMOTE, "todos";

---------------------------------------

*enable_command;
*disable_command;

Esses comandos alternam a capacidade de usar atcommand ao interagir com um NPC.

A configuração padrão, 'atcommand_disable_npc', é definida em 'conf/battle/gm.conf'.

---------------------------------------
//
4,1.- Fim dos comandos relacionados a itens
//
---------------------------------------

*armazenamento aberto;

Isso abrirá a janela de armazenamento Kafra do personagem no cliente conectado ao
invocando personagem. Pode ser usado de qualquer tipo de NPC ou script de item, não apenas
limitado à equipe da Kafra.

A janela de armazenamento abre independentemente de haver diálogos de NPC abertos ou
não, mas é preferível fechar a caixa de diálogo antes de exibir o armazenamento
janela, para evitar qualquer interrupção quando ambas as janelas se sobrepõem.

    mes "Feche esta janela para abrir seu armazenamento.";
    close2;
    armazenamento aberto;
    end;

---------------------------------------

*openstorage2 <id_de_armazenamento>{,<modo>{,<id_da_conta>}};

Assim como o comando 'openstorage', exceto que este comando pode abrir armazenamentos adicionais
pelo <storage_id> especificado. Para <storage_id>, leia o conf/inter_server.yml
para grupos de armazenamento.

Os valores para <mode> são:
	STOR_MODE_NONE: O jogador só pode ler as entradas de armazenamento.
	STOR_MODE_GET: O jogador pode obter itens do armazenamento.
	STOR_MODE_PUT: O jogador pode colocar itens no armazenamento.
	STOR_MODE_ALL: O jogador pode pegar e colocar itens no armazenamento. (padrão)

Exemplo:
	if (status_vip(STATUS_VIP_ATIVO)) {
		mes "Eu abrirei seu armazenamento Premium.";
		mes "Obrigado por usar nosso serviço.";
		close2;
		armazenamento aberto2 1;
	} outro {
		mes "Desculpe, seu status Premium expirou.";
		mes "O armazenamento será aberto, mas você não poderá colocar nenhum item nele.";
		close2;
		openstorage2 1,MODO_DE_STOR_GET;
	}
	end;

---------------------------------------

*openmail({<id_char>});

Isso abrirá a janela de e-mail de um personagem no cliente conectado ao
invocando personagem.

Este comando não é compatível com o PACKETVER 20150513 ou mais recente.

	mes "Feche esta janela para abrir sua caixa de entrada de e-mail.";
	close2;
	correio aberto;
	end;

---------------------------------------

*mail <id de destino>,"<nome do remetente>","<título>","<corpo>"{,<zeny>{,<matriz de id do item>,<matriz de valor do item>{,refine{,bound{,<matriz de cartão0 do item>{,<matriz de cartão1 do item>{,<matriz de cartão2 do item>{,<matriz de cartão3 do item>
		{,<matriz de id0 de opção aleatória>, <matriz de valor0 de opção aleatória>, <matriz de parâmetro0 de opção aleatória>{,<matriz de id1 de opção aleatória>, <matriz de valor1 de opção aleatória>, <matriz de parâmetro1 de opção aleatória>
		{,<matriz de id2 de opção aleatória>, <matriz de valor2 de opção aleatória>, <matriz de parâmetro2 de opção aleatória>{,<matriz de id3 de opção aleatória>, <matriz de valor3 de opção aleatória>, <matriz de parâmetro3 de opção aleatória>
		{,<matriz de id4 de opção aleatória>, <matriz de valor4 de opção aleatória>, <matriz de parâmetro4 de opção aleatória>}}}}}}}}};

Este comando enviará um e-mail para <id de destino>, que é um ID de personagem.
Um <nome do remetente> pode ser especificado, mas não precisa ser do criador direto
do e-mail e é limitado a NAME_LENGTH (24) caracteres. O e-mail <título> é limitado
para MAIL_TITLE_LENGTH (40) caracteres. O e-mail <corpo> é limitado a MAIL_BODY_LENGTH
(200) caracteres para PACKETVER < 20150513 ou 500 caracteres para clientes posteriores.

<zeny> opcional e dados de item podem ser adicionados ao e-mail também. PACKETVER < 20150513
é limitado a 1 item, enquanto os clientes posteriores são limitados a MAIL_MAX_ITEM (5).

<matriz de id do item>, <matriz de quantidade do item>, <matriz de cartão do item0>, <matriz de cartão do item1>,
<item card2 array> e <item card3 array> devem ser todos arrays de inteiros.

Para opções aleatórias, pode haver 5 matrizes em pares de 3 (ids, valores, parâmetros) logo após os cartões.
Todos esses arrays também devem ser arrays inteiros.

Exemplo de envio de e-mail com zeny:
	.@charid = obtercharid(0);
	.@sender$ = "Poring";
	.@title$ = "Bem-vindo";
	.@body$ = "Olá! Sou um simples Poring dos campos de Prontera! Bem-vindo ao Ragnarok!";
	.@zeny = 5000;
	e-mail .@charid, .@sender$, .@title$, .@body$, .@zeny;

Exemplo de envio de correspondência com itens:
	.@charid = obtercharid(0);
	.@sender$ = "Angeling";
	.@title$ = "Bem-vindo";
	.@body$ = "Olá! Sou um simples Angeling dos campos de Prontera! Bem-vindo ao Ragnarok!";
	.@zeny = 0;
	setarray .@mailitem[0], 504, 505, 2220, 1214; // Poção Branca, Poção Azul, Chapéu, Adaga
	setarray .@mailamount[0], 10, 5, 1, 1; // 10 Poções Brancas, 5 Poções Azuis, 1 Chapéu, 1 Adaga
	setarray .@mailrefine[0], 0, 0, 3, 10; // +3 Chapéu, +10 Adaga
	setarray .@mailbound[0], 0, 0, Bound_Account, Bound_Char; // Chapéu limitado à conta, Adaga limitada ao caractere
	setarray .@mailcard0[0], 0, 0, 4198, 4092; // Anexar o Cartão Roxo Maya ao Chapéu, Anexar o Cartão Trabalhador Esqueleto à Adaga
	setarray .@mailcard1[0], 0, 0, 0, 4092; // Anexar Cartão de Trabalhador Esqueleto à Adaga
	setarray .@mailcard2[0], 0, 0, 0, 4092; // Anexar cartão de trabalhador esqueleto à adaga
	e-mail .@charid, .@sender$, .@title$, .@body$, .@zeny, .@mailitem, .@mailamount, .@mailrefine, .@mailbound, .@mailcard0, .@mailcard1, .@mailcard2;
	
Exemplo de envio de e-mail com itens e opções aleatórias:
	.@charid = obtercharid(0);
	.@sender$ = "Angeling";
	.@title$ = "Bem-vindo";
	.@body$ = "Olá! Sou um simples Angeling dos campos de Prontera! Bem-vindo ao Ragnarok!";
	.@zeny = 0;
	setarray .@mailitem[0], 504, 505, 2220, 1214; // Poção Branca, Poção Azul, Chapéu, Adaga
	setarray .@mailamount[0], 10, 5, 1, 1; // 10 Poções Brancas, 5 Poções Azuis, 1 Chapéu, 1 Adaga
	setarray .@mailrefine[0], 0, 0, 3, 10; // +3 Chapéu, +10 Adaga
	setarray .@mailbound[0], 0, 0, Bound_Account, Bound_Char; // Chapéu limitado à conta, Adaga limitada ao caractere
	setarray .@mailcard0[0], 0, 0, 4198, 4092; // Anexar o Cartão Roxo Maya ao Chapéu, Anexar o Cartão Trabalhador Esqueleto à Adaga
	setarray .@mailcard1[0], 0, 0, 0, 4092; // Anexar Cartão de Trabalhador Esqueleto à Adaga
	setarray .@mailcard2[0], 0, 0, 0, 4092; // Anexar cartão de trabalhador esqueleto à adaga
	setarray .@mailcard3[0], 0, 0, 0, 0; // Esvaziar último slot
	setarray .@mailrndopt_id0[0], 0, 0, 0, RDMOPT_VAR_MAXHPAMOUNT; // Encante a Adaga com a opção de HP aumentada
	setarray .@mailrndopt_val0[0], 0, 0, 0, 1000; // Encante a Adaga com a opção de HP aumentada em 1000 pontos
	setarray .@mailrndopt_prm0[0], 0, 0, 0, 0; // Encantar a Adaga com opção de HP aumentado - não precisa de nenhum parâmetro
	e-mail .@charid, .@sender$, .@title$, .@body$, .@zeny, .@mailitem, .@mailamount, .@mailrefine, .@mailbound, .@mailcard0, .@mailcard1, .@mailcard2, .@mailcard3, .@mailrndopt_id0, .@mailrndopt_val0, .@mailrndopt_prm0;

---------------------------------------

*openauction({<char_id>});

Isso abrirá a janela de leilão no cliente conectado ao personagem invocador.

	mes "Feche esta janela para abrir a janela do Leilão.";
	close2;
	leilão aberto;
	end;

---------------------------------------
\\
4,2.- Comandos relacionados à guilda
\\
---------------------------------------

*armazenamentodeguildopens()

Esta função funciona da mesma forma que 'openstorage', mas abrirá um armazenamento de guilda
janela em vez do armazenamento da guilda da guilda o personagem invocador pertence
para.

Valores de retorno:
GSTORAGE_OPEN - Aberto com sucesso.
GSTORAGE_STORAGE_ALREADY_OPEN - O armazenamento do jogador já está aberto.
GSTORAGE_ALREADY_OPEN - O armazenamento da guilda já está aberto.
GSTORAGE_NO_GUILD - O jogador não está em uma guilda.
GSTORAGE_NO_STORAGE - A guilda não investiu na habilidade Expansão de Armazenamento da Guilda (somente se OFFICIAL_GUILD_STORAGE estiver habilitado).
GSTORAGE_NO_PERMISSION - O jogador não tem permissão para usar o armazenamento da guilda.

---------------------------------------

*guildopenstorage_log({<id do caractere>})

Abre a janela de registro de armazenamento da guilda para o personagem anexado ou para o ID de personagem fornecido.

Valores de retorno possíveis:
A janela GUILDSTORAGE_LOG_FINAL_SUCCESS foi aberta com sucesso.
A janela GUILDSTORAGE_LOG_EMPTY não foi aberta porque não existem entradas.
GUILDSTORAGE_LOG_FAILED Ocorreu algum erro no banco de dados.

---------------------------------------

*guild_has_permission(<permissão>{,<id do caractere>})

Verifica se o jogador anexado ou o jogador com o ID de personagem fornecido tem a(s) permissão(ões) fornecida(s).
A permissão pode ser uma máscara de bits e permite usar vários valores ao mesmo tempo.
Retorna verdadeiro se o jogador tiver todas as permissões fornecidas ou falso se o jogador tiver pelo menos
não possui uma das permissões fornecidas ou não faz parte de nenhuma guilda.

As permissões disponíveis são:
GUILD_PERM_INVITE Se um jogador tem permissão para convidar outros jogadores.
GUILD_PERM_EXPEL Se um jogador tem permissão para expulsar outros membros da guilda.
GUILD_PERM_STORAGE Se um jogador tiver permissão para acessar o armazenamento da guilda.
GUILD_PERM_ALL Uma combinação de todas as permissões acima.

---------------------------------------

*guildchangegm(<id da guilda>,<nome do novo mestre>)

Esta função mudará o Guild Master de uma guilda. O ID é o ID da guilda
id, e o nome do novo mestre da guilda deve ser passado.

Retorna 1 em caso de sucesso, 0 caso contrário.

---------------------------------------

*guildgetexp <quantidade>;

Isso dará a quantidade especificada de pontos de experiência da guilda para a guilda
invocando o personagem pertence a. Ele falhará silenciosamente se eles não pertencerem a
qualquer guilda.

---------------------------------------

*guildskill <id da habilidade>,<nível>
*guildskill "<nome da habilidade>",<nível>

Este comando aumentará a habilidade da guilda especificada pelo número especificado de
níveis. Isso se refere ao personagem invocador e só funcionará se o personagem invocador
personagem é membro de uma guilda E seu mestre de guilda, caso contrário, não há falha
mensagem será dada e nenhum erro ocorrerá, mas nada acontecerá - o mesmo
sobre a habilidade da guilda tentando exceder o máximo possível. A lista completa de
as habilidades da guilda estão disponíveis em 'db/(pre-)re/skill_db.yml', essas são todas as habilidades do GD_
o fim.

// Isso daria à guilda do seu personagem um nível de Aprovação (GD_APPROVAL ID
// 10000). Observe que se você tentar adicionar dois níveis de aprovação ou adicionar
// Aprovação quando a guilda já tem, ela só terá um nível de
// Aprovação posterior.
	habilidade de guilda 10000,1,0;

Você pode querer fazer uma missão para obter uma certa habilidade de guilda, torne-a difícil
o suficiente para que toda a guilda precise ajudar ou algo assim. Fazendo isso pela Glória
da habilidade da Guilda, que permite que sua guilda use um emblema, é uma boa ideia para
uma busca divertida.

---------------------------------------
//
4,2 Fim dos comandos relacionados à guilda.
//
---------------------------------------

*resetlvl <tipo de ação>{,<char_id>};

Este é um comando de redefinição de caracteres, destinado principalmente ao suporte de script de renascimento
Trabalhos avançados, que resetão as estatísticas e o nível do personagem que invoca
dependendo do tipo de ação dado. Os tipos de ação válidos são:

1 - Nível base 1, Nível de trabalho 1, 0 pontos de habilidade, 0 exp base, 0 exp de trabalho, limpa o
     efeitos de status (apenas aqueles configuráveis ​​por 'setoption'), define todas as estatísticas como 1.
     Se o novo trabalho for 'Novice High', dê 100 pontos de status, dê Primeiros Socorros e
     Habilidades de fingir de morto.
2 - Nível base 1, nível de trabalho 1, 0 pontos de habilidade, 0 experiência base, 0 experiência de trabalho.
     Habilidades e valores de atributos não são alterados.
3 - Nível base 1, exp base 0. Nada mais é alterado.
4 - Nível de trabalho 1, experiência de trabalho 0. Nada mais é alterado.

Em todos os casos, tudo o que o personagem estiver vestindo estará desequipado.

Mesmo que não retorne um valor, ele é usado como uma função no oficial
scripts de renascimento. Pergunte à AppleGirl por quê.

---------------------------------------

*resetstatus({<id_char>});

Este é um comando de redefinição de personagem, que resetá as estatísticas no invocador
personagem e devolver todos os pontos de atributo usados ​​para aumentá-lo anteriormente.
Nada acontecerá com nenhum outro número sobre o personagem.

Usado em NPCs reiniciados (duh!)

---------------------------------------

*resetskill({<id_char>});

Este comando retira todos os pontos de habilidade do personagem que invoca, então eles
só tem a Habilidade Básica apagada (nível 0) restante e retorna os pontos para eles
para gastar novamente. Nada mais mudará, exceto as habilidades. As habilidades de missão também
reset se a opção 'quest_skill_reset' estiver definida como Sim em 'battle_athena.conf'. Se
a opção 'quest_skill_learn' está definida lá, os pontos nas habilidades da missão
também contará para o total.

Usado em NPCs reiniciados (duh!)

---------------------------------------

*resetfeel({<id_char>});

Este comando resetá os mapas designados do Gladiador Estelar no personagem que o invocou.
Funciona somente nas classes Gladiador Estelar e Imperador Estelar.

---------------------------------------

*resethate({<id_char>});

Este comando resetá os monstros designados do Gladiador Estelar no personagem que o invocou.
Funciona somente nas classes Gladiador Estelar e Imperador Estelar.

---------------------------------------

*sc_start <tipo de efeito>,<tiques>,<valor 1>{,<taxa>,<sinalizador>{,<GID>}};
*sc_start2 <tipo de efeito>,<tiques>,<valor 1>,<valor 2>{,<taxa>,<sinalizador>{,<GID>}};
*sc_start4 <tipo de efeito>,<tiques>,<valor 1>,<valor 2>,<valor 3>,<valor 4>{,<taxa>,<sinalizador>{,<GID>}};
*sc_end <tipo de efeito>{,<GID>};
*sc_end_class {<id_char>{,<id_job>}};

Esses comandos concederão um efeito de status ao personagem.

O <tipo de efeito> determina qual status é invocado. Isso pode ser um número
ou constante, com os status comuns (principalmente negativos) encontrados em 'src/map/script_constants.hpp'
com o prefixo 'SC_'. Uma lista completa está localizada em 'src/map/status.hpp', embora
elas não estão documentadas atualmente.

A duração do status é dada em <ticks> ou milissegundos.
Use INFINITE_TICK para duração infinita.

Certas mudanças de status recebem um parâmetro adicional <valor 1>, que normalmente
modifica as estatísticas do jogador pelo número ou porcentagem fornecida. Isso difere para cada
status e às vezes é zero.

O valor opcional <taxa> é a chance de o status ser invocado (100 = 1%).
Isto é usado principalmente em scripts de itens. Quando usado em um script de NPC, uma bandeira DEVE
ser definido para que a taxa funcione.

O valor opcional <flag> é como o início da alteração de status será tratado (uma máscara de bits).
SCSTART_NOAVOID: A mudança de status não pode ser evitada.
SCSTART_NOTICKDEF: O tique não pode ser reduzido por estatísticas (padrão).
SCSTART_LOADED: sc_data carregado, então nenhum valor será alterado.
SCSTART_NORATEDEF: A taxa não pode ser reduzida.
SCSTART_NOICON: O ícone de status não será enviado ao cliente

Se um <GID> for fornecido, a mudança de status será invocada no caractere especificado
em vez daquele anexado ao script. Isso só pode ser definido após a configuração
uma taxa e uma bandeira.

'sc_start2' e 'sc_start4' permitem que parâmetros extras sejam passados ​​e são usados ​​apenas
para efeitos que os requeiram. O significado dos valores extras varia dependendo do
tipo de efeito. Para mais informações, leia status_change.txt contendo uma lista de todas as Mudanças de Status
e seu uso de val1, val2, val3 e val4 na fonte.

'sc_end' removerá um efeito de status especificado. Se SC_ALL (-1) for fornecido, ele irá
executar uma remoção completa de todos os status (embora os permanentes sejam reaplicados).

'sc_end_class' funciona como 'sc_end', mas removerá todos os efeitos de status de qualquer classe aprendida
habilidade no personagem invocador. Se <job_id> for fornecido, ele encerrará o efeito para aquele job.

Exemplos:
	// Isso envenenará o personagem que invocou por 10 minutos com 50% de chance.
	sc_start SC_POISON,600000,0,5000;

	// Isso concederá o efeito de Bênção de Nível 10.
	sc_start SC_BENÇÃO,240000,10;

	// Ajustar a resistência do elemento por porcentagem. Exemplo com script de item Resist_Fire:
	// val1: Resistência à água
	// val2: Resistência de terra
	// val3: Resistência ao fogo
	// val4: Resistência ao vento
	sc_start4 ELEMENTO_DE_ARMADURA_SC,1200000,-15,0,20,0;

	// Isso encerrará o status de congelamento do personagem que o invoca.
	sc_end SC_FREEZE;
	
	// Isso encerrará o efeito de qualquer habilidade aprendida pelo personagem que a invocou.
	sc_end_class;
	
	// Isso encerrará o efeito de qualquer habilidade aprendida para o personagem com <char_id> 150000.
	// val1: <id_caractere>
	sc_end_class(150000);
	
	// Isso encerrará o efeito de qualquer habilidade do Arquibispo para o personagem que invocou.
	// val1: <id_caractere>
	// val2: <job_id> do Arcebispo
	sc_end_class(getcharid(0),Job_Arch_Bishop);

Nota: para usar SC_NOCHAT você deve alterar Maneira
	set Manner, -5; // Silenciará um usuário por 5 minutos
	set Manner, 0; // Irá ativar o som de um usuário
	set Manner, 5; // Irá ativar o som de um usuário e impedir o próximo uso de 'Manner'

---------------------------------------

*getstatus(<tipo de efeito>{,<tipo>{,<id_char>}})

Recupera informações sobre um efeito de status específico quando chamado. Dependendo de <tipo>
especificou que a função retornará informações diferentes.

Valores possíveis de <type>:
	- 0 ou indefinido: se o status é ativo
	- 1: o val1 do status
	- 2: o val2 do status
	- 3: o val3 do status
	- 4: o val4 do status
	- 5: a quantidade de tempo em milissegundos que o status permanece

Se <tipo> não for definido ou for definido como 0, a função de script irá
retornar 1 se o status estiver ativo, ou 0 se o status não estiver ativo. Se o status
não está ativo quando qualquer um dos campos <tipo> são fornecidos, esta função de script
sempre retornará 0.

---------------------------------------

*skilleffect <id da habilidade>,<número>{,<ID do jogo>};
*skilleffect "<nome da habilidade>",<número>{,<ID do jogo>};

Este comando exibe os efeitos visuais e sonoros da habilidade fornecida no momento
personagem anexado ou, quando definido, em qualquer unidade com o ID fornecido.
O parâmetro numérico é para habilidade cujo efeito visual
envolve a exibição de um número (de cura ou dano). Observe que este comando
não usará realmente a habilidade, ela é destinada a scripts que simulam
uso de habilidades pelo NPC, como buffs, definindo status apropriado e
exibindo o efeito da habilidade.

	mes "Seja abençoado!";
	// Cura de 2000 HP
	curar 2000,0;
	efeito de habilidade 28.2000;
	// Bênção Nível 10
	sc_start SC_BENÇÃO,240000,10;
	efeito de habilidade 34,0;
	// Aumenta o nível 5 do AGI
	sc_start SC_INCREASEAGI,140000,5;
	efeito de habilidade 29,0;

Isso curará o personagem com 2000 HP, aumentará-o com Bênção Nível 10 e
Aumente o AGI nível 5 e exiba os efeitos apropriados.

---------------------------------------

*npcskilleffect <id da habilidade>,<número>,<x>,<y>;
*npcskilleffect "<nome da habilidade>",<número>,<x>,<y>;

Este comando se comporta de forma idêntica ao 'skilleffect', no entanto, a habilidade do tipo solo
os efeitos serão centralizados nas coordenadas do mapa fornecidas no mesmo mapa que o
o personagem anexado e todos os outros tipos de habilidade serão centralizados no anexado
personagem.

---------------------------------------

*efeito especial <número do efeito>{,<alvo_de_envio>{,"<Nome do NPC>"}};

Este comando exibirá um efeito especial com o número fornecido, centralizado no
coordenadas de NPCs especificados, se houver. Para uma lista completa de números de efeitos especiais
conhecido veja 'doc/effect_list.txt'. Alguns números de efeito são conhecidos por não funcionar em
algumas versões do cliente. (Notavelmente, a chuva está ausente de qualquer executável do cliente
lançado depois de abril de 2005.)

O parâmetro <nome do NPC> exibirá <número do efeito> em outro NPC. Se o NPC
especificado não existe, o comando não fará nada. Ao especificar um NPC,
<send_target> deve ser especificado ao especificar um <Nome NPC>, especificando ÁREA
manterá o comportamento padrão do comando.

	// isso fará com que o NPC "John Doe#1"
	// mostra o efeito "EF_HIT1" especificado por
	// Jane Doe. Eu me pergunto o que John fez...
	mes "[Jane Doe]";
	mes "Bem, eu nunca!";
	efeito especial EF_HIT1,AREA,"John Doe#1";
	close;

---------------------------------------

*specialeffect2 <número do efeito>{,<send_target>{,"<Nome do jogador>"}};

Este comando se comporta de forma idêntica ao 'efeito especial', mas o efeito será
centrado no sprite do personagem invocador.

O parâmetro <nome do jogador> exibirá <número do efeito> em outro jogador diferente do
um atualmente anexado ao script. Assim como com specialeffect, ao especificar
um jogador, <send_target> deve ser fornecido, especificando AREA manterá o padrão
comportamento do comando.

---------------------------------------

*removespecialeffect <número do efeito>{,<send_target>{,"<Nome do NPC>"}};

Trabalho para 2018-10-02+
Este comando se comporta como parâmetro como 'specialeffect', mas é usado para remover o efeito com <número do efeito>
de invocar NPC.

---------------------------------------

*removespecialeffect2 <número do efeito>{,<send_target>{,"<Nome do jogador>"}};

Trabalho para 2018-10-02+
Este comando se comporta como parâmetro do 'specialeffect2', mas é usado para remover o efeito com <número do efeito>
de invocar o personagem.

---------------------------------------

*statusup <estatística>{,<id_char>};

Este comando mudará uma estatística específica do personagem invocador em um
permanentemente. As estatísticas devem ser fornecidas como números, mas você pode usar essas constantes para
substitua-os:

bStr - Força
bVit - Vitalidade
bInt - Inteligência
bAgi - Agilidade
bDex - Destreza
bLuk - Sorte

---------------------------------------

*statusup2 <estatística>,<quantidade>{,<id_caractere>};

Este comando alterará uma estatística específica do personagem invocador pelo
valor especificado permanentemente. O valor pode ser negativo. Veja 'statusup'.

	// Isso diminuirá a Vit de um personagem para sempre.
	statusup2 bVit,-1;
---------------------------------------

*traitstatusup <stat>{,<id_char>};

Este comando mudará uma característica específica do personagem invocador em um
permanentemente. As estatísticas de características devem ser fornecidas como números, mas você pode usar essas constantes para
substitua-os:

bPow - Poder
bSta - Resistência
bWis - Sabedoria
bSpl - Feitiço
bCon - Concentração
bCrt - Criativo

---------------------------------------

*traitstatusup2 <estatística>,<quantidade>{,<id_caractere>};

Este comando mudará uma característica específica do personagem que invoca pelo
valor especificado permanentemente. O valor pode ser negativo. Veja 'statusup'.

	// Isso diminuirá a Sta de um personagem para sempre.
	traçostatusup2 bSta,-1;

---------------------------------------

*bônus <tipo de bônus>,<val1>;
*bonus2 <tipo de bônus>,<val1>,<val2>;
*bonus3 <tipo de bônus>,<val1>,<val2>,<val3>;
*bonus4 <tipo de bônus>,<val1>,<val2>,<val3>,<val4>;
*bonus5 <tipo de bônus>,<val1>,<val2>,<val3>,<val4>,<val5>;

Esses comandos devem ser usados ​​em scripts de itens. Eles provavelmente funcionarão
scripts de itens externos, mas o bônus não persistirá por muito tempo. Eles, como
esperado, refere-se apenas a um caractere invocador.

Você pode encontrar a lista completa de bônus possíveis e qual comando usar para cada um
tipo em 'doc/item_bonus.txt'.

---------------------------------------

*autobonus <script de bônus>,<taxa>,<duração>{,<sinalizador>,{<outro script>}};
*autobonus2 <script de bônus>,<taxa>,<duração>{,<sinalizador>,{<outro script>}};
*autobonus3 <script de bônus>,<taxa>,<duração>,<id da habilidade>,{<outro script>};
*autobonus3 <script de bônus>,<taxa>,<duração>,"<nome da habilidade>",{<outro script>};

Esses comandos devem ser usados ​​somente em scripts de itens! Veja 'petautobonus' para uso de pet.

O que esses comandos fazem é 'anexar' um script ao player que obterá
executado no ataque (ou quando atacado no caso de autobonus2).

Taxa é a taxa de ativação do script (1000 = 100%).

Duração é o tempo em milissegundos que o bônus durará desde que o script foi acionado.

ID da habilidade/nome da habilidade: a habilidade que será usada como gatilho para iniciar o bônus. (autobonus3)

O argumento opcional 'flag' é usado para classificar o tipo de ataque em que o script
pode disparar (compartilha os mesmos sinalizadores do script de bônus bAutoSpell):

Critérios de alcance:
	BF_SHORT: Ativado em ataque corpo a corpo
	BF_LONG: Ativado em ataque à distância
	Padrão: BF_SHORT+BF_LONG
Critérios de tipo de ataque:
	BF_WEAPON: Ativado por habilidades de armas
	BF_MAGIC: Gatilho em habilidades mágicas
	BF_MISC: Acionador em habilidades diversas
	Padrão: BF_WEAPON
Critérios de habilidade:
	BF_NORMAL: Dispara em ataques normais
	BF_SKILL: Gatilho em habilidades
	padrão: Se o tipo de ataque for BF_WEAPON (somente), BF_NORMAL será usado,
		   caso contrário, BF_SKILL+BF_NORMAL é usado.

A diferença entre o argumento opcional 'outro script' e o 'script bônus' é que,
o primeiro dispara somente quando ataca (ou atacado) e o último é executado em
cálculo de status também, que garante, dentro da duração, o "bônus" que obtém
perdido no cálculo de status é restaurado. Então, o 'script bônus' é tecnicamente suposto aceitar
comando "bonus" somente. E normalmente usamos 'other script' para mostrar efeitos visuais.

Em todos os casos, quando o script for acionado, o jogador anexado será aquele
quem detém o bônus. Atualmente não há como saber dentro deste script
quem era o outro personagem (o atacante em autobonus2, ou o alvo em
bônus automático e bônus automático3).

//Concede 1% de chance de iniciar o estado "todas as estatísticas +10" por 10 segundos quando
//usando armas ou ataques diversos (habilidades corpo a corpo e à distância) e mostra um especial
//efeito quando o bônus está ativo.
	bônus automático "{ bônus bAllStats,10; }",10,10000,BF_WEAPON|BF_MISC,"{ efeito especial2 EF_FIRESPLASHHIT; }";

---------------------------------------

*bonus_script "<código do script>",<duração>{,<sinalizador>{,<tipo>{,<ícone_de_status>{,<id_do_caractere>}}}};

Este comando anexará um script a um player por um determinado período, em segundos.
Após esse tempo, o script irá expirar automaticamente. O mesmo bônus não pode ser
empilhado. Por padrão, este bônus será armazenado na tabela `bonus_script` quando o jogador
efetua logout.

Bandeiras (bitmask):
	1: Remova quando estiver morto.
	2: Removível por Dispell.
	4: Removível por folga.
	8: Remover quando o jogador faz logout.
	16: Removível ao Banir Buster.
	32: Removível por atualização.
	64 : Removível por Lux Anima.
	128: Remover quando Madogear estiver ativado ou desativado.
	256: Remova quando receber dano.
	512: O script é permanente e não pode ser limpo por bonus_script_clear.
	1024: Forçar a substituição do script duplicado expandindo a duração.
	2048: Forçar a adição de script duplicado. Este sinalizador não pode ser empilhado com 1024,
	      se ambos estiverem definidos, 1024 será verificado primeiro e ignorará este sinalizador.

Tipos:
	Isso será usado para decidir o buff negativo ou positivo para 'debuff_on_logout'.
	0: Ignora o tipo de buff e não será removido se o sinalizador não for &8 (padrão)
	1: Lustre
	2: Debuff

Status_icon: Veja a seção "Ícone de status" em 'src/map/script_constants.hpp'. O padrão é SI_BLANK (-1).

Exemplo:
  - Identidade: 512
    Nome Aegis: Apple
    Nome: Apple
    Tipo: Cura
    Comprar: 15
    Peso: 20
    Bandeiras:
      BuyingStore: verdadeiro
    Roteiro: |
      bonus_script "{ bônus bStr,5; }",60;

---------------------------------------

*bonus_script_clear {<sinalizador>,{<id_do_caractere>}};

Remove o bonus_script anexado do player. Se nenhum 'char_id' for fornecido, ele removerá
do invocador.

Se 'flag' for 1, significa que limpará todos os scripts, mesmo seu efeito Permanente. Por padrão,
ele apenas remove scripts não permanentes.

---------------------------------------

*plagiarizeskill <id_da_habilidade>,<nível>;

Permita que o jogador plagie habilidades específicas que podem ser copiadas.
Retorna 1 em caso de sucesso, 0 caso contrário.

Observação:
- Plágio só é capaz de copiar habilidade enquanto SC_PRESERVE não estiver ativo e habilidade for copiável por Plágio.
- O Reproduce pode copiar a habilidade se SC__REPRODUCE estiver ativo e a habilidade for copiável pelo Reproduce.

---------------------------------------

*plagiarizeskillreset <sinalizador>;

Remova uma habilidade plagiada do jogador.
Retorna 1 em caso de sucesso, 0 caso contrário.

Constantes de sinalizadores:
	1 - Use para habilidade de plágio
	2 - Use para reproduzir habilidade

---------------------------------------

*habilidade <id da habilidade>,<nível>{,<sinalizador>};
*skill "<nome da habilidade>",<nível>{,<sinalizador>};
*addtoskill <id da habilidade>,<nível>{,<sinalizador>};
*addtoskill "<nome da habilidade>",<nível>{,<sinalizador>};

Esses comandos darão ao personagem invocador uma habilidade específica. Isso também é
usado para scripts de itens.

O nível é óbvio. O ID da habilidade é o número de ID da habilidade em questão, conforme
'db/(pre-)re/skill_db.yml'. Não se sabe ao certo se isso pode ser usado para fornecer
a habilidade de um personagem, um monstro, mas você pode tentar com os números fornecidos
em 'db/(pre-)re/mob_skill_db.txt'.

A bandeira é 0 se a habilidade for dada permanentemente (será escrita com o personagem
dados) ou 1 se for temporário (será perdido eventualmente, isso é para cartão
uso de scripts de itens.). O parâmetro flag é opcional e o padrão é 1 em
'skill' e para 2 em 'addtoskill'.

O sinalizador 2 significa que o parâmetro de nível deve ser interpretado como um empilhável
bônus adicional ao nível de habilidade. Se o personagem não tivesse essa habilidade
anteriormente, agora eles estarão em 0+o nível fornecido.

O sinalizador 3 é o mesmo que o sinalizador 1, pois ele salva no banco de dados. No entanto, essas habilidades
são ignorados quando qualquer ação é tomada para ajustar a árvore de habilidades (redefinição/mudança de trabalho).

Constantes de sinalizadores:
	0 - HABILIDADE_PERM
	1 - HABILIDADE_TEMP
	2 - NÍVEL_DE_TEMPLO_DE_HABILIDADE
	3 - CONCESSÃO_DE_HABILIDADE_PERM

// Isso dará permanentemente ao personagem Stone Throw (TF_THROWSTONE,152), em
// nível 1.
    habilidade 152,1,0;

---------------------------------------

*nu {<char_id>};

Este comando desequipará qualquer coisa equipada no personagem que o invoca.

Não é necessário fazer isso ao mudar de emprego, pois 'jobchange' irá desequipar
tudo que não pode ser equipado pela nova classe de trabalho de qualquer maneira.

---------------------------------------

*sit {"<nome do personagem>"};
*stand {"<nome do personagem>"};

Esses comandos farão o personagem sentar ou ficar de pé.
Se nenhum caractere for especificado, o comando será executado para o caractere de chamada.

Além disso, a constante Sitting é verdadeira quando o personagem está sentado, falsa caso contrário.

---------------------------------------

*disfarce <ID do monstro>{,<id_do_caractere>};
*desmascarar {<char_id>};

Este comando disfarça o jogador atual com um sprite de monstro.
O disfarce dura até que "desfazer disfarce" seja emitido ou o jogador efetue logout.

Exemplo:

disguise 1002; // Disfarce o personagem como um Poring.
next;
undisguise; // Retorna ao sprite do personagem normal.

---------------------------------------

*transform <ID do monstro>,<duração>{,<tipo sc>,<val1>,<val2>,<val3>,<val4>};
*transform "<nome do monstro>",<duração>{,<tipo sc>,<val1>,<val2>,<val3>,<val4>};
*active_transform <ID do monstro>,<duração>{,<tipo sc>,<val1>,<val2>,<val3>,<val4>};
*active_transform "<nome do monstro>",<duração>{,<tipo sc>,<val1>,<val2>,<val3>,<val4>};

Este comando transformará um jogador em um monstro por um determinado período e pode conceder
um efeito de atributo SC enquanto transformado. Note que os jogadores não podem ser transformados
durante a Guerra do Emperium ou se já estiver disfarçado.
Só pode ser removido quando você morrer ou a duração terminar.

'transform' e 'active_transform' podem ser empilhados um sobre o outro, mas usar 'transform' ou
'active_transform' duas vezes não acumulará (cancelará o bônus anterior para o novo).
'active_transform' terá prioridade sobre transform durante sua duração.

---------------------------------------
\\
4.3 Comandos relacionados ao casamento
\\
---------------------------------------

*casamento("<nome do cônjuge>");

Esta função irá casar dois caracteres, o caractere invocador e o outro
referidos pelo nome dado, juntos, configurando-os como o casamento um do outro
parceiro. Nenhuma segunda chamada de função precisa ser emitida (pelo menos no SVN atual) para
certifique-se de que o casamento funcione nos dois sentidos. A função retorna 1 em caso de sucesso, ou
0 se o casamento não pôde ser concluído, seja porque o outro personagem
não foi encontrado ou porque um dos dois personagens já é casado.

Isso não fará nada mais pelo casamento, exceto configurar a identificação do cônjuge para
ambos os personagens. Nenhum anel será dado e nenhum efeito será mostrado.

---------------------------------------

*casamento;

Este comando irá chamar os efeitos do casamento - a música e o confete - centralizados em
o personagem invocador. Um exemplo pode ser encontrado no script do casamento.

---------------------------------------

*divórcio({<char_id>})

Esta função irá "descasar" o personagem invocador de quem quer que ele seja
casado com. Ambos não serão mais parceiros conjugais um do outro (pelo menos em
SVN atual, que previne os casos de problemas de múltiplos cônjuges). Ele retornará
1 em caso de sucesso ou 0 se o personagem não for casado.

Esta função também destruirá ambas as alianças e enviará uma mensagem para ambas
jogadores, dizendo-lhes que agora estão divorciados.

---------------------------------------

*adopt("<nome_dos_pais>","<nome_do_bebê>");
*adotar(<id_pai>,<id_bebê>);

Esta função enviará a solicitação de adoção do cliente para o bebê especificado
personagem. O valor pai pode ser qualquer um dos pais. Ambos os pais e o bebê
precisa estar online para que a adoção funcione.

Valores de retorno:
ADOPT_ALLOWED - Envia mensagem ao Baby para aceitar ou negar.
ADOPT_ALREADY_ADOPTED - O personagem já foi adotado.
ADOPT_MARRIED_AND_PARTY - Os pais precisam ser casados ​​e estar em uma festa com o bebê.
ADOTE_EQUIPE_ANÉIS - Os pais precisam equipar as alianças.
ADOPT_NOT_NOVICE - O bebê não é um novato.
ADOPT_CHARACTER_NOT_FOUND - Um pai ou bebê não foi encontrado.
ADOTE_MAIS_CRIANÇAS - Você não pode adotar mais de 1 criança. (mensagem do cliente)
ADOPT_LEVEL_70 - Os pais precisam ter pelo menos nível 70 para adotar alguém. (mensagem do cliente)
ADOPT_MARRIED - Você não pode adotar uma pessoa casada. (mensagem do cliente)

---------------------------------------
//
4.3.- Fim dos mandamentos relacionados ao casamento
//
---------------------------------------

*pcfollow <id>,<id de destino>;
*pcstopfollow <id>;

Faz um personagem seguir ou parar de seguir alguém. Este comando faz o mesmo
como o comando @follow. A principal diferença é que @follow pode usar caracteres
nomes, e este comando precisa do ID da conta do alvo.

Exemplos:
	// Isso fará com que Aaron siga Bullah, quando ambos os personagens estiverem online.
	pcfollow getCharID(3,"Aaron"),getCharID(3,"Bullah");

	// Faz Aaron parar de seguir quem ele está seguindo.
	pcstopfollow getCharID(3,"Aaron");

---------------------------------------

*pcblockmove <id>,<opção>;
*unitblockmove <id>,<opção>;

Impede que o GID fornecido se mova quando a opção é 1 e permite que o ID
mova novamente quando a opção for 0. Este comando será executado para a unidade anexada
se o GID fornecido for zero.

Exemplos:
	// Evita que o caractere atual se afaste.
	pcblockmove getcharid(3),1;

	// Habilita o caractere atual a se mover novamente.
	pcblockmove getcharid(3),0;

---------------------------------------

*pcblockskill <id>,<opção>;
*unitblockskill <id>,<opção>;

Impede que o GID fornecido lance habilidades quando a opção é 1 e habilita
o ID para lançar habilidades novamente quando a opção for 0. Este comando será executado por
a unidade anexada se o GID fornecido for zero.

Exemplos:
	// Impede que o personagem atual conjure habilidades.
	pcblockskill obtercharid(3),1;

	// Habilita o personagem atual a lançar habilidades novamente.
	pcblockskill obtercharid(3),0;

---------------------------------------

*setpcblock <tipo>,<estado>{,<ID da conta>};
*getpcblock {<ID da conta>};

O comando 'setpcblock' impede/permite que o jogador execute o <tipo> de ação fornecido de acordo
para o <estado> durante a sessão do player (nota: @reloadscript remove todos os <tipo>, exceto PCBLOCK_IMMUNE).
Os valores <type> são máscaras de bits, múltiplos de <type> podem ser adicionados para alterar a ação do jogador.

A ação é bloqueada quando <estado> é verdadeiro, enquanto falso permite a ação novamente.

O comando 'getpcblock' retorna o valor da máscara de bits do bloco atual
sinalizadores de bloco habilitados.

Disponível <tipo>:
	PCBLOCK_MOVE Impede que o jogador se mova.
	PCBLOCK_ATTACK Impede que o jogador ataque.
	PCBLOCK_SKILL Impede que o jogador use habilidades/itens.
	PCBLOCK_USEITEM Impede que o jogador utilize itens utilizáveis.
	PCBLOCK_CHAT Impede que o jogador envie mensagens globais/de guilda/de grupo/sussurros.
	PCBLOCK_IMMUNE Evita que o jogador seja atingido por monstros.
	PCBLOCK_SITSTAND Impede que o jogador fique sentado/de pé.
	PCBLOCK_COMMANDS Impede que o jogador use atcommands/charcommands.
	PCBLOCK_NPCCLICK Impede que o jogador clique/toque em qualquer NPC/loja/televisão.
	PCBLOCK_EMOTION Impede que o jogador use emoções.
	PCBLOCK_EQUIP Impede que o jogador substitua o equipamento.
	PCBLOCK_NPC Simula interação com NPC. Útil para NPC sem janela de mensagens. Soma de PCBLOCK_MOVE|PCBLOCK_SKILL|PCBLOCK_USEITEM|PCBLOCK_COMMANDS|PCBLOCK_NPCCLICK|PCBLOCK_EQUIP.
	PCBLOCK_ALL Soma de todos os sinalizadores.

Exemplos:

// Torna o jogador anexado invulnerável a monstros (o mesmo que @monsterignore)
	setpcblock PCBLOCK_IMMUNE, verdadeiro;

// Impede que o jogador anexado ataque e use habilidades
	setpcblock PCBLOCK_ATTACK|PCBLOCK_SKILL, verdadeiro;

// Reativa o ataque, as habilidades e o uso de itens
	setpcblock PCBLOCK_ATTACK|PCBLOCK_SKILL|PCBLOCK_USEITEM, falso;

// verificações relacionadas ao getpcblock
	if (getpcblock() e PCBLOCK_IMMUNE)
		mes "Você é invulnerável!";

	if (getpcblock() & (PCBLOCK_MOVE|PCBLOCK_SITSTAND))
		mes "Você não pode andar ou sentar.";

	if ((getpcblock() & (PCBLOCK_ATTACK|PCBLOCK_SKILL)) == 0)
		mes "Você pode atacar e usar habilidades.";

	if (getpcblock() & PCBLOCK_CHAT)
		mes "Você não pode conversar.";

---------------------------------------

*macro_detector({<ID da conta>});
*macro_detector({"<nome do personagem>"});

Este comando exibirá o desafio da interface do captcha no personagem que o invoca ou no <ID da conta>/<nome do personagem> fornecido.

Exemplo:
	// Use 'getareaunits' para reunir uma área de jogadores para testar.
	// Cria um array int dos IDs das contas.
	.@num = getareaunits(BL_PC, "prontera", 150, 150, 160, 160, .@array[0]);

	mes "O número de jogadores em Prontera entre 150x150 e 160x160 é " + .@num + " .";
	mes "Jogadores para desafiar:";
	freeloop(1); // Se a lista for muito grande
	for(.@i = 0; .@i < getarraysize(.@array); .@i++) {
		mes (.@i + 1) + " " + convertpcinfo(.@array[.@i], CPC_NAME);
		detector_de_macro .@array[.@i];
	}
	loop livre(0);
	end;

---------------------------------------

*permission_check(<permissão>{,<char_id>});

Este comando retornará verdadeiro se o caractere anexado tiver a permissão especificada, falso caso contrário.
Se <char_id> for fornecido, ele verificará a permissão para esse caractere.

Uma lista completa das constantes de permissão do jogador (com o prefixo 'PC_PERM') junto com o
a documentação completa sobre permissões pode ser encontrada em 'doc/permissions.txt'.


Exemplo:
	if (permissão_verificação(PC_PERM_TRADE)) {
		mes "Você tem permissão para negociar!";
	}
	outro {
		mes "Você não tem permissão para negociar!";
	}
	end;

---------------------------------------

*permission_add(<permissão>{,<char_id>});
*permission_remove(<permissão>{,<char_id>});

Esses comandos adicionarão ou removerão temporariamente a permissão especificada para o personagem anexado,
ou o <char_id> fornecido até que o jogador efetue logout.

Uma lista completa das constantes de permissão do jogador (com o prefixo 'PC_PERM') junto com o
a documentação completa sobre permissões pode ser encontrada em 'doc/permissions.txt'.

Exemplos:
	// Adiciona a permissão 'can_trade' ao personagem anexado,
	// permitindo que eles negociem, deixem cair, vendam, armazenem e enviem itens.
	permissão_add(PC_PERM_TRADE);

	// Remove a permissão 'can_party' do personagem anexado,
	// impedindo-os de se juntar ou criar partidos.
	permissão_remove(PC_PERM_PARTY);

---------------------------------------

=================================
|5.- Comandos relacionados a Mob/NPC.|
=================================
---------------------------------------

*monster "<nome do mapa>",<x>,<y>,"<nome a ser exibido>",<id do mob>,<quantidade>{,"<rótulo do evento>",<tamanho>,<ai>};
*monster "<nome do mapa>",<x>,<y>,"<nome a ser exibido>","<nome do mob>",<quantidade>{,"<rótulo do evento>",<tamanho>,<ai>};
*areamonster "<nome do mapa>",<x1>,<y1>,<x2>,<y2>,"<nome a ser exibido>",<id do mob>,<quantidade>{,"<rótulo do evento>",<tamanho>,<ai>};
*areamonster "<nome do mapa>",<x1>,<y1>,<x2>,<y2>,"<nome a ser exibido>","<nome do mob>",<quantidade>{,"<rótulo do evento>",<tamanho>,<ai>};

Este comando irá gerar <quantidade> monstros com <id do mob> ou <nome do mob> no local especificado
coordenadas no mapa especificado. Se o script for invocado por um personagem, um especial
<nome do mapa>, "this", será reconhecido como o nome do mapa do caractere invocador
está localizado em. Este comando funciona bem em scripts de itens.

Os mesmos argumentos de comando significam as mesmas coisas descritas acima no
início deste documento ao falar sobre spawns permanentes de monstros. Monstros
gerados dessa maneira não reaparecerão ao serem mortos.

Ao contrário dos spawns permanentes de monstros, se o ID do mob for -1, um monstro aleatório irá
ser escolhido de todo o banco de dados de acordo com as regras configuradas no
servidor para ramos mortos. Isso funcionará para todos os outros tipos de ramos não permanentes
monstros aparecem.

A única coisa muito especial sobre este comando é um rótulo de evento, que é um
parâmetro opcional. Este rótulo é escrito como '<nome do objeto NPC>::<nome do rótulo>'
e quando o monstro for morto, ele executará o script dentro do
objeto NPC especificado a partir do rótulo fornecido. O RID do jogador
anexado a esta execução estará o RID do personagem assassino.
A variável 'killedrid' é definida como a Clasif (ID do mob) do monstro morto.
A variável 'killedgid' é definida como o ID (ID exclusivo do jogo do mob) do monstro morto.

<tamanho> pode ser:
	Tamanho_Pequeno (0) (padrão)
	Tamanho_Médio (1)
	Tamanho_Grande (2)

<ai> pode ser:
	AI_NONE (0) (padrão)
	AI_ATTACK (1) (ataque/amigável)
	AI_SPHERE (2) (habilidade de alquimista)
	AI_FLORA (3) (habilidade de alquimista)
	AI_ZANZOU (4) (habilidade Kagerou/Oboro)
	AI_LEGION (5) (habilidade Sera)
	AI_FAW (6) (Habilidade mecânica)
	AI_WAVEMODE (7) Monstros normais ignorarão ataques de monstros AI_WAVEMODE

    monster "lugar",60,100,"Poring",1002,1,"NPCNAME::OnLabel";

As coordenadas 0,0 farão o monstro aparecer em um lugar aleatório no mapa.

O comando 'areamonster' funciona de forma muito semelhante ao comando 'monster' e não é
significativamente diferente, mas gera os monstros dentro de um quadrado definido por
x1/y1-x2/y2.

O valor retornado é uma matriz com o ID do jogo do(s) monstro(s) gerado(s), dependendo
na quantidade gerada. O array é armazenado em $@mobid[].

Roteiro simples para matar monstros:

		<Definição normal de objeto NPC. Vamos supor que você o chamou de NPCNAME.>
		mes "[Invocar Homem]";
		mes "Quer começar a caça ao Poring?";
		next;
		if (select("Sim.:Não.") == 2) {
			mes "[Invocar Homem]";
			mes "Volte mais tarde.";
			close;
		}

		// Invoca 10 Porings.
		// Usar as coordenadas 0,0 os gerará em um local aleatório.
		monster "prontera",0,0,"Quest Poring",1002,10,"NPCNAME::OnPoringKilled";

		mes "[Invocar Homem]";
		mes "Agora vá e mate todos os Porings que eu invoquei.";
		close;

	OnPoringMorto:
		$PoringMorto++;
		if ($PoringKilled >= 10) {
			announce "Invocar o Homem: Muito bem. Todos os Porings estão mortos!",3;
			$PoringKilled = 0;
		}
		end;

Para mais bons exemplos, veja qualquer script oficial de missão de trabalho 2-1 ou 2-2.

---------------------------------------

*areamobuseskill "<nome do mapa>",<x>,<y>,<alcance>,<id do mob>,<id da habilidade>,<nível da habilidade>,<tempo de conjuração>,<cancelável>,<emoção>,<tipo de alvo>;
*areamobuseskill "<nome do mapa>",<x>,<y>,<alcance>,<id do mob>,"<nome da habilidade>",<nível da habilidade>,<tempo de conjuração>,<cancelável>,<emoção>,<tipo de alvo>;
*areamobuseskill "<nome do mapa>",<x>,<y>,<intervalo>,"<nome do mob>",<id da habilidade>,<nível da habilidade>,<tempo de conjuração>,<cancelável>,<emoção>,<tipo de alvo>;
*areamobuseskill "<nome do mapa>",<x>,<y>,<alcance>,"<nome do mob>","<nome da habilidade>",<nível da habilidade>,<tempo de conjuração>,<cancelável>,<emoção>,<tipo de alvo>;

Este comando fará com que todos os monstros do <mob id> ou <mob name> especificado no
área usa a habilidade especificada. <nome do mapa>, <x> e <y> definem o centro da área,
que estende células <intervalo> em cada direção (ex: um intervalo de 3 criaria
um quadrado 7x7). A habilidade pode ser especificada por <id da habilidade> ou <nome da habilidade>. <tempo de conjuração> está em
milissegundos (1000 = 1 segundo), e o restante deve ser autoexplicativo.

<tipo de destino> pode ser:
	0 = eu
	1 = alvo atual da multidão
	2 = o mestre da máfia
	3 = alvo aleatório

Exemplo:

	// gera 1 Planta Brilhante na área 5x5 centralizada em (155.188)
	areamonster "prontera",153.186.157.190,"Planta Brilhante",1083,1;
	// faça a planta lançar um Raio Frio nível 10 em um alvo aleatório
	areamobuseskill "prontera",155,188,2,1083,"MG_COLDBOLT",10,3000,1,ET_KEK,3;

---------------------------------------

*killmonster "<nome do mapa>","<rótulo do evento>"{,<tipo>};

Este comando matará todos os monstros que foram gerados com 'monstro' ou
'addmonster' e tem um rótulo de evento especificado anexado a eles. Normalmente usado para
livre-se dos monstros restantes da missão quando ela estiver completa.

Se o rótulo for dado como "Todos", todos os monstros que têm seus tempos de respawn definidos
para -1 (como todos os monstros invocados com o script 'monstro' ou 'areamonster'
comando, e todos os monstros invocados com comandos do GM, mas nenhum outro - que
ou seja, todos os monstros não permanentes) no mapa especificado serão mortos independentemente
do valor do rótulo do evento.

A partir de r12876, killmonster agora suporta um tipo de argumento opcional. Usando 1 para o tipo
fará com que o comando dispare eventos "OnMyMobDead" de qualquer monstro que morra
como resultado deste comando.

---------------------------------------

*killmonsterall "<nome do mapa>"{,<tipo>};

Este comando matará todos os monstros em um nome de mapa especificado, independentemente de como
eles foram gerados ou o que são. A partir de r12873, o comportamento mudou um pouco.
À luz de uma correção de comportamento de rótulo para comandos de geração de mobs que agora permitirão que o rótulo
acionado quando não há jogador, killmonsterall também foi modificado para suportar isso.

Usar isso da maneira normal/antiga significa que os rótulos não são acionados quando um jogador não o faz.
atacar/matar um monstro. Isso ocorre porque ele quebra a compatibilidade com scripts mais antigos se
forçado a usar o novo método. No entanto, se você deseja usar o novo tipo de rótulo com este
comando, simplesmente use 1 para tipo. Qualquer outro número não será reconhecido.

---------------------------------------

*strmobinfo(<tipo>,<id do monstro>);

Esta função retornará informações sobre um registro de monstro no banco de dados, como
por 'db/(pre-)re/mob_db.yml'. Tipo é o tipo de informação retornada. Tipos válidos são:
Ele retornará 0 se não houver tal monstro (ou o valor do tipo for inválido),
ou uma string vazia se você solicitou o nome do monstro.

1 - campo 'nome em inglês' no banco de dados, uma string.
2 - campo 'nome japonês' no banco de dados, uma string.
     Todos os outros valores retornados são números:
3 - Nível.
4 - HP máximo.
5 - SP máximo.
6 - Recompensa de experiência.
7 - Recompensa por experiência profissional.

---------------------------------------

*mobcount("<nome do mapa>","<rótulo do evento>")

Esta função contará todos os monstros no mapa especificado que tenham um determinado
rótulo do evento e retornar o número ou 0 se não encontrar nenhum. Naturalmente, apenas
monstros gerados com os comandos de script 'monster' e 'areamonster' podem ter campos não vazios
rótulo do evento.
Se você passar para esta função uma string vazia para o rótulo do evento, ela retornará
a contagem total de monstros sem rótulo de evento, incluindo monstros que aparecem permanentemente.
Com o sistema de mobs dinâmicos habilitado, onde os mobs não são mantidos
na memória para mapas sem pessoas reais jogando neles, isso retornará 0
para qualquer mapa desse tipo.
Se o rótulo do evento for dado como "todos", todos os monstros serão contados, independentemente de
tendo qualquer etiqueta de evento anexada.

Se o nome do mapa for dado como "este", o mapa em que o personagem invocador está será
ser usado. Se o mapa não for encontrado, ou o invocador não for um personagem enquanto o mapa
é "this", retornará -1.

---------------------------------------

*clone "<nome do mapa>",<x>,<y>,"<evento>",<id do caractere>{,<id_mestre>{,<modo>{,<sinalizador>,<duração>}}}

Este comando cria um monstro que é uma cópia de outro jogador. O primeiro
quatro argumentos servem ao mesmo propósito que no comando de script monster, O
<char id> é o id do personagem do jogador a ser clonado (o jogador deve estar online).
Se <master id> for fornecido, o clone será um 'escravo/minion' dele. Master_id
deve ser um ID de personagem de outro jogador online.

O modo pode ser especificado para determinar o comportamento do clone. Seu
os valores são os mesmos que os usados ​​para o campo mode no mob_db. O
o modo padrão é agressivo, auxilia, pode se mover, pode atacar.

A bandeira pode ser zero ou um atualmente. Se zero, o clone é um normal
monstro que terá como alvo os jogadores, se houver, é considerado um monstro invocado,
e como tal, ele mirará em outros monstros. O padrão é zero.

A duração especifica quanto tempo o clone viverá antes de ser removido automaticamente.
Especificado em segundos, o padrão é sem limite (zero).

O valor retornado é o ID do monstro do clone gerado. Se o comando falhar,
o valor retornado é zero.

---------------------------------------

*invocar "nome do monstro",<id do monstro>{,<Tempo limite>{,"rótulo do evento"}};

Este comando invocará um monstro. (veja também 'monstro') Ao contrário dos monstros gerados
com outros comandos, este irá preparar o monstro para lutar para proteger o
invocando personagem. O nome do monstro e o id do mob obedecem às mesmas regras que o dado
no início deste documento para spawns permanentes de monstros com o
exceções mencionadas ao descrever o comando 'monstro'.

O efeito da habilidade 'Chamar Homúnculo' será exibido centralizado no
invocando personagem.

O tempo limite é o tempo em milissegundos que a invocação dura e é definido como padrão
para 60000 (1 minuto). Observe que também o valor 0 setá o temporizador para o padrão,
e não é possível criar uma semente que dure para sempre.
Se um rótulo de evento for fornecido, após o monstro ser morto, o rótulo do evento será
executado como se fosse por 'donpcevent'.

O valor retornado é o ID do jogo do monstro gerado.

// Invocará um monstro do tipo galho morto para lutar pelo personagem.
invocar "--ja--",-1;

---------------------------------------

*addmonsterdrop <id do monstro>,<id do item>,<taxa>,{<roubo protegido>,{<id do grupo de opções aleatórias>}};
*addmonsterdrop "<nome do monstro>",<id do item>,<taxa>,{<roubo protegido>,{<id do grupo de opções aleatórias>}};
*delmonsterdrop <id do monstro>,<id do item>;
*delmonsterdrop "<nome do monstro>",<id do item>;

Esses comandos adicionarão ou excluirão temporariamente um drop de monstro, que será redefinido
quando o banco de dados mob recarrega ou o servidor desliga. Eles retornam true em caso de sucesso, false caso contrário.

Se o monstro já dropar o item especificado, sua taxa de drop será atualizada com
a taxa dada (100 = 1%).

Se <steal protected> for verdadeiro, o item será protegido contra TF_STEAL (padrão falso).
<random option group id> vincula o item ao ID do grupo de opções aleatório fornecido (padrão 0).
O Id deve ser válido, como definido em db/[pre-]re/item_randomopt_group.yml

Exemplos:
	// Faz com que o Barão Coruja drope mel a uma taxa de 80%.
	adicionarmonsterdrop 1295.518.8000;

	// Faz com que o Owl Baron largue Knife_ a uma taxa de 80%, protegido de TF_STEAL e com ID de grupo de opção aleatório 5.
	addmonsterdrop 1295,1202,8000,verdadeiro,5;

	// Exclui Luva do Carrasco de Rybio.
	delmonsterdrop 1201,7017;

---------------------------------------

*mob_setidleevent <GID>,<evento>;

Este comando anexará um rótulo de evento ao monstro com o <GID> fornecido que executará
quando o <GID> estiver ocioso.

Exemplo:
	monster "prontera",0,0,"Quest Poring",1002,1;
	mob_setidleevent $@mobid[0], "NOME DO NPC::OnIdle";
	end;

Em inatividade:
	mobchat getattachedrid(),0,0x00FF00,"Estou OCIOSO!";
	end;

---------------------------------------

*disablenpc {"<nome do objeto NPC>"};
*enablenpc {"<nome do objeto NPC>"};

Esses dois comandos desabilitarão e habilitarão, respectivamente, um objeto NPC
especificado pelo nome. O NPC desabilitado desaparecerá de vista e não mais
ser acionável da maneira normal. Não está claro se ainda será
acessível através de 'donpcevent' e outros comandos de disparo, mas provavelmente
será. Você pode desabilitar até mesmo NPCs de dobra se souber os nomes dos objetos, o que é
uma maneira fácil de fazer um mapa acessível somente caminhando metade do tempo. Então
você os 'enablenpc' de volta.

Você também pode usar esses comandos para criar a ilusão de um NPC trocando
entre vários locais, o que geralmente é melhor do que realmente mover o NPC -
crie um objeto NPC com uma parte visível e uma parte oculta em seu nome, faça alguns
cópias e, em seguida, desabilite todas, exceto uma.

---------------------------------------

*hideonnpc {"<nome do objeto NPC>"};
*hideoffnpc {"<nome do objeto NPC>"};

Esses comandos farão com que o objeto NPC especificado seja exibido como oculto/visível,
mesmo que não esteja realmente desabilitado por si só. Oculto como na habilidade de ladrão Hide, mas
infelizmente, não detectável por Ruwach ou Visão.

Do jeito que estão agora, esses comandos são inúteis, é sugerido usar
'disablenpc'/'enablenpc', porque esses dois comandos realmente descarregam o NPC
localização do sprite e outros dados que o acompanham da memória quando não são usados.
No entanto, você pode usá-los para algumas ideias de missões (como camuflar NPCs falando
enquanto escondido e depois revelado... você pode passear =P

---------------------------------------

*unloadnpc "<nome do objeto NPC>";

Este comando descarregará completamente um objeto NPC e todas as suas duplicatas.

---------------------------------------
 
*duplicado "<nome do NPC>","<mapa>",<x>,<y>{,"<nome do NPC duplicado>"{,<sprite>{,<dir>{,<xs>{,<xy>}}}}};

Este comando duplicará o NPC com o <nome do NPC> fornecido no <mapa> em <x>/<y>.
Se <Nome do NPC duplicado>, <sprite>, <dir>, <xs> ou <ys> não for fornecido, o valor do NPC original será usado.
O nome Unique do novo NPC duplicado é retornado em caso de sucesso. Uma string vazia é retornada em caso de falha.

OBSERVAÇÃO:
	Duplicatas sempre terão as mesmas variáveis ​​de NPC que o NPC original.
	Editar uma variável de NPC em uma duplicata ou no NPC original irá alterá-la para os outros.

---------------------------------------
 
*duplicate_dynamic("<nome do NPC>"{,<ID do personagem>});

Este comando duplicará o NPC com o <nome do NPC> fornecido próximo ao jogador anexado ou o jogador com o <ID do personagem> fornecido.
O nome Unique do novo NPC duplicado é retornado em caso de sucesso. Uma string vazia é retornada em caso de falha.

OBSERVAÇÃO:
	Duplicatas sempre terão as mesmas variáveis ​​de NPC que o NPC original.
	Editar uma variável de NPC em uma duplicata ou no NPC original irá alterá-la para os outros.

---------------------------------------

*cloakonnpc {"<nome do objeto NPC>"{,<ID do personagem>}};
*cloakoffnpc {"<nome do objeto NPC>"{,<ID do personagem>}};

Esses comandos farão com que o objeto NPC especificado seja exibido como camuflado/desmascarado,
mesmo que não esteja realmente desabilitado.
O jogador pode interagir com um NPC camuflado (por meio de clique no NPC, evento de monstro...)
mas a área de ativação do NPC está desabilitada.

Se <ID do personagem> for fornecido, o NPC será exibido apenas para o especificado
jogador até que ele/ela saia do mapa, faça logout ou a opção npc seja alterada.
Se nenhum <ID do personagem> for especificado, ele será exibido na área.

---------------------------------------

*cloakonnpcself {"<nome do objeto NPC>"};
*cloakoffnpcself {"<nome do objeto NPC>"};

Mesmo comando acima, mas um jogador anexado é necessário. O NPC só será exibido para o jogador anexado.

---------------------------------------

*isnpccloaked {"<nome do objeto NPC>"{,<ID do personagem>}};

Retorna verdadeiro se o NPC foi camuflado para o jogador anexado ou fornecido
<ID do personagem>, caso contrário, false. Isso funciona em associação com cloakonnpc
quando tem como alvo um personagem específico.

---------------------------------------

*doevent "<nome do objeto NPC>::<rótulo do evento>";

Este comando iniciará um novo thread de execução em um objeto NPC especificado no
rótulo especificado. A execução do script que executa este comando não será interrompida,
e o evento chamado pelo comando 'doevent' não será executado até que o invocador
script foi encerrado. Nenhum parâmetro pode ser passado com uma chamada doevent.

O script do objeto NPC invocado dessa maneira será executado como se tivesse sido
invocado pelo RID que estava ativo no script que emitiu um 'doevent'. Como
portanto, o comando não funcionará se um RID não estiver anexado.

	lugar,100,100,1%TAB%script%TAB%NPC%TAB%53,{
		mes "Isso é o que você verá quando clicar em mim";
		close;
	No rótulo:
		mes "Isto é o que você verá se o doevent for ativado";
		close;
	}

	....

	doevent "NPC::OnLabel";

---------------------------------------

*donpcevent "<nome do objeto NPC>::<rótulo do evento>";

Este comando invoca o código do rótulo do evento dentro de outro NPC ou NPCs. Ele
inicia uma instância separada de execução, e o NPC invocador irá retomar
execução imediata.

Se o rótulo do evento fornecido tiver o formato "NpcName::OnLabel", então somente
O rótulo do evento do NPC será invocado (muito parecido com 'goto' em outro NPC). Se o
o formulário é "::OnLabel" (nome do NPC omitido), o código do evento de todos os NPCs com determinado
rótulo será invocado, um após o outro. Em ambos os casos, o script invocado
será executado sem um RID anexado, independentemente de o script de invocação ter sido ou não
anexado a um player. O nome do rótulo do evento precisa começar com "On".

Este comando pode ser usado para fazer outros NPCs agirem como se estivessem respondendo a
as ações do NPC invocador, como usar uma emoção ou falar.

	lugar,100,100,1%TAB%script%TAB%NPC1%TAB%53,{
		mes "NPC2 copia minhas ações!";
		close2;
		donpcevent "NPC2::OnEmote";
		end;
	Em Emote:
		emoção rand(1,30);
		end;
	}

	lugar,102,100,1%TAB%script%TAB%NPC2%TAB%53,{
		mes "NPC1 copia minhas ações!";
		close2;
		donpcevent "NPC1::OnEmote";
		end;
	Em Emote:
		emoção rand(1,30);
		end;
	}

Qualquer um dos dois NPCs com quem se fala, ambos mostrarão uma emoção aleatória no momento
ao mesmo tempo.

A partir da versão r16564, o comando agora retorna 1 ou 0 em caso de sucesso ou falha.
Uma mensagem de depuração também é exibida no console quando nenhum evento é acionado.

---------------------------------------

*cmdothernpc "<nome do npc>","<comando>";

Isto é simplesmente "donpcevent <nome do npc>::OnCommand<comando>".
É uma aproximação do 'cmdothernpc' da linguagem de script oficial do servidor.

Retorna verdadeiro se o comando foi executado no outro NPC com sucesso, falso caso contrário.

---------------------------------------

*npctalk "<mensagem>"{,"<nome do NPC>",<bandeira>{,<cor>}};

Este comando exibirá uma mensagem como se o objeto NPC que o executa fosse um jogador
falando - isto é, acima da cabeça deles e na janela de bate-papo.
O nome de exibição do NPC não será acrescentado na frente da mensagem.
Se a opção <nome do NPC> for fornecida e não estiver vazia, então o NPC exibirá a mensagem,
caso contrário, o NPC anexado exibirá a mensagem,
o formato da cor é RGB (0xRRGGBB). A cor é Branco por padrão.

Alvo para <flag>:
- bc_all: A mensagem de transmissão é enviada para todo o servidor (somente na janela de bate-papo).
- bc_map: A mensagem é enviada para todos no mesmo mapa que a origem do npc.
- bc_area: A mensagem é enviada aos jogadores nas proximidades da fonte (valor padrão).
- bc_self: A mensagem é enviada apenas para o jogador anexado.

	// Isso fará com que todos na área vejam o NPC cumprimentando o personagem
	// que acabou de invocá-lo.
	npctalk "Olá " + strcharinfo(0) + ", como vai você?";

---------------------------------------

*chatmes "<mensagem>"{,"<nome do NPC>"};

Este comando exibirá uma mensagem na sala de espera (chat) do NPC.
Se a opção <nome do NPC> for fornecida, então esse NPC exibirá a mensagem, caso contrário
o NPC anexado exibirá a mensagem.
Se o NPC não estiver em uma sala de espera, nada acontece.

	// Todos na sala de espera verão esta mensagem:
	chatmes "Esperando 5 minutos até a próxima partida começar";

---------------------------------------

*setnpcdisplay("<nome do npc>", "<nome de exibição>", <id da classe>, <tamanho>)
*setnpcdisplay("<nome do npc>", "<nome de exibição>", <id da classe>)
*setnpcdisplay("<nome do npc>", "<nome de exibição>")
*setnpcdisplay("<nome do npc>", <id da classe>)

Altera o nome de exibição e/ou a classe de exibição do NPC alvo.
Retorna 0 se for bem-sucedido, 1 se o NPC não existir.
O tamanho é 0 = normal, 1 = pequeno e 2 = grande.

---------------------------------------
\\
5,1.- Comandos relacionados ao tempo
\\
---------------------------------------

*addtimer <tiques>,"NPC::OnLabel";
*deltimer "NPC::OnLabel";
*addtimercount <tiques>,"NPC::OnLabel";

Esses comandos criarão, destruirão e atrasarão um cronômetro de contagem regressiva - 'addtimer' para
criar, 'deltimer' para destruir e 'addtimercount' para atrasá-lo pelo tempo especificado
número de ticks. Para todos os três casos, o rótulo do evento fornecido é o identificador de
esse timer. O timer roda no objeto de personagem que está anexado ao script,
e pode ter várias instâncias. Quando o rótulo é executado, ele é executado como se o player que
o cronômetro corre em clicou no NPC.

Quando esse cronômetro acabar, um novo thread de execução será iniciado no NPC especificado
objeto no rótulo especificado.

Os tiques são dados em 1/1000 de segundo.

Mais uma coisa. Esses temporizadores são armazenados como parte dos dados do jogador. Se o jogador
sai, todos eles são imediatamente excluídos, sem executar o script.
Se esse comportamento for indesejável, use algum outro mecanismo de temporizador (como 'sleep').

Exemplo:
<Cabeçalho NPC> {
	dispbottom "Iniciando um cronômetro de 5 segundos...";
	adicionartimer 5000, strnpcinfo(3) + "::On5secs";
	end;
Em 5 segundos:
	dispbottom "5 segundos se passaram!";
	end;
}

---------------------------------------

*initnpctimer{ "<nome do NPC>" {, <Anexar sinalizador>} } |
             { "<Nome do NPC>" | <Anexar sinalizador> };
*stopnpctimer{ "<nome do NPC>" {, <Desanexar sinalizador>} } |
             { "<Nome do NPC>" | <Desanexar sinalizador> };
*startnpctimer{ "<nome do NPC>" {, <Anexar sinalizador>} } |
              { "<Nome do NPC>" | <Anexar sinalizador> };
*setnpctimer <tick>{,"<nome do NPC>"};
*getnpctimer(<tipo de informação>{,"<nome do NPC>"})
*attachnpctimer {"<nome do personagem>"};
*detachnpctimer {"<nome do NPC>"};

Este conjunto de comandos e funções criará e gerenciará um cronômetro baseado em NPC.
O nome do NPC pode ser omitido, caso em que o NPC que fez a chamada é usado como alvo.

Ao contrário dos comandos addtimer/deltimer que permitem que você tenha muitos temporizadores diferentes
referenciando diferentes rótulos no mesmo NPC, cada um com sua própria contagem regressiva,
'initnpctimer' pode ter apenas um por objeto NPC. Mas pode disparar muitos rótulos
e informá-lo sobre quantos já foram acionados e quantos ainda permanecem.

Este cronômetro está contando a partir de 0 em tiques de 1/1000 de segundo cada. Após
criando este temporizador, a execução não irá parar, mas continuará alegremente
em diante. O temporizador então invocará novos threads de execução em rótulos
"OnTimer<tempo>:" no objeto NPC ao qual está anexado.

Para criar o timer, use o 'initnpctimer', que o iniciará.
'stopnpctimer' pausará o cronômetro, sem limpar o tique atual, enquanto
'startnpctimer' permitirá que o timer pausado continue.

Por padrão, os temporizadores não têm um RID anexado, o que permite que eles continuem mesmo
se o jogador que os iniciou fizer logoff. Para anexar um RID a um cronômetro, você pode
use o "flag" opcional "attach" ao usar 'initnpctimer/startnpctimer',
ou faça isso manualmente usando 'attachnpctimer'. Da mesma forma, o sinalizador opcional de
stopnpctimer permite que você desconecte qualquer RID após parar o cronômetro e usando
'detachnpctimer' você pode desanexar um RID a qualquer momento.

Normalmente, há apenas um único cronômetro por NPC, mas como exceção, desde que
você anexa um player ao timer, você pode ter vários timers rodando ao mesmo tempo,
porque elas serão armazenadas nos jogadores em vez do NPC.
NOTA: Você precisa anexar o RID antes do cronômetro _antes_ de iniciá-lo
obtenha um timer anexado ao jogador. Caso contrário, ele permanecerá como um timer NPC (sem efeito).

Se o player conectado ao npctimer fizer logout, o "OnTimerQuit:"
o rótulo do evento desse NPC será acionado, para que você possa fazer o apropriado
limpeza (o jogador ainda está conectado quando este evento é acionado).

O comando 'setnpctimer' setá explicitamente o timer para um determinado tique.
'getnpctimer' fornece informações do timer. Seu parâmetro define qual tipo:

0 - Retornará a contagem atual de tiques do temporizador.
1 - Retornará 1 se houver rótulos "OnTimer<ticks>:" restantes no
     NPC especificado aguardando execução.
2 - Retornará o número de vezes que o timer foi acionado e será acionado
     um rótulo "OnTimer<tick>:" no NPC especificado.

Exemplo 1:

	<Cabeçalho NPC> {
	// Precisamos usar attachnpctimer porque o comando mes abaixo precisa de RID attach
		anexar npctimer;
		initnpctimer;
		npctalk "Não posso falar agora, me dê 10 segundos";
		end;
	OnTimer5000:
		npctalk "Ok, mais 5 segundos";
		end;
	OnTimer6000:
		npctalk "4";
		end;
	OnTimer7000:
		npctalk "3";
		end;
	OnTimer8000:
		npctalk "2";
		end;
	OnTimer9000:
		npctalk "1";
		end;
	OnTimer10000:
		parar o temporizador;
		mes "[Homem]";
		mes "Ok, podemos conversar agora";
		detachnpctimer;
		// e lembre-se de que attachnpctimer e detachnpctimer só podem ser usados ​​enquanto o timer do NPC não estiver em execução!
	}

Exemplo 2:

	OnTimer15000:
		npctalk "Mais 15 segundos se passaram.";

		// Você deve usar 'initnpctimer' em vez de 'setnpctimer 0'.
		// Isso é igual a 'setnpctimer 0' + 'startnpctimer'.
		// Alternativamente, você também pode inserir outro rótulo 'OnTimer15001' para que o timer não pare. */
		initnpctimer;
		end;

	// Este rótulo OnInit será executado quando o script for carregado, para que o temporizador
	// é inicializado imediatamente quando o servidor inicia. Ele é descartado de volta para 0
	// toda vez que o NPC disser algo, ele ficará em ciclo contínuo.
	OnInit:
		initnpctimer;
		end;

Exemplo 3:

	mes "[Homem]";
	mes "Eu estava esperando " + (getnpctimer(0)/1000) + " segundos por você.";
	// Dividimos o timer retornado por 1000 para converter milissegundos em segundos.
	close;

Exemplo 4:

	mes "[Homem]";
	mes "Ok, vou deixar você ter mais 30 segundos...";
	close2;
	setnpctimer (getnpctimer(0)-30000);
	// Observe o 'close2'. Se houvesse um 'next' ali o cronômetro seria
	// alterado somente após o jogador pressionar o botão 'próximo'.
	end;

---------------------------------------

*sleep {<milissegundos>};
*sleep2 {<milissegundos>};
*awake "<nome do NPC>";

Esses comandos são usados ​​para controlar a pausa de um NPC.
sleep e sleep2 pausarão o script pelo número determinado de milissegundos.
Awake é usado para cancelar um sono. Quando o wake é chamado em um NPC, ele será executado como
se o temporizador de sono acabasse, e assim fazendo o script continuar. Sleep e sleep2
basicamente faz o mesmo, mas a principal diferença é que o sono não vai manter o livramento,
enquanto sleep2 faz. Além disso, sleep2 irá parar o script se não houver nenhuma unidade anexada.

Exemplos:
	sleep 10000; //pausa o script por 10 segundos e descarta o RID (para que nenhum player seja mais anexado)
	sleep2 5000; //pausa o script por 5 segundos e continua com o RID anexado.
	awake "NPC"; //Cancela qualquer temporizador de sono em execução no NPC 'NPC'.

---------------------------------------

*progressbar "<cor>",<segundos>;

Este comando funciona quase como sleep2, mas exibe uma barra de progresso
acima da cabeça do personagem atualmente anexado (como barra de conjuração).
Depois que a quantidade de segundos fornecida passar, o script será retomado. Se o
o personagem se move enquanto a barra de progresso avança, ele é abortado e
o script termina. O formato da cor é RGB (RRGGBB). A cor é
atualmente ignorado pelo cliente e sempre aparece verde.

OBSERVAÇÃO:
Os clientes Ragexe são conhecidos por travar aleatoriamente se uma janela de mensagem ainda estiver aberta.
Se possível, feche todas as janelas de mensagens antes de acionar o comando progressbar.

---------------------------------------

*progressbar_npc "<cor>",<segundos>{,<"Nome do NPC">};

Este comando funciona como progressbar, mas exibe uma barra de progresso
acima da cabeça do NPC atualmente anexado (ou fornecido). Uma vez que o
dado que a quantidade de segundos passa, o script continua. O formato de cor
está em RGB (RRGGBB). A cor é atualmente ignorada pelo cliente e
parece sempre verde.

---------------------------------------
//
5,1.- Comandos relacionados ao fim dos tempos
//
---------------------------------------

*announce "<texto>",<bandeira>{,<cordafonte>{,<tipodafonte>{,<tamanhodafonte>{,<alinhamentodafonte>{,<fonteY>{,<id_do_caractere>}}}}}};

Este comando transmitirá uma mensagem para todos ou para a maioria dos jogadores, semelhante a
Comandos do GM @kami/@kamib.

	announce "Isso será mostrado para todos em amarelo.",0;

A região onde a transmissão é ouvida (alvo), fonte da transmissão
e a cor em que a mensagem aparecerá é determinada pelas bandeiras.

Os valores dos sinalizadores são codificados como constantes em 'src/map/script_constants.hpp' para torná-los mais fáceis de usar.

Bandeiras de destino:
- bc_all: A mensagem de transmissão é enviada para todo o servidor (padrão).
- bc_map: A mensagem é enviada para todos no mesmo mapa que a fonte da transmissão (veja abaixo).
- bc_area: A mensagem é enviada aos jogadores nas proximidades da fonte.
- bc_self: A mensagem é enviada apenas para o jogador atual, se o sinalizador de origem for bc_pc, também pode
			ser usado para enviar a mensagem para o ID do personagem, se fornecido.
Você não pode usar mais de um sinalizador de destino.

Sinalizadores de origem:
- bc_pc: A fonte da transmissão é o jogador anexado ou o ID do personagem, se fornecido (padrão).
- bc_npc: A fonte da transmissão é o NPC, não o jogador anexado ao script
  (útil quando um jogador não está anexado ou a mensagem deve ser enviada para aqueles
  perto do NPC).
Você não pode usar mais de um sinalizador de origem.

Bandeiras especiais:
- bc_yellow: A transmissão será exibida na cor amarela (padrão).
- bc_blue: A transmissão será exibida na cor azul.
- bc_woe: Indica que esta transmissão é 'Informações WoE' que podem ser desabilitadas no lado do cliente.
Devido à maneira como o cliente manipula as transmissões, é impossível set bc_blue e bc_woe ao mesmo tempo.

Os parâmetros opcionais permitem o uso de transmissões em cores, espessuras de fonte, tamanhos personalizados, etc.
Se qualquer um dos parâmetros opcionais for usado, o sinalizador especial será ignorado.
Parâmetros opcionais podem não funcionar bem (ou não funcionar) dependendo do cliente de jogo usado.

O parâmetro de cor é um único número que pode estar em notação hexadecimal.
Por exemplo:
    announce "Isso será mostrado a todos em verde.",bc_all,0x00FF00;
Exibirá um anúncio global em verde. O formato de cor é RGB (0xRRGGBB).

Em scripts oficiais, apenas dois tipos de fontes são usados:
- normal (FW_NORMAL = 400, padrão),
- negrito (FW_BOLD = 700).

O tamanho padrão da fonte é 12.

Usar isso para mensagens privadas para jogadores provavelmente não é uma boa ideia,
mas pode ser usado em NPCs para "visualizar" um anúncio.

	// Esta será uma mensagem privada para o jogador que usa o NPC que fez o
	// anúncio
	announce "Esta é minha mensagem só para você",bc_blue|bc_self;

	// Isso será mostrado na tela de todos que estiverem na visão do NPC.
	announce "Esta é minha mensagem apenas para vocês aqui",bc_npc|bc_area;

	// Esta será uma mensagem privada para o jogador com id de personagem 150000
	announce "Esta é minha mensagem apenas para o char id 150000",bc_self,0xFFF618,FW_NORMAL,12,0,0,150000;

---------------------------------------

*mapannounce "<nome do mapa>","<texto>",<bandeira>{,<cor da fonte>{,<tipo da fonte>{,<tamanho da fonte>{,<alinhamento da fonte>{,<fonteY>}}}}}};

Este comando funcionará como 'anunciar', mas só será transmitido para personagens
atualmente residindo no mapa especificado. O sinalizador e os parâmetros opcionais
os parâmetros são os mesmos de 'announce', mas os sinalizadores de destino e origem são ignorados.

---------------------------------------

*areaannounce "<nome do mapa>",<x1>,<y1>,<x2>,<y2>,"<texto>",<bandeira>{,<cordafonte>{,<tipodefonte>{,<tamanhodafonte>{,<alinhamentodafonte>{,<fonteY>}}}}}};

Este comando funciona como 'announce', mas só será transmitido para personagens
residindo no retângulo x1/y1-x2/y2 especificado no mapa fornecido. As bandeiras e
Os parâmetros opcionais são os mesmos de 'announce', mas os sinalizadores de destino e origem são ignorados.

	areaannounce "prt_church",0,0,350,350,"Deus está no céu, tudo bem com o mundo",0;

---------------------------------------

*callshop "<nome>"{,<opção>};

Esta é uma série de comandos usados ​​para criar lojas dinâmicas.
A função 'callshop' chama uma loja invisível (view -1) como se o jogador tivesse clicado nela.

As opções são:
	0 = A janela normal (comprar, vender e cancelar) (padrão)
	1 = A janela de compra
	2 = A janela de venda

Nota: O parâmetro <option> só funciona no NPC do tipo 'loja'.

Uma loja chamada com este comando irá acionar os rótulos "OnBuyItem" e "OnSellItem"
(desde que um comando npcshop* seja executado a partir desse NPC, veja a nota abaixo). Estes
os rótulos, se usados, substituirão a forma como a loja lida com a compra e venda de itens,
permitindo a criação de lojas dinâmicas.

O rótulo "OnBuyItem" define as seguintes matrizes:
	@bought_nameid - ID do item comprado
	@bought_quantity - quantidade comprada

O rótulo "OnSellItem" define as seguintes matrizes:
	@sold_nameid - ID do item vendido
	@sold_quantity - quantidade vendida
	@sold_refine - refinar contagem
	@sold_attribute - se o item está quebrado (1) ou não (0)
	@sold_identify - se o item é identificado (1) ou não (0)
	@sold_enchantgrade - enchantgrade
	@sold_card1 - slot para cartão 1
	@sold_card2 - slot para cartão 2
	@sold_card3 - slot para cartão 3
	@sold_card4 - slot para cartão 4
	@sold_option_id1 - ID de opção aleatória 1
	@sold_option_val1 - valor de opção aleatório 1
	@sold_option_param1 - parâmetro de opção aleatória 1
	@sold_option_id2 - ID de opção aleatória 2
	@sold_option_val2 - valor de opção aleatório 2
	@sold_option_param2 - parâmetro de opção aleatória 2
	@sold_option_id3 - ID de opção aleatória 3
	@sold_option_val3 - valor de opção aleatório 3
	@sold_option_param3 - parâmetro de opção aleatória 3
	@sold_option_id4 - ID de opção aleatória 4
	@sold_option_val4 - valor de opção aleatório 4
	@sold_option_param4 - parâmetro de opção aleatória 4
	@sold_option_id5 - ID de opção aleatória 5
	@sold_option_val5 - valor de opção aleatório 5
	@sold_option_param5 - parâmetro de opção aleatória 5

Nota: Esses rótulos só serão acionados se um comando npcshop* for executado porque eles
comandos definem dados especiais no NPC da loja, chamado master_nd na fonte. Os rótulos acima
são acionados no NPC cujo master_nd é fornecido na loja.

Um exemplo completo de uma loja dinâmica pode ser encontrado em doc/sample/npc_dynamic_shop.txt.

---------------------------------------

*npcshopitem "<nome>",<id do item>,<preço>{,<id do item>,<preço>{,<id do item>,<preço>{,...}}};
*npcshopitem "<nome>",<id do item>,<preço>,<estoque>{,<id do item>,<preço>,<estoque>{,<id do item>,<preço>,<estoque>{,...}}};

Este comando permite que você substitua o conteúdo de uma loja NPC ou cashshop existente. O
a lista de vendas atual será apagada e apenas os itens especificados com o preço
especificado estará à venda.

A função retorna 1 se a loja foi atualizada com sucesso, ou 0 em caso de falha.

NOTAS:
- Que você não pode usar -1 para especificar o preço de venda padrão para cashshops, pointshops ou itemsshops.
- Se o tipo de loja anexada for uma loja de mercado, observe que há um parâmetro extra após o preço, <stock>. Certifique-se de não adicionar itens duplicados! Para estoque ilimitado, use -1.

---------------------------------------

*npcshopadditem "<nome>",<id do item>,<preço>{,<id do item>,<preço>{,<id do item>,<preço>{,...}}};
*npcshopadditem "<nome>",<id do item>,<preço>,<estoque>{,<id do item>,<preço>,<estoque>{,<id do item>,<preço>,<estoque>{,...}}};

Este comando adicionará mais itens no final da lista de vendas para o
loja NPC ou cashshop especificada. Se você especificar um item já para venda, esse item será
aparecem duas vezes na lista de vendas.

A função retorna 1 se a loja foi atualizada com sucesso, ou 0 em caso de falha.

NOTAS:
- Que você não pode usar -1 para especificar o preço de venda padrão para cashshops, pointshops ou itemsshops.
- Se o tipo de loja anexada for loja de mercado, será necessário um parâmetro extra após o preço, que é <estoque>
   e certifique-se de não adicionar item duplicado! Para estoque ilimitado use -1.

---------------------------------------

*npcshopdelitem "<nome>",<id do item>{,<id do item>{,<id do item>{,...}}};

Este comando removerá itens da loja ou cashshop do NPC especificado.
Se o item a ser removido existir mais de uma vez na loja, todas as instâncias serão
removido.

Observe que a função retorna 1 mesmo que nenhum item tenha sido removido. O retorno
o valor serve apenas para confirmar que a loja foi realmente encontrada.

---------------------------------------

*npcshopattach "<nome>"{,<sinalizador>};

Este comando anexará o script atual à loja NPC fornecida.
Quando um script é anexado a uma loja, os eventos "OnBuyItem" e "OnSellItem"
do seu script será executado sempre que um jogador comprar/vender na loja.
Além disso, as matrizes @bought_nameid[], @bought_quantity[] ou @sold_nameid[]
e @sold_quantity[] será preenchido com os itens e quantidades
comprado/vendido.

O parâmetro opcional especifica se deve anexar ("1") ou desanexar ("0") de
a loja (o padrão é anexar). Observe que destacar irá destacar qualquer NPC
anexado à loja, mesmo que seja de outro script, enquanto anexar irá
substituir qualquer outro script que já esteja anexado.

A função retorna 0 se a loja não foi encontrada, 1 caso contrário.

NOTAS:
- Se o tipo de loja anexada for uma loja de mercado, o padrão será chamar a janela "comprar".

---------------------------------------

*npcshopupdate "<nome>",<item_id>,<preço>{,<estoque>}

Atualizar uma entrada de uma loja. Se o preço for 0, ele não será alterado. Também pode ser usado para
marketshop para atualizar a quantidade de estoque. Para estoque ilimitado, use -1.
Para outros tipos de loja, o valor do estoque não tem efeito.

Se o preço for -1, ele será definido como o preço de compra padrão.

A função retorna 1 se a loja foi atualizada com sucesso, ou 0 em caso de falha.

NOTAS:
- Que você não pode usar -1 para especificar o preço de venda padrão para cashshops, pointshops ou itemsshops.

---------------------------------------

*waitingroom "<nome da sala de bate-papo>",<limite>{,"<rótulo do evento>"{,<gatilho>{,<zeny obrigatório>{,<nível mínimo>{,<nível máximo>}}}}};

Este comando criará uma sala de bate-papo, de propriedade do objeto NPC que está executando este
script e exibido acima do sprite do NPC.
O comprimento máximo do nome de uma sala de bate-papo é de 60 letras.

O limite é o número máximo de pessoas autorizadas a entrar na sala de bate-papo.
O NPC anexado está incluído nesta contagem. Se o evento opcional e o gatilho
parâmetros são fornecidos, o rótulo do evento ("<nome do objeto NPC>::<nome do rótulo>")
será invocado como se fosse um 'doevent' sobre o número de pessoas no chat
sala atingindo o valor de ativação fornecido.

// O NPC apenas mostrará uma caixa acima de sua cabeça que diz "Olá Mundo", clicando
// não fará nada, pois o limite é zero.
    sala de espera "Olá Mundo",0;

// O NPC terá uma caixa acima de sua cabeça, que dirá "Disco - Sala de Espera"
// e terá 8 slots de espera. Clicar aqui entrará na sala de bate-papo, onde
// o jogador poderá esperar até que 7 jogadores se acumulem. Quando isso acontecer,
// fará com que o NPC "Bouncer" execute o rótulo "OnStart".

    sala de espera "Discoteca - Sala de espera",8,"Bouncer::OnStart",7;

// O NPC terá uma caixa acima de sua cabeça, que dirá "Grupo - Sala de Espera"
// e terá 8 slots de espera. Clicar aqui permitirá que um jogador que tenha
// 5000 zeny e lvl 50~99 para entrar na sala de chat, onde o jogador estará
// capaz de esperar até que 7 jogadores se acumulem. Quando isso acontecer, causará
// o NPC "Bouncer" executa o rótulo "OnStart".

	sala de espera "Festa - Sala de espera",8,"Bouncer::OnStart",7,5000,50,99;

A criação de uma sala de espera não interrompe a execução do script e irá
continue para a próxima linha.

Para mais exemplos, veja os scripts de busca de emprego 2-1 e 2-2 que fazem uso extensivo
de salas de espera.

---------------------------------------

*delwaitingroom {"<nome do objeto NPC"};

Este comando irá apagar uma sala de espera. Se nenhum parâmetro for fornecido, ele irá
exclua uma sala de espera anexada ao objeto NPC que executa este comando, se for o caso,
ele irá deletar uma sala de espera de propriedade de outro objeto NPC. Esta é a única maneira
para se livrar de uma sala de espera, nada mais fará com que ela desapareça.

Não está claro o que acontece com uma sala de espera se o NPC for desabilitado com
'disablenpc', a propósito.

---------------------------------------

*enablewaitingroomevent {"<nome do objeto NPC>"};
*disablewaitingroomevent {"<nome do objeto NPC>"};
*enablearena;
*desabilitararena;

Isso habilitará e desabilitará o acionamento do evento da sala de espera (consulte
'waitingroom') respectivamente. Opcionalmente, fornecer um nome de objeto NPC fará isso
para um objeto NPC especificado. A sala de bate-papo não desaparecerá quando o acionamento for
desabilitado e habilitado dessa maneira e os jogadores não serão expulsos dele.
Habilitar um evento de sala de bate-papo também fará com que ele verifique imediatamente se o
número de usuários excedeu o valor do gatilho e acionou o evento
de acordo.

Normalmente, sempre que uma sala de espera era criada para garantir que apenas uma
personagem está, por exemplo, tentando passar em um teste de missão de trabalho, e nenhum outro
personagens estão presentes na sala para bagunçar o roteiro.

Os comandos 'enablearena'/'disablearena' são apenas aliases sem parâmetro.
Eles supostamente são deixados aqui para compatibilidade com scripts oficiais do servidor,
mas nenhum script brHades usa isso no momento.

---------------------------------------

*getwaitingroomstate(<tipo de informação>{,"<nome do objeto NPC>"})

Esta função retornará informações sobre o estado da sala de espera para o
sala de espera anexa ou para uma sala de espera anexada ao NPC especificado se
qualquer.

Os tipos de informação válidos são:

0 - Número de usuários conversando no momento.
1 - Número máximo de usuários permitidos.
2 - Retornará 1 se a sala de espera tiver um gatilho definido.
      0 caso contrário.
3 - Retornará 1 se a sala de espera estiver desativada no momento.
      0 caso contrário.
4 - O Título da sala de espera (string)
5 - Senha da sala de espera, se houver. Não adianta, pois não tem como
      Defina uma senha para uma sala de espera agora mesmo.
16 - Nome do evento da sala de espera (string)
32 - Se a sala de espera está cheia ou não.
33 - Se a quantidade de usuários na sala de espera é maior que o gatilho
      número.

---------------------------------------

*warpwaitingpc "<nome do mapa>",<x>,<y>{,<número de pessoas>};

Este comando warpá a quantidade de caracteres igual ao número de gatilho de
o chat da sala de espera anexado ao objeto NPC executando este comando para o
mapa e coordenadas especificados, expulsando-os do chat. Aqueles que esperam o
o mais longo será distorcido primeiro. Ele também pode fazer uma distorção aleatória no mesmo mapa
("Aleatório" em vez do nome do mapa) e vá para o ponto de salvamento ("SavePoint").

A lista de personagens a serem teletransportados é retirada da lista de membros da sala de bate-papo.
Aqueles que não estiverem na sala de bate-papo não serão considerados, mesmo que estejam falando com
o NPC em questão. Se o número de pessoas for dado, exatamente essa quantidade de pessoas
será deformado.

Este comando também pode rastrear quem acabou de ser distorcido. Ele faz isso definindo
variáveis ​​especiais:

$@warpwaitingpc[] é uma matriz que contém os números account_id do
                  personagens que foram apenas distorcidos.
$@warpwaitingpcnum contém o número do caractere que acabou de ser distorcido.

Veja também 'getpartymember' para obter conselhos sobre o que fazer com essas variáveis.

A maneira óbvia de usar isso de forma eficaz seria criar uma sala de espera para
dois personagens para serem teletransportados para um mapa PVP aleatório para um duelo um contra um, por
exemplo.

---------------------------------------

*waitingroomkick "<nome do objeto NPC>" , "<nome do personagem>";

Este comando expulsa o personagem fornecido da sala de espera anexado ao NPC fornecido.

---------------------------------------

*getwaitingroomusers "<nome do objeto NPC>";

Este comando obtém todos os personagens na sala de espera do NPC fornecido e armazena
seus gids na matriz .@waitingroom_users[]. Além disso, armazena o número de caracteres
na variável .@waitingroom_usercount.

---------------------------------------

*kickwaitingroomall {"<nome do objeto NPC>"};

Este comando expulsa todos de uma sala de espera específica.

---------------------------------------

*setmapflagnosave "<nome do mapa>","<nome do mapa alternativo>",<x>,<y>;

Este comando define o sinalizador 'nosave' para o mapa especificado e também fornece um
ponto alternativo de respawn após relogin.

Isso não torna um mapa impossível de salvar como você faria normalmente
pense, 'savepoint' ainda funcionará. No entanto, ele fará o mapa especificado
envie os jogadores que estão se reconectando para o mapa alternativo fornecido nas coordenadas
especificado.

---------------------------------------

*setmapflag "<nome do mapa>",<sinalizador>{,<zona>{,<tipo>}};

Este comando marca um mapa especificado com o sinalizador de mapa fornecido, o que alterará o
comportamento do mapa. Uma lista completa de mapflags está localizada em 'src/map/script_constants.hpp' com
o prefixo 'mf_' e a documentação pode ser encontrada em 'doc/mapflags.txt'.

As bandeiras do mapa alteram o comportamento do mapa em relação ao teletransporte (mf_nomemo,
mf_noteleport, mf_nowarp, mf_nogo), armazenando o local quando desconectado
(mf_nosave), uso de branch morto (mf_nobranch), penalidades em caso de morte
(mf_nopenalty, mf_nozenypenalty), comportamento PVP (mf_pvp, mf_pvp_noparty,
mf_pvp_noguild), comportamento WoE (mf_gvg,mf_gvg_noparty), capacidade de usar
habilidades ou abrir acordos comerciais (mf_notrade, mf_novending, mf_noskill, mf_noicewall),
efeitos climáticos atuais (mf_snow, mf_fog, mf_sakura, mf_leaves, mf_rain, mf_clouds,
mf_fireworks) e se a noite estará em vigor neste mapa (mf_nightenabled).

O parâmetro opcional <zone> é usado para set a zona para mapflags 'restritos',
Bypass de nível GM para 'nocommand', experiência base/trabalho para 'bexp'/'jexp' e
bandeira para 'campo de batalha'.

Para o sinalizador de mapa 'skill_damage':
	- set a bandeira aqui ajustará o dano global (todas as habilidades) no mapa.
	- <zona> é o valor de ajuste de dano de -100 a 100000 das habilidades.
	- Veja 'getmapflag' para os diferentes valores <type>.
Para o sinalizador de mapa 'skill_duration':
	- <zona> é o ID da habilidade a ser ajustada.
	- <tipo> é a porcentagem de ajuste de 0 a 100000.

---------------------------------------

*removemapflag "<nome do mapa>",<sinalizador>{,<zona>};

Este comando remove um mapflag de um mapa especificado.
Veja 'setmapflag' para uma lista de mapflags.

O parâmetro opcional 'zone' é usado para remover a zona de mapflags restritos.

---------------------------------------

*getmapflag("<nome do mapa>",<sinalizador>{,<tipo>})

Este comando verifica o status de um determinado mapflag e retorna o estado do mapflag.
0 significa OFF, e 1 significa ON. Veja 'setmapflag' para uma lista de mapflags.

Para MF_RESTRICTED, o valor da zona do mapa é retornado.

O parâmetro opcional 'type' é usado no mapflag 'skill_damage':
SKILLDMG_MAX: se mapflag estiver definido (padrão)
SKILLDMG_PC: dano contra jogadores
SKILLDMG_MOB: dano contra mobs
SKILLDMG_BOSS: dano contra chefes
SKILLDMG_OTHER: dano contra outro
SKILLDMG_CASTER: tipo de conjurador

---------------------------------------

*setbattleflag "<bandeira de batalha>",<valor>{,<recarregar>};
*getbattleflag("<bandeira de batalha>")

Define ou obtém o valor do sinalizador de batalha fornecido.
Os sinalizadores de batalha são os sinalizadores encontrados nos arquivos battle / *.conf e também são usados ​​no script de taxas variáveis ​​do Lupus.
Se o valor de recarga for fornecido, o servidor tentará recarregar os dados do monstro
para aplicar corretamente as novas taxas. Isso se aplica às configurações do tipo EXP/Drop. O servidor
tentará apenas recarregar configurações específicas.

Exemplos:

// setá a taxa de experiência base para 20x (2000%) - Os dados do monstro continuarão a usar as taxas anteriores no início do servidor
	setBattleFlag "taxa_de_exp_base",2000;

// setá a taxa de experiência base para 20x (2000%) - Os dados do monstro serão recarregados para o novo valor
	setBattleFlag "base_exp_rate",2000,verdadeiro;

// Retornará o valor da taxa de experiência baif (quando usado após o exemplo acima, imprimirá 2000).
	mes getBattleFlag("base_exp_rate");

---------------------------------------

*warpportal <fonte x>,<fonte y>,"<nome do mapa>",<alvo x>,<alvo y>;

Cria um portal de dobra idêntico à habilidade "Portal de dobra" do Acólito.
As coordenadas de origem especificam a localização do portal no mapa do NPC invocador.
O mapa de destino e as coordenadas determinam o destino do portal.

Exemplos:

// Criará um portal de teletransporte no mapa do NPC em 150.150 levando a prontera, coordenadas 150.180.
	portal de guerra 150.150,"prontera",150.180;

---------------------------------------

*mapwarp "<do mapa>","<para o mapa>",<x>,<y>{,<tipo>,<ID>};

Este comando coletará todos os personagens localizados no mapa From e os teletransportará
atacado para o mesmo ponto no mapa, ou distribuí-los aleatoriamente lá se
as coordenadas são zero. "Aleatório" é entendido como um nome especial para mapear e
significará embaralhar aleatoriamente todos no mesmo mapa.

Opcionalmente, um tipo e ID podem ser especificados. Os tipos disponíveis são:

0 - Todos
1 - Guild
2 - Festa

Exemplo:

// Teleportará todos os membros da guilda com ID 63 no mapa prontera para o mapa alberta.
	mapwarp "prontera","alberta",150,150,1,63;

---------------------------------------
\\
5,2.- Comandos relacionados à guilda
\\
---------------------------------------

*maprespawnguildid "<nome do mapa>",<id da guilda>,<bandeira>;

Este comando percorre o mapa especificado e para cada jogador e monstro
achei que lá faz coisas.

A bandeira é uma máscara de bits (some números para obter os efeitos desejados)
1 - teletransportar todos os membros da guilda para seus pontos de salvamento.
2 - teletransportar todos os não membros da guilda (incluindo jogadores sem guilda) para seus pontos de salvamento.
4 - remova todos os monstros que não sejam guardiões ou Emperium.

A bandeira 7 significará, portanto, 'eliminar todos os mobs, exceto os guardiões e o Império e
expulsar todos os personagens', que é o que os scripts oficiais fazem no castelo
rendição. No início do WoE, os scripts fazem 2 (teletransportam todos os intrusos para fora).

Para exemplos, verifique os scripts WoE na distribuição.

---------------------------------------

*agitstart;
*agitar;
*agitstart2;
*agitend2;
*agitstart3;
*agitend3;

Esses comandos iniciarão e encerrarão o War of Emperium FE, War of Emperium SE,
ou Guerra do Emperium TE.

Isso é um pouco mais complexo do que parece, já que os comandos em si não
realmente fazer algo interessante, exceto causar todos os 'OnAgitStart:' e
'OnAgitEnd:', 'OnAgitStart2:' e 'OnAgitEnd2:', ou 'OnAgitStart3:' e
'OnAgitEnd3:' no caso dos dois últimos comandos, eventos a serem executados em todos os lugares,
respectivamente. Eles são usados ​​como gatilhos simples para executar muitos scripts complexos
em todo o servidor e eles, por sua vez, são acionados pelo relógio com um
'OnClock<time>:' rótulo de disparo de tempo.

---------------------------------------

*gvgon "<nome do mapa>";
*gvgoff "<nome do mapa>";

Esses comandos ativarão e desativarão o modo GVG para os mapas especificados, configurando
bandeiras de mapa apropriadas. No modo GVG, os mapas se comportam como se estivessem durante o tempo de WoE,
mesmo que o próprio WoE possa ou não estar em vigor.

---------------------------------------

*gvgon3 "<nome do mapa>";
*gvgoff3 "<nome do mapa>";

Esses comandos se comportam de forma idêntica ao gvgon/gvgoff, mas aplicam o mapflag GVG_TE.

---------------------------------------

*flagemblem <id da guilda>;

Este comando só funciona quando executado por objetos NPC que tenham id de sprite 722,
que é um sprite de bandeira de guilda 3D. Se não for, os dados mudarão, mas nada
será visto por qualquer um. Se for invocado dessa maneira, o emblema do
a guilda especificada aparecerá na bandeira, no entanto, se algum jogador estiver assistindo
neste momento, eles não verão a mudança do emblema até que saiam de vista
da bandeira e retorno.

Isso é comumente usado em scripts oficiais de guildwar com uma chamada de função que
retorna um id de guilda:

// Isso mudará o emblema na bandeira para o da guilda que a possui
// "castelo da guilda"

    flagemblema GetCastleData("guildcastle",1);

---------------------------------------

*guardian "<nome do mapa>",<x>,<y>,"<nome a ser exibido>",<id do mob>{,"<rótulo do evento>"{,<índice do guardião>}};

Este comando é aproximadamente equivalente a 'monstro', mas deve ser usado com
monstros guardiões do castelo e só funcionará com eles. Isso setá o guardião
características de acordo com os valores de investimento do castelo e de outra forma
configure as coisas que somente os guardiões do castelo precisam.

Desde o tronco r12524:
Retorna o id do mob ou 0 se ocorreu um erro.
Quando o 'índice de guardião' não é fornecido, ele produz um guardião temporário.
Guardiões temporários não são salvos com o castelo e não podem ser acessados ​​pelo guardianinfo.

---------------------------------------

*guardianinfo("<nome do mapa>", <número do guardião>, <tipo>);

Esta função retornará várias informações sobre o guardião especificado, ou -1
se falhar por algum motivo. É usado principalmente no NPC gerente do castelo.

O nome do mapa e o número do guardião (valor entre 0 e 7) definem o alvo.
O tipo indica quais informações retornar:
0 - visibilidade (se o guardião está instalado ou não)
1 - máx. hp
2 - hp atual

---------------------------------------

*getguildalliance(<id1 da guilda>, <id2 da guilda>);

Este comando retornará a relação entre duas guildas.

NOTA: Isso deve ser usado em colaboração com 'requestguildinfo' como o
map-server precisa solicitar informações do char-server.

Valores de retorno:
	-2 - ID da guilda1 não existe
	-1 - ID da guilda2 não existe
	 0 - Ambas as guildas não têm relação OU o ID da guilda não foi fornecido
	 1 - Ambas as guildas são aliadas
	 2 - Ambas as guildas são antagonistas

---------------------------------------
//
5,2.- Fim dos comandos relacionados à guilda
//
---------------------------------------

*npcspeed( <valor de velocidade> {,"<nome do npc>"} );
*npcwalkto( <x>,<y> {,"<nome do npc>"} } );
*npcstop( {"<nome do npc>", {"<sinalizador>"}});

Esses comandos farão com que o objeto NPC em questão se mova pelo mapa.

'npcsspeed' setá permanentemente a velocidade de caminhada dos NPCs para um valor especificado. Como no
@speed comando GM, MAX_WALK_SPEED (1000) é a velocidade mais lenta possível enquanto MIN_WALK_SPEED (20) é a mais rápida
possível (movimento instantâneo). DEFAULT_NPC_WALK_SPEED (200) é a velocidade de caminhada padrão do NPC.

'npcwalkto' iniciará o movimento do sprite do NPC em direção às coordenadas especificadas
no mesmo mapa em que está atualmente. O script prossegue imediatamente após o
O NPC começa a se mover.

'npcstop' interromperá o movimento.

O valor <flag> em npcstop afeta como a unidade é parada. Os seguintes flags são valores bitwiif (podem ser combinados usando o operador pipe):
	USW_NONE = A unidade continuará caminhando até seu destino original.
	USW_FIXPOS = Emita um pacote fixpos posteriormente.
	USW_MOVE_ONCE = Força a unidade a mover uma célula, caso ainda não o tenha feito.
	USW_MOVE_FULL_CELL = Habilita a movimentação para a próxima célula quando a unidade já estiver na metade do caminho (pode causar efeitos colaterais ao tocar/colocar, como uma alteração de mapa com script).
	USW_FORCE_STOP = Forçar parada de movimento.
Padrão: USW_FIXPOS | USW_MOVE_FULL_CELL | USW_FORCE_STOP

Durante o trânsito, o NPC será clicável, mas invocá-lo fará com que ele
pare de se mover, o que tornará suas coordenadas diferentes das do cliente
calculado com base nas coordenadas de velocidade e movimento.

Apenas alguns sprites NPC têm animações de caminhada, e aqueles que têm, não recebem
a animação invocada ao mover o NPC, devido ao problema no andar do NPC
código, que parece um pouco bobo. Você pode ter mais sucesso definindo um job-
id de sprite baseado em sprite em 'db/mob_avail.yml' com isto.

---------------------------------------

*movenpc "<nome do NPC>",<x>,<y>{,<dir>};

Este comando se parece com a função NPCWalkToxy, mas é um pouco diferente.

Enquanto NPCWalkToXY apenas faz o NPC 'andar' até as coordenadas fornecidas (o que
às vezes dá problemas se o caminho não for uma linha reta sem objetos),
este comando apenas move o NPC. Ele basicamente se teletransporta para dentro e para fora no atual
e dado local. Direction pode ser usado para mudar a direção de visão do NPC.

Exemplo:

// Isso moverá o Bugga de suas coordenadas antigas para as novas coordenadas em 100,20 (se essas coordenadas forem legítimas).
	moverNPC "Bugga",100,20;

---------------------------------------

=====================
|6.- Outros comandos.|
=====================
---------------------------------------

*depura "<mensagem>";

Este comando enviará uma mensagem de depuração para o console do servidor (janela do servidor de mapas). Ele
não será exibido em nenhum outro lugar.

    // Exibe "NAME clicou em mim!" na janela do servidor de mapas.
    debugmes strcharinfo(0) + "clicou em mim!";

---------------------------------------

*errormes "<mensagem>";

Este comando enviará uma mensagem de erro para o console do servidor (janela do servidor de mapas).
não será exibido em nenhum outro lugar.

    // Exibe "NAME clicou em mim!" na janela do servidor de mapas.
    errormes strcharinfo(0) + "clicou em mim!";

---------------------------------------

*logmes "<mensagem>";

Este comando irá escrever a mensagem dada no arquivo de log NPC do servidor de mapas, como
especificado em 'conf/log_athena.conf'. Na versão TXT do servidor, o log
o arquivo é 'log/npclog.log' por padrão. Na versão SQL, se o log SQL for
habilitado, a mensagem irá para a tabela 'npclog', caso contrário, irá para a
mesmo arquivo de log.

Se os logs não estiverem habilitados, nada acontecerá.

---------------------------------------

*globalmes "<mensagem>"{,"<nome do NPC>"};

Este comando enviará uma mensagem para a janela de bate-papo de todos os usuários conectados no momento
personagens.

Se o nome do NPC for especificado, a mensagem será enviada como se o remetente fosse
o NPC com o dito nome.
O nome de exibição do NPC não será acrescentado na frente da mensagem.

---------------------------------------

*rand(<número>{,<número>});

Esta função retorna um número ...
(se você especificar um) ... posicionado aleatoriamente entre 0 e o número que você especificar -1.
(se você especificar dois) ... posicionados aleatoriamente entre os dois números que você especificar.

rand(10) resultaria em 0,1,2,3,4,5,6,7,8 ou 9
rand(0,9) resultaria em 0,1,2,3,4,5,6,7,8 ou 9
rand(2,5) resultaria em 2,3,4 ou 5

---------------------------------------

*ponto de vista <ação>,<x>,<y>,<número do ponto>,<cor>{,<ID do caractere>};

Este comando marcará lugares no mini mapa no cliente conectado ao
invocando personagem. Ele usa as coordenadas X e Y normais do mapa principal.
As cores das marcas são definidas através de um número hexadecimal, igual aos
usado para colorir texto na saída 'mes', mas são escritos como números hexadecimais em C.
(Eles se parecem com 0x<seis números>.)

Ação é o que você quer fazer com um ponto, 1 irá defini-lo, enquanto 2 irá limpá-lo
it. 0 também irá defini-lo, mas removerá o ponto automaticamente após 15 segundos.
O número do ponto é o número do ponto - você pode ter vários. Se mais de
um ponto é desenhado nas mesmas coordenadas, eles irão circular, o que pode ser usado
para criar marcas piscantes.

	// Este comando mostrará uma marca nas coordenadas X 30 Y 40, é a marca número 1,
	// e será vermelho.

	ponto de vista 1,30,40,1,0xFF0000;

Isso criará três pontos:

	ponto de vista 1,30,40,1,0xFF0000;
	ponto de vista 1,35,45,2,0xFF0000;
	ponto de vista 1,40,50,3,0xFF0000;

E é assim que você os remove:

	ponto de vista 2,30,40,1,0xFF0000;
	ponto de vista 2,35,45,2,0xFF0000;
	ponto de vista 2,40,50,3,0xFF0000;

O cliente determina o que faz com os pontos inteiramente, o servidor não mantém nada
memória de onde os pontos estão colocados.

---------------------------------------

*viewpointmap "<nome do mapa>",<ação>,<x>,<y>,<número do ponto>,<cor>;

Este comando marcará lugares no minimapa do cliente para todos os jogadores atualmente
no mapa definido. Ele usa as coordenadas X e Y normais do mapa principal.
As cores das marcas são definidas através de um número hexadecimal, igual aos
usado para colorir texto na saída 'mes', mas são escritos como números hexadecimais em C.
(Eles se parecem com 0x<seis números>.)

Ação é o que você quer fazer com um ponto, 1 irá defini-lo, enquanto 2 irá limpá-lo
it. 0 também irá defini-lo, mas removerá o ponto automaticamente após 15 segundos.
O número do ponto é o número do ponto - você pode ter vários. Se mais de
um ponto é desenhado nas mesmas coordenadas, eles irão circular, o que pode ser usado
para criar marcas piscantes.

	// Este comando mostrará uma marca nas coordenadas X 30 Y 40, é a marca número 1,
	// e ficará vermelho para todos os jogadores atualmente no mapa Prontera.

	mapa de ponto de vista "prontera",1,30,40,1,0xFF0000;

Isso criará três pontos:
	.@map$ = "prontera";
	viewpointmap .@map$,1,30,40,1,0xFF0000;
	viewpointmap .@map$,1,35,45,2,0xFF0000;
	viewpointmap .@map$,1,40,50,3,0xFF0000;

E é assim que você os remove:
	.@map$ = "prontera";
	viewpointmap .@map$,2,30,40,1,0xFF0000;
	viewpointmap .@map$,2,35,45,2,0xFF0000;
	viewpointmap .@map$,2,40,50,3,0xFF0000;

O cliente determina o que faz com os pontos inteiramente, o servidor não mantém nada
memória de onde os pontos estão colocados.

---------------------------------------

*cutin "<nome do arquivo>",<posição>;

Este comando exibirá uma imagem, geralmente uma ilustração de NPC, também chamada
cutin, para o cliente atualmente conectado. O parâmetro de posição determina o
colocação da ilustração e assume os seguintes valores:

	0 canto inferior esquerdo
	1 meio inferior
	2 canto inferior direito
	3 meio da tela em uma janela móvel com uma barra de título vazia
	4 meio da tela sem o cabeçalho da janela, mas ainda móvel
	255 limpar todos os cortes exibidos

A imagem é lida de data\texture\유저인터페이스\illust, do arquivo GRF
e pasta de dados, e é necessário ser um bitmap. A extensão de arquivo .bmp pode ser
omitido. A cor magenta (#ff00ff) é considerada transparente. Não há limite
colocadas no tamanho das ilustrações pelo cliente, embora o carregamento de grandes
imagens (cerca de 700x700 e maiores) fazem com que o cliente congele por um breve período (atraso).
Normalmente o tamanho é cerca de 320x480. Novas ilustrações podem ser adicionadas apenas
colocando o novo arquivo no local acima.

O cliente pode exibir apenas um corte por vez e cada novo corte
fará com que o antigo desapareça. Para excluir o exibido atualmente
ilustração sem exibir uma nova, um nome de arquivo vazio e posição 255
deve ser usado.

	// Exibe a ilustração do Comodo Kafra no canto inferior direito.
	corte "kafra_07",2;

	// Maneira típica de terminar um script, que exibia uma ilustração durante uma
	// diálogo com um jogador.
	mes "Até mais.";
	close2;
	corte "",255;
	end;

---------------------------------------

*emoção <número da emoção>{,<alvo>};

Este comando faz com que um objeto exiba um sprite de emoção acima do seu próprio
se eles estivessem fazendo essa emoção. Para uma lista completa de números de emoção,
veja 'src/map/script_constants.hpp' em 'ET_'. Os não tão óbvios são 'ET_QUESTION'
(um ponto de interrogação) e 'ET_SURPRISE' (o ponto de exclamação).

O parâmetro de destino opcional especifica quem receberá a emoção além de
a cabeça deles. Use o ID do jogo alvo (GID).

---------------------------------------

*misceffect <número do efeito>;

Este comando, se executado a partir de um objeto NPC que tenha um sprite, chamará um
número de efeito especificado, centralizado no sprite do NPC. Se o código em execução não
não tem um ID de objeto (um NPC 'flutuante') ou não está sendo executado a partir de um objeto NPC em
todos (um script de item) o efeito será centrado no personagem que está LIVRE
anexado ao script, se houver. Para scripts de itens utilizáveis, este comando irá
crie um efeito centrado no jogador que está usando o item.

Uma lista completa de efeitos conhecidos pode ser encontrada em 'doc/effect_list.txt'. A lista de
aqueles que realmente funcionam podem diferir muito entre as versões do cliente.

---------------------------------------

*soundeffect "<nome do arquivo do efeito>",<tipo>;
*soundeffectall "<nome do arquivo do efeito>",<tipo>{,"<nome do mapa>"}{,<x0>,<y0>,<x1>,<y1>};

Esses dois comandos reproduzirão um efeito sonoro para o caractere de invocação
apenas ('soundeffect') ou vários caracteres ('soundeffectall'). Se a execução
o código não tem um ID de objeto (um NPC 'flutuante') ou não está sendo executado a partir de um NPC
objeto em tudo (um script de item) o som será centralizado no personagem que está
RID foi anexado ao script, se houver. Se for, será centralizado nisso
objeto. (um sprite NPC)

O nome do arquivo de efeito é o nome do arquivo em um GRF. Ele deve ter a extensão .wav.

Não é bem certo o que o 'tipo' realmente faz, ele é enviado ao cliente
diretamente. Provavelmente determina de qual diretório tocar o efeito.
É certo que dar 0 para o número reproduzirá arquivos de som de '\data\wav\',
mas não está claro de onde os outros números serão lidos.

Os arquivos de som em si devem estar no formato PCM e os nomes dos arquivos também devem
ter um comprimento máximo de 23 caracteres, incluindo a extensão .wav:

efeito sonoro "1234567890123456789.wav", 0; // isso reproduzirá o efeito sonoro
efeito sonoro "12345678901234567890.wav", 0; // lança erro de gravidade

Você pode adicionar seus próprios efeitos dessa forma, naturalmente.

---------------------------------------

*playBGM "<nome do arquivo BGM>";
*playBGMall "<nome do arquivo BGM>"{,"<nome do mapa>"{,<x0>,<y0>,<x1>,<y1>}};

Esses dois comandos tocarão uma música de fundo para o personagem que o invoca
somente ('playBGM') ou múltiplos caracteres ('playBGMall').

O nome do arquivo BGM é o nome do arquivo na pasta /BGM/. Ele precisa estar na extensão .mp3.

Não é necessário especificar a extensão dentro do script.
Se as coordenadas forem omitidas, o BGM será transmitido em todo o mapa. Se o nome do mapa
é omitido também, a BGM será tocada para todo o servidor.

Você pode adicionar suas próprias músicas de fundo dessa forma, naturalmente.

---------------------------------------

*pvpon "<nome do mapa>";
*pvpoff "<nome do mapa>";

Esses comandos ativarão e desativarão o modo PVP para os mapas especificados. Além disso
set os sinalizadores mencionados em 'setmapflag', 'pvpon' também criará um PVP
temporizador e classificação como o comando GM @pvpon fará.

---------------------------------------

*atcommand "<comando>";

Este comando executará a linha de comando fornecida exatamente como se tivesse sido digitada em
o teclado pelo jogador conectado ao personagem invocador, e que
personagem pertencia a uma conta que tinha nível GM 99.

	// Isso pedirá ao invocador um nome de personagem e então usará o '@nuke'
	// Comando do GM sobre eles, matando-os impiedosamente.
	entrada .@player$;
	no comando "@nuke " + .@player$;

Observe que para atcommands vinculados usando 'bindatcmd', este comando executará o
atcommand original, não o atcommand vinculado ao script.

---------------------------------------

*charcommand "<comando>";

Este comando executará a linha de comando fornecida exatamente como se tivesse sido digitada em
o teclado de um personagem que pertencia a uma conta que tinha nível GM 99.

Os comandos também podem ser executados sem um rid anexado.

	// Isso faria o mesmo que acima, mas agora
	// não precisa de um player conectado por padrão.
	charcommand "#opção 0 0 0 Roy";

---------------------------------------

*bindatcmd "<comando>","<nome do objeto NPC>::<rótulo do evento>"{,<nível do comando at>,<nível do comando char>};

Este comando vinculará um rótulo de evento NPC a um comando at. Após a execução do
atcommand, o usuário invocará o rótulo do evento NPC. Cada atcommand só é permitido
uma ligação. Se você religar, ela substituirá a ligação original.
Observação: o nível padrão para atcommand é 0, enquanto o nível padrão para charcommand é 100.

As seguintes variáveis ​​são definidas durante a execução:
	.@atcmd_command$ = O nome do @command usado.
	.@atcmd_parameters$[] = Matriz contendo os parâmetros fornecidos, começando com um índice de 0.
	.@atcmd_numparameters = O número de parâmetros definidos.

Exemplo:

	Quando um usuário digita o comando "@test", um efeito anjo será mostrado.

	- script atcmd_example -1,{
	OnInit:
		bindatcmd "teste",strnpcinfo(3) + "::OnAtcommand";
		end;
	OnAtcommand:
		efeito especial2 EF_ANGEL2;
		end;
	}

---------------------------------------

*unbindatcmd "<comando>";

Este comando desvinculará um rótulo de evento NPC de um comando at.

---------------------------------------

*useatcmd "<comando>";

Este comando executará um comando at vinculado ao script para o RID anexado. Se o
o comando fornecido não está vinculado a nenhum script, este comando agirá como 'atcommand'
e tentar executar um comando definido pela fonte.

As três variáveis ​​.@atcmd_***** NÃO serão definidas ao invocar comandos at vinculados a script
desta maneira.

---------------------------------------

*camerainfo <intervalo>,<rotação>,<latitude>{,<id do caractere>};

Este comando atualizará as informações da câmera do cliente com os valores fornecidos onde
o cliente pode ser o personagem anexado ou o jogador fornecido pelo parâmetro char id.
Observação: isso requer 2016-05-25aRagexeRE ou mais recente.

Os valores fornecidos serão divididos por 100 e transmitidos como números de ponto flutuante.

	alcance O fator de zoom da câmera.
				Padrão: 230000 (230,0) quando totalmente ampliado
				Máximo: 400000 (400,0) quando totalmente ampliado

	rotação A rotação da câmera.
				Padrão: 0 (0,0) quando nenhuma rotação é aplicada
				Máximo: 360000 (360,0°) quando totalmente girado

	latitude O ângulo da câmera.
				Padrão: -50000 (-50,0)
				Máximo: -75000 (-75,0)

---------------------------------------

*refineui({<id do caractere>})

Abre a interface de refinamento para o jogador anexado ou para o ID de personagem fornecido.

Este recurso requer 2016-10-12aRagexeRE ou mais recente.

---------------------------------------

*openstylist({<id do caractere>})

Abre a interface do estilista para o jogador anexado ou para o ID de personagem fornecido.

Este recurso requer a versão do pacote 2015-11-04 ou mais recente.

---------------------------------------

*laphine_synthesis({<id do item>})
*laphine_synthesis({<"nome do item">})

Abre a interface de síntese do Laphine para <ID do item> ou <nome do item> para o player anexado.
Se executado dentro de um script de item, <ID do item> ou <nome do item> é opcional.

Este recurso requer a versão do pacote 2016-06-01 ou mais recente.

---------------------------------------

*atualização_laphine()

Abre a interface de atualização do laphine para o player conectado.

Este recurso requer a versão do pacote 2017-07-26 ou mais recente.

Esta função deve ser usada em scripts de itens.

---------------------------------------

*openbank({<id do caractere>})

Abre a interface do banco para o jogador vinculado ou para o ID do personagem fornecido.

Este comando requer a versão do pacote 2015-12-02 ou mais recente.

---------------------------------------

*enchantgradeui {<id do caractere>};

Abre a interface do usuário do enchantgrade para o personagem anexado ou o jogador fornecido pelo parâmetro char ID.

Este comando requer a versão do pacote 2020-07-24 ou mais recente.

---------------------------------------

*set_reputation_points(<tipo>,<pontos>{,<id do caractere>})

Define os pontos de reputação via <pontos> para o grupo de reputação <tipo> para o jogador anexado ou o ID de personagem fornecido.
<type> é o índice do lado do cliente, conforme armazenado no campo Id dos arquivos de banco de dados reputation.yml.

---------------------------------------

*get_reputation_points(<tipo>{,<id do caractere>})

Obtém os pontos de reputação para o grupo de reputação <tipo> do jogador anexado ou do ID de personagem fornecido.
<type> é o índice do lado do cliente, conforme armazenado no campo Id dos arquivos de banco de dados reputation.yml.

---------------------------------------

*add_reputation_points(<tipo>,<pontos>{,<id do caractere>})

Adiciona os pontos de reputação via <pontos> para o grupo de reputação <tipo> para o jogador anexado ou para o ID de personagem fornecido.
<type> é o índice do lado do cliente, conforme armazenado no campo Id dos arquivos de banco de dados reputation.yml.

---------------------------------------

*item_reform({<id do item>{,<id do caractere>}})
*item_reform({<"nome do item">{,<id do caractere>}})

Abre a interface de reforma de itens para <ID do item> ou <nome do item> para o jogador anexado ou o ID do personagem fornecido.
Se executado dentro de um script de item, <ID do item> ou <nome do item> é opcional.

Este recurso requer a versão do pacote 2021-11-03 ou mais recente.

---------------------------------------

*item_enchant(<índice LUA do lado do cliente>{,<ID do caractere>});

Abre a interface de encantamento para o personagem anexado ou o jogador fornecido pelo parâmetro <char ID>.
Se o jogador exceder 70% do peso, o cliente não abrirá a IU de encantamento e acionará um
mensagem de erro em vez disso.

Este comando requer a versão do pacote 2021-11-03 ou mais recente.

---------------------------------------

*opentips({<ID da dica>,{<ID do caractere>}});

Abre a interface do usuário da caixa de dicas para o jogador anexado ou para o ID do personagem fornecido.

Este comando requer a versão do pacote 2017-11-22 ou mais recente.

---------------------------------------

*specialpopup(<ID do pop-up>);

Abra o pop-up e/ou mostre o texto pelo ID da lista definida no arquivo spopup.lub do cliente.
O pop-up e o texto só ficam visíveis se o jogador for teleportado de um mapa para outro.

Este comando requer a versão do pacote 2022-10-05 ou mais recente.

---------------------------------------
\\
6,1.- Comandos relacionados à unidade
\\
---------------------------------------

*unitwalk <GID>,<x>,<y>{,"<rótulo do evento>"};
*unitwalkto <GID>,<GID de destino>{,"<rótulo do evento>"};

Este comando dirá a um <GID> para caminhar até uma posição, definida como um conjunto de
coordenadas ou outro objeto. O comando retorna 1 para sucesso e 0 em caso de falha.

Se as coordenadas forem passadas, o <GID> caminhará até as coordenadas x,y fornecidas no
mapa atual da unidade. Embora não haja como se mover por um mapa inteiro com 1 comando
uso, isso pode ser usado em um loop para mover longas distâncias.

Se um ID de objeto for passado, o <GID> inicial irá para o <GID de destino> (semelhante a
caminhando para atacar). Isto é baseado na distância de <GID> para <ID do alvo>. Este comando
usa uma verificação de caminhada difícil, então ele calculará um caminho de caminhada com obstáculos. Enviar um caminho ruim
o ID de destino resultará em um erro.

Um rótulo de evento opcional também pode ser passado, que será executado quando o <GID> for atingido
as coordenadas fornecidas ou <Target GID>.

Exemplos:

// Faz o jogador caminhar até as coordenadas (150,150).
	unitwalk getcharid(3),150.150;

// Executa uma verificação condicional com o comando e relata sucesso ou falha ao jogador.
	if (unidadecaminhada(getcharid(3),150,150))
		dispbottom "Te acompanhando até lá...";
	outro
		dispbottom "Isso é muito longe, cara.";

// Faz o jogador caminhar até outro personagem chamado "WalkToMe".
	unidadecaminharparaobtercharid(3),obtercharid(3,"WalkToMe");

---------------------------------------

*unitattack <GID>,<ID do alvo>{,<tipo de ação>};
*unitattack <GID>,"<Nome do alvo>"{,<tipo de ação>};

Este comando fará um ataque <GID> no alvo especificado. Ele retorna verdadeiro em
sucesso e falso para todos os fracassos.

Se <GID> for um jogador e um <tipo de ação> diferente de zero for fornecido, a unidade executará uma
ataque contínuo em vez de um único ataque.

Observação:
Usar unitattack com <GID> 0 significa que ele usará a unidade atualmente anexada.
Para os jogadores, qualquer solicitação de ataque falhará, porque falar com um NPC impede que ataquem um monstro.
Portanto, você precisa separar o jogador do NPC antes de usar este comando.

---------------------------------------

*unidadekill <GID>;

Este comando irá matar um <GID>.

---------------------------------------

*unitwarp <GID>,"<nome do mapa>",<x>,<y>;

Este comando irá warp um <GID> para o mapa e coordenadas especificados.

Se <GID> for zero, o comando é executado para a unidade que invocou o script. Isso pode ser
usado com "OnTouch" para teleportar monstros:

Em toque:
	unitwarp 0,"este",-1,-1;

---------------------------------------

*unitstopattack <GID>;

Este comando fará com que um <GID> pare de atacar.

---------------------------------------

*unitstopwalk <GID>{,<bandeira>};

Este comando fará com que um <GID> pare de se mover.

Nota: Se isso for chamado do OnTouch, o walktimer conectado à unidade será
removido do OnTouch, o que faz com que este comando não impeça a unidade de andar.
Sugira usar 'unitblockmove' para parar a unidade à força com o OnTouch.

O valor <flag> afeta como a unidade é parada. Os seguintes flags são bitwise
valores (podem ser combinados usando o operador pipe):
	USW_NONE = A unidade continuará caminhando até seu destino original.
	USW_FIXPOS = Emita um pacote fixpos posteriormente.
	USW_MOVE_ONCE = Força a unidade a mover uma célula, caso ainda não o tenha feito.
	USW_MOVE_FULL_CELL = Habilita a movimentação para a próxima célula quando a unidade já estiver na metade do caminho (pode causar efeitos colaterais ao tocar/colocar, como uma alteração de mapa com script).
	USW_FORCE_STOP = Forçar parada de movimento.

Este comando também removerá o rastreamento de estado usado para 'unitwalk' e 'unitwalkto'.

---------------------------------------

*unittalk <GID>,"<texto>"{,flag};

Este comando fará um <GID> dizer uma mensagem. O nome de exibição do <GID> não será anexado na frente da mensagem.
flag: Especificar alvo
   bc_area - A mensagem é enviada aos jogadores nas proximidades da fonte (padrão).
   bc_self - A mensagem é enviada somente para o jogador anexado.

---------------------------------------

*unitskilluseid <GID>,<id da habilidade>,<nível da habilidade>{,<id do alvo>,<tempo de transmissão>,<cancelar>,<ID_da_linha>,<intervalo_de_ignorar>};
*unitskilluseid <GID>,"<nome da habilidade>",<nível da habilidade>{,<id do alvo>,<tempo de transmissão>,<cancelar>,<ID_da_linha>,<intervalo_de_ignorar>};
*unitskillusepos <GID>,<id da habilidade>,<nível da habilidade>,<x>,<y>{,<tempo de transmissão>,<cancelar>,<ID_da_linha>,<intervalo_de_ignorar>};
*unitskillusepos <GID>,"<nome da habilidade>",<nível da habilidade>,<x>,<y>{,<tempo de transmissão>,<cancelar>,<ID_da_linha>,<intervalo_de_ignorar>};

Esta é a substituição dos comandos mais antigos, estes usam os mesmos valores para
GID como os outros comandos da unidade* (Veja 'GID').

O ID da habilidade é o ID da habilidade, o nível da habilidade é o nível da habilidade.
O tempo de conjuração é a quantidade de segundos para adicionar ou remover da habilidade. Use um valor positivo para
adicione um valor negativo para subtrair. Usar 0 ou nenhum valor usará o tempo de conjuração de habilidade padrão.
Para a posição, x e y são fornecidos em UnitSkillUsePos.

<cancel> define se o lançamento pode ser interrompido quando atingido (verdadeiro/falso).
CastCancel de skill_db.yml é o valor padrão de <cancel>.

Se <Line_ID> for definido (número positivo, padrão 0), o monstro dirá a mensagem de 'Line_ID'
em mob_chat_db.yml ao lançar a habilidade.

Se <ignore_range> for true, a unidade ignorará o intervalo de habilidades definido pelo banco de dados. O valor padrão é false.
Atenção! esta configuração não funciona para todas as habilidades.

---------------------------------------

*unitexists <GID>;

Verifica se o ID do jogo fornecido existe. Retorna falso se o objeto não existe ou verdadeiro se
sim, faz.

---------------------------------------

*getunittype <GID>;

Retorna o tipo de objeto do ID do jogo fornecido. Retorna -1 se o GID fornecido não
existem.

Valores de retorno:
	BL_PC - Objeto de personagem
	BL_MOB - Objeto monstro
	BL_PET - Objeto de estimação
	BL_HOM - Objeto homúnculo
	BL_MER - Objeto mercenário
	BL_NPC - Objeto NPC
	BL_ELEM - Objeto elementar

---------------------------------------

*getunitname <GID>;

Obtém o nome da unidade fornecida. Os tipos suportados são monstro, homúnculo, pet e NPC.
Mercenário e Elemental não suportam nomes personalizados.

Retorna "Desconhecido" se a unidade não for encontrada.

---------------------------------------

*setunitname <GID>,"<novo nome>";

Altera o nome da unidade dada para o novo nome dado. Os tipos suportados são monstro,
homúnculo e animal de estimação. Para mudar o nome de um NPC, veja 'setnpcdisplay'. Mercenário e
O Elemental não suporta nomes personalizados.

Mudar um homúnculo ou nome de animal de estimação será permanente.

Retorna "Desconhecido" se a unidade não for encontrada.

---------------------------------------

*setunittitle <GID>,<título>;

Aplique um <title> ao <GID> fornecido.

Nota: Isso só funciona em tipos não-jogadores. Também só funcionará em mobs se battle_config.show_mob_info não estiver habilitado.

---------------------------------------

*getunittitle <GID>;

Retorna o título do <GID> fornecido.

---------------------------------------

*getunitdata <GID>,<nome da matriz>;
*setunitdata <GID>,<parâmetro>,<novo valor>;

Isso é usado para obter e set dados especiais relacionados à unidade.
Com getunitdata, o array fornecido será preenchido com os dados atuais. Em setunitdata
os índices na matriz seriam usados ​​para set esses dados na unidade.

Tanto getunitdata quanto setunitdata retornarão -1 se o GID fornecido não existir.

Nota: Ao ajustar o status de uma unidade (STR, AGI, etc.), os respectivos status da unidade são
      recalculado (HIT, FLEE, etc) automaticamente. Tenha em mente que algumas estatísticas não
	  afetam o status de uma unidade e terão que ser modificados diretamente.

Os parâmetros (índices) para monstros são:
	TAMANHO_UMOB
	NÍVEL_UMOB
	UMOB_HP
	UMOB_MAXHP
	UMOB_MASTERAID
	UMOB_MAPID
	UMOB_X
	UMOB_Y
	VELOCIDADE_UMOB
	MODO_UMOB
	UMOB_AI
	UMOB_SCOPÇÃO
	UMOB_SEX
	CLASSE_UMOB
	PENTEADO_UMOB
	UMOB_COR DE CABELO
	UMOB_CABEÇAINFERIOR
	UMOB_HEADMIDDLE
	UMOB_CABEÇA
	UMOB_COR DA ROUPA
	ESCUDO_UMOB
	ARMA_UMOB
	UMOB_LOOKDIR
	UMOB_CANMOVETICK
	UMOB_STR
	UMOB_AGI
	UMOB_VIT
	UMOB_INT
	UMOB_DEX
	UMOB_LUK
	UMOB_SLAVECPYMSTRMD
	UMOB_DMGIMMUNE
	UMOB_ATKRANGE
	UMOB_ATKMIN
	UMOB_ATKMAX
	UMOB_MATKMIN
	UMOB_MATKMAX
	UMOB_DEF
	UMOB_MDEF
	UMOB_ACERTO
	UMOB_FUGIR
	UMOB_PDODGE
	UMOB_CRIT
	CORRIDA_UMOB
	UMOB_ELETIPO
	UMOB_ELEVÁVEL
	UMOB_AMOÇÃO
	ATRASO_UMOB
	UMOB_DMOÇÃO
	UMOB_ID_ALVO
	UMOB_ROBE
	UMOB_CORPO2
	ID_DO_GRUPO_UMOB
	UMOB_IGNORAR_LIMITE_DE_PILHA_DE_CÉLULAS
	UMOB_RES
	UMOB_MRES
	UMOB_DANO TOMADO

-----

Os parâmetros (índices) para homúnculos são:
	TAMANHO_UHOM
	NÍVEL_UHOM
	UHOM_HP
	UHOM_MAXHP
	UHOM_SP
	UHOM_MAXSP
	UHOM_MASTERCID
	UHOM_MAPID
	UHOM_X
	UHOM_Y
	UHOM_FOME
	UHOM_INTIMIDADE
	UHOM_VELOCIDADE
	UHOM_LOOKDIR
	UHOM_CANMOVETICK
	UHOM_STR
	UHOM_AGI
	UHOM_VIT
	UHOM_INT
	UHOM_DEX
	UHOM_LUK
	UHOM_DMGIMMUNE
	UHOM_ATKRANGE
	UHOM_ATKMIN
	UHOM_ATKMAX
	UHOM_MATKMIN
	UHOM_MATKMAX
	UHOM_DEF
	UHOM_MDEF
	UHOM_ACERTO
	UHOM_FUGIR
	UHOM_PDODGE
	UHOM_CRIT
	UHOM_RAÇA
	UHOM_ELETIPO
	UHOM_ELEVÁVEL
	UHOM_AMOÇÃO
	UHOM_ATRASO
	UHOM_DMOÇÃO
	UHOM_ID_TARGET
	ID_DO_GRUPO_UHOM

-----

Os parâmetros (índices) para animais de estimação são:
	TAMANHO_UPET
	NÍVEL_UPET
	UPET_HP
	UPET_MAXHP
	UPET_MASTERAID
	UPET_MAPID
	UPET_X
	UPET_Y
	UPET_FOME
	UPET_INTIMIDADE
	VELOCIDADE_UPET
	UPET_LOOKDIR
	UPET_CANMOVETICK
	UPET_STR
	UPET_AGI
	UPET_VIT
	UPET_INT
	UPET_DEX
	UPET_LUK
	UPET_DMGIMMUNE
	UPET_ATKRANGE
	UPET_ATKMIN
	UPET_ATKMAX
	UPET_MATKMIN
	UPET_MATKMAX
	UPET_DEF
	UPET_MDEF
	UPET_ACERTO
	UPET_FUGIR
	UPET_PDODGE
	CRITÉRIO_UPET
	CORRIDA_UPET
	UPET_ELETIPO
	UPET_ELEVÁVEL
	UPET_AMOÇÃO
	ATRASO_UPET
	UPET_MOÇÃO
	ID_DO_GRUPO_UPET

-----

Os parâmetros (índices) para mercenários são:
	TAMANHO_UMER
	UMER_HP
	UMER_MAXHP
	UMER_MASTERCID
	UMER_MAPID
	UMER_X
	UMER_Y
	UMER_KILLCOUNT
	UMER_VIDA ÚTIL
	VELOCIDADE_UMER
	UMER_LOOKDIR
	UMER_CANMOVETICK
	UMER_STR
	UMER_AGI
	UMER_VIT
	UMER_INT
	UMER_DEX
	UMER_LUK
	UMER_DMGIMMUNE
	UMER_ATKRANGE
	UMER_ATKMIN
	UMER_ATKMAX
	UMER_MATKMIN
	UMER_MATKMAX
	UMER_DEF
	UMER_MDEF
	UMER_HIT
	UMER_FUGIR
	UMER_PDODGE
	CRITÉRIO_UMER
	UMER_RAÇA
	UMER_ELETYPE
	UMER_ELEVEL
	UMER_AMOÇÃO
	ATRASO_UMER
	UMER_DMOÇÃO
	UMER_ID_TARGET
	ID_DO_GRUPO_UMER

-----

Os parâmetros (índices) para elementais são:
	TAMANHO_UELE
	UELE_HP
	UELE_MAXHP
	UELE_SP
	UELE_MAXSP
	UELE_MASTERCID
	UELE_MAPID
	UELE_X
	UELE_Y
	UELE_VIDA ÚTIL
	MODO_UELE
	UELE_VELOCIDADE
	UELE_LOOKDIR
	UELE_CANMOVETICK
	UELE_STR
	UELE_AGI
	UELE_VIT
	UELE_INT
	UELE_DEX
	UELE_LUK
	UELE_DMGIMMUNE
	UELE_ATKRANGE
	UELE_ATKMIN
	UELE_ATKMAX
	UELE_MATKMIN
	UELE_MATKMAX
	UELE_DEF
	UELE_MDEF
	UELE_HIT
	UELE_FUGIR
	UELE_PDODGE
	UELE_CRIT
	UELE_RAÇA
	UELE_ELETYPE
	UELE_ELEVEL
	UELE_AMOÇÃO
	UELE_ATRASO
	UELE_DMOTION
	UELE_ID_TARGET
	ID_DO_GRUPO_UELE

-----

Os parâmetros (índices) para NPCs são:
	NÍVEL_UNPC
	UNPC_HP
	UNPC_MAXHP
	UNPC_MAPID
	UNPC_X
	UNPC_Y
	UNPC_LOOKDIR
	UNPC_STR
	UNPC_AGI
	UNPC_VIT
	UNPC_INT
	UNPC_DEX
	UNPC_LUK
	UNPC_PLUSALLSTAT
	UNPC_DMGIMMUNE
	UNPC_ATKRANGE
	UNPC_ATKMIN
	UNPC_ATKMAX
	UNPC_MATKMIN
	UNPC_MATKMAX
	UNPC_DEF
	UNPC_MDEF
	UNPC_HIT
	UNPC_FUGIR
	UNPC_PDODGE
	CRIT_UNPC
	CORRIDA_UNPC
	UNPC_ELETYPE
	UNPC_ELEVÁVEL
	UNPC_AMOÇÃO
	ATRASO_UNPC
	UNPC_DMOTION
	UNPC_SEX
	CLASSE_UNPC
	PENTEADO_UNPC
	UNPC_COR DE CABELO
	UNPC_HEADBOTTOM
	UNPC_HEADMIDDLE
	UNPC_HEADTOP
	UNPC_COR_DA_ROUPA
	UNPC_ESCUDO
	ARMA_UNPC
	UNPC_ROBE
	UNPC_CORPO2
	UNPC_MORTOS
	ID_DO_GRUPO_UNPC

*Observações:
		- *_TAMANHO: pequeno (0); médio (1); grande (2)
	    - *_MAPID: refere-se ao índice map_data (de src/map/map.cpp), não ao índice mapindex_db (de src/common/mapindex.cpp)
			-- Para 'setunitdata', o nome do mapa também pode ser passado como um valor válido em vez do ID do mapa
		- *_VELOCIDADE: 20 - 1000
		- *_MODE: veja doc/mob_db_mode_list.txt
		- *_LOOKDIR: norte (0), noroeste (1), oeste (2), etc.
		- *_CANMOVETICK: segundos * 1000 a unidade não poderá se mover
		- *_DMGIMMUNE: a unidade será imune a danos (1) ou receberá danos (0)
		- *_FOME: 0 - 100
		- *_INTIMIDADE: 0 - 1000
		- *_LIFETIME: segundos * 1000 a unidade estará 'viva' por
		- *_AMOTION: veja doc/mob_db.txt
		- *_ADELAY: veja doc/mob_db.txt
		- *_DMOTION: veja doc/mob_db.txt
		- *_BODY2: habilitar (1) a exibição alternativa ou desabilitar (0)
		- *_TARGETID: quando definido como 0, a unidade liberará o alvo e parará de atacar

		- UMOB_AI: nenhum (0); ataque (1); esfera marinha (2); flora (3); zanzou (4); legião (5); faw (6)
		- UMOB_SCOPTION: veja a seção 'Variáveis' no topo deste documento
		- UMOB_SLAVECPYMSTRMD: fazer o escravo copiar o modo do mestre (1), ou não (0)

		- UNPC_PLUSALLSTAT: o mesmo que 'bAllStats'; aumenta/diminui todas as estatísticas em uma determinada quantidade
		- UNPC_DEADSIT: em pé (0), morto (1), sentado (2)

Exemplo:
	// Crie alguns Porings e salve o ID do jogo.
	// - Tenha em mente que quando o comando de script 'monster' é usado,
	// - todos os GIDs dos monstros gerados são armazenados em uma matriz
	// - chamado $@mobid[].
	monster "prontera",149,190,"Poring",1002,10;
	.GID = $@mobid[9]; // Armazene e modifique o 10º Poring gerado para torná-lo mais forte!

	// Salve os dados do grupo forte de Poring na variável .@por_arr[]. (.@por_arr[1] sendo nível, .@por_arr[13] sendo classe, etc.)
	// Com esses dados, podemos ter o NPC exibido ou manipulá-lo como quisermos. Isso não precisa ser executado antes de 'setunitdata'.
	obter dados da unidade .GID,.@por_arr;

	// Defina o HP máximo do Poring para 1000 (o HP atual também será atualizado para 1000).
	setunitdata .GID,UMOB_MAXHP,1000;

---------------------------------------

*geteleminfo <tipo>{,<id_char>};

Obtenha informações do elemental do jogador anexado ou do jogador por char_id.
Outras informações podem ser obtidas pelo comando 'getunitdata'.

Os tipos válidos são:
   ELEMINFO_ID ID elementar (ID exclusivo para o tipo de unidade elemental)
   ELEMINFO_GAMEID ID elementar do jogo
   ELEMINFO_CLASS Classe Elemental (ID definido em elemental_db.yml)

---------------------------------------
\\
6,1.- Fim dos comandos relacionados à unidade
\\
---------------------------------------

*npcskill <id da habilidade>,<nível da habilidade>,<ponto de estatística>,<nível do NPC>;
*npcskill "<nome da habilidade>",<nível da habilidade>,<ponto de atributo>,<nível do NPC>;

Este comando faz com que o objeto NPC anexado lance uma habilidade no objeto anexado
jogador. A habilidade não terá tempo de conjuração ou tempo de recarga. O jogador deve estar
dentro do intervalo de habilidade padrão ou o comando falhará silenciosamente.

O parâmetro "stat point" define temporariamente todas as estatísticas do NPC para o valor fornecido,
e "nível do NPC" é o nível temporário do NPC (usado em algumas habilidades).
Nenhum valor pode ser maior que o nível máximo definido na configuração e irá
não funciona corretamente se o NPC tiver um sprite de mob.

Antes de usar habilidades, os NPCs devem ter estatísticas básicas aplicadas a eles, dependendo do
habilidade sendo usada: UNPC_ATKMIN, UNPC_ATKMAX, UNPC_MATKMIN, UNPC_MATKMAX, UNPC_STR,
UNPC_AGI, UNPC_VIT, UNPC_INT, UNPC_DEX, UNPC_LUK.
Veja 'setunitdata' para mais informações sobre uso.

    // Lança Cura de Nível 10 no jogador anexado, calculado com
    // todas as estatísticas são 99 e nível base 60.
    npcskill "AL_HEAL",10,99,60;

---------------------------------------

*dia;
*noite;

Esses dois comandos alternarão todo o servidor entre o modo diurno e noturno
respectivamente. Se o seu servidor estiver configurado para alternar entre dia e noite por
configuração, ele eventualmente retornará a esse ciclo.

Exemplo:

- script DiaNoite -1,{
OnClock0600:
	dia;
	end;
OnInit:
	// definindo o modo correto na inicialização do servidor
	if (gettime(DT_HOUR)>=6 && gettime(DT_HOUR)<18) end;
OnClock1800:
	noite;
	end;
}

Este script permite emular o ciclo dia/noite como o servidor faz, mas também
permite acionar efeitos adicionais em caso de mudança, como anúncios, presentes, etc.
O ciclo dia/noite definido pela configuração deve ser desabilitado quando este script for usado.

---------------------------------------

*defpattern <número do conjunto>,"<padrão de expressão regular>","<rótulo do evento>";
*activatepset <número do conjunto>;
*deactivatepset <número do conjunto>;
*deletepset <número do conjunto>;

Este conjunto de comandos só está disponível se o servidor for compilado com regular
biblioteca de expressões habilitada. Compilação padrão e a maioria das distribuições binárias
não são, o que provavelmente é ruim, já que estes, embora complexos de usar, são bastante
fascinante.

Eles farão o objeto NPC ouvir o texto falado publicamente pelos jogadores e
compare-o com padrões de expressão regular e, em seguida, acione os rótulos associados
com esses padrões de expressão regular.

Os padrões são organizados em conjuntos, que são referenciados por um número de conjunto. Você pode
tem vários padrões de conjuntos e vários padrões podem estar ativos ao mesmo tempo.
Os números para conjuntos de padrões começam em 1.

'defpattern' associará um determinado padrão de expressão regular a um evento
rótulo. Este evento será acionado sempre que algo que um jogador disser for correspondido
por este padrão de expressão regular, se o padrão estiver ativo no momento.

'activatepset' tornará o conjunto de padrões especificado ativo. Um padrão ativo
habilitará rótulos de disparo definidos com 'defpattern', o que não acontecerá
por padrão.
'deactivatepset' desativará um conjunto de padrões especificado. Dando -1 como um padrão
set número neste caso desativará todos os conjuntos de padrões definidos.

'deletepset' excluirá um conjunto de padrões da memória, para que você possa criar um novo
padrão definido em seu lugar.

Usar expressões regulares é uma grande magia. Mas com essa grande magia vem
poder incomparável de manipulação de texto. Para uma explicação do que é um regular
padrão de expressão é, veja algumas páginas da web:

http://www.regular-expressions.info/
http://www.weitz.de/regex-coach/

Para um exemplo disso em uso, consulte doc/sample/npc_test_pcre.txt

Com isso você poderia, por exemplo, punir automaticamente os jogadores que pedirem
Zeny em locais públicos ou, alternativamente, dar-lhes Zeny automaticamente se
eles querem tanto isso.

---------------------------------------

*pow(<número>,<potência>)

Retorna o resultado do cálculo.

Exemplo:
	.@i = pow(2,3); // .@i será 8

---------------------------------------

*sqrt(<número>)

Retorna a raiz quadrada de um número.

Exemplo:
	.@i = sqrt(25); // .@i será 5

---------------------------------------

*distância(<x0>,<y0>,<x1>,<y1>)

Retorna a distância entre 2 pontos.

Exemplo:
	.@i = distância(100,200,101,202);

---------------------------------------

*min(<número ou matriz>{,<número ou matriz>,...})
*minimum(<número ou matriz>{,<número ou matriz>,...})
*max(<número ou matriz>{,<número ou matriz>,...})
*máximo(<número ou matriz>{,<número ou matriz>,...})

Retorna o menor (ou maior) do conjunto de parâmetros fornecidos.
Esses parâmetros devem ser números ou matrizes numéricas.

Exemplo:
	.@minimum = min( 1, -6, -2, 8, 2 ); // .@minimum será igual a -6
	.@maximum = max( 0, 5, 10, 4 ); // .@maximum será igual a 10
	.@level = min( BaseLevel, 70 ); // .@level será o nível base do personagem, limitado a 70

	setarray .@testarray, 4, 5, 12, 6, 7, 3, 8, 9, 10;

	.@minimum = min( .@testarray ); // .@minimum será igual a 3
	.@maximum = max( .@testarray ); // .@maximum será igual a 12

	.@minimum = min( -6, 1, 2, 3, .@testarray ); // .@minimum será igual a -6
	.@maximum = max( -6, 1, 2, 3, .@testarray ); // .@maximum será igual a 12

---------------------------------------

*cap_value(<número>, <mín.>, <máx.>)

Retorna o número, mas limitado entre <min> e <max>.

Exemplo:
	// limitado entre 0 ~ 100
	.@value = cap_value(10, 0, 100); // .@value será igual a 10
	.@value = cap_value(1000, 0, 100); // .@value será igual a 100
	.@value = cap_value(-10, 3, 100); // .@value será igual a 3

---------------------------------------

*round(<número>,<precisão>);
*ceil(<número>,<precisão>);
*floor(<número>,<precisão>);

Retorna <número> arredondado para múltiplo de <precisão>.

A função `round` arredondará o <número> para cima se sua divisão com <precisão> resultar em um resto
com um valor igual ou maior que a metade de <precisão>. Caso contrário, ele arredonda o <número> para baixo.
`ceil` sempre arredonda o <número> para cima.
`floor` sempre arredonda o <número> para baixo.

---------------------------------------

*md5("<sequência de caracteres>")

Retorna a soma de verificação md5 de um número ou string.

Exemplo:
	mes md5(12345);
	mes md5("12345"); // Ambos exibirão 827ccb0eea8a706c4c34a16891f84e7b
	mes md5("qwerty"); // Irá exibir d8578edf8458ce06fbc5bb76a58c5ca4

---------------------------------------

*query_sql("sua consulta MySQL"{, <variável de matriz>{, <variável de matriz>{, ...}}});
*query_logsql("sua consulta MySQL"{, <variável de matriz>{, <variável de matriz>{, ...}}});

Executa uma consulta SQL. Uma consulta 'select' pode preencher variáveis ​​de array com até 2 bilhões de linhas de
valores e retornará o número de linhas (ou seja, tamanho da matriz) ou -1 em caso de falha.

Observe que 'query_sql' é executado no banco de dados principal, enquanto 'query_logsql' é executado no banco de dados de log.

Exemplo:
	.@nb = query_sql("selecione nome,fama de `char` ORDEM POR fama DESC LIMITE 5", .@nome$, .@fama);
	mes "Hall da Fama: TOP5";
	mes "1." + .@name$[0] + "(" + .@fame[0] + ")"; // maior valor de fama.
	mes "2." + .@name$[1] + "(" + .@fame[1] + ")";
	mes "3." + .@name$[2] + "(" + .@fame[2] + ")";
	mes "4." + .@name$[3] + "(" + .@fame[3] + ")";
	mes "5." + .@name$[4] + "(" + .@fame[4] + ")";

---------------------------------------

*escape_sql(<valor>)

Converte o valor em uma string e escapa caracteres especiais para que seja seguro
use em query_sql(). Retorna a forma escapada do valor fornecido.

Exemplo:
	.@name$ = "Laptop do John";
	.@esc_str$ = escape_sql(.@name$); // String de escape: Laptop de John

---------------------------------------

*setiteminfo(<id do item>,<tipo>,<valor>)
*setiteminfo(<nome do item aegis>,<tipo>,<valor>)

Esta função setá algum valor de um item.
Retorna o novo valor em caso de sucesso, ou -1 em caso de falha (item_id não encontrado ou tipo inválido).

Os tipos válidos são:
	ITEMINFO_BUY (0) - Preço de compra
	ITEMINFO_SELL (1) - Preço de venda
	ITEMINFO_TYPE (2) - Tipo
	ITEMINFO_MAXCHANCE (3) - maxchance (chance máxima de queda deste item, por exemplo, 1 = 0,01%)
	                                  se = 0, então os monstros não o deixam cair (raro ou um item de missão)
	                                  se = 10000, então este item é vendido apenas em lojas de NPC
	ITEMINFO_GENDER (4) - Gênero
	ITEMINFO_LOCATIONS (5) - Localização(ões)
	ITEMINFO_WEIGHT (6) - Peso
	ITEMINFO_ATAQUE (7) - ATAQUE
	ITEMINFO_DEFESA (8) - DEF
	ITEMINFO_RANGE (9) - Intervalo
	ITEMINFO_SLOT (10) - Slot
	ITEMINFO_VIEW (11) - Ver
	ITEMINFO_EQUIPLEVELMIN (12) - equipamento LV
	ITEMINFO_WEAPONLEVEL (13) - arma LV
	ITEMINFO_ALIASNAME (14) - Nome do Alias
	ITEMINFO_EQUIPLEVELMAX (15) - equipamento LV Max
	ITEMINFO_MAGICATTACK (16) - matk se RENEWAL for definido
	ITEMINFO_ARMORLEVEL (19) - armadura LV

Exemplo:
	setiteminfo 7049,ITEMINFO_WEIGHT,9990; // A pedra agora pesa 999,0

---------------------------------------

*setitemscript(<id do item>,<"{ novo script do item }">{,<tipo>});

Defina um novo bônus de script para o Item. Muito útil para eventos de jogo.
Você pode remover o itemscript de um item deixando o argumento itemscript vazio.
Retorna 1 em caso de sucesso ou 0 em caso de falha (item_id não encontrado ou o novo script de item é inválido).
O tipo pode ser usado opcionalmente para indicar qual script set (o padrão é 0):
0 - Roteiro
1 - EquipScript
2 - DesequiparScript

Exemplo:
	setitemscript 2637,"{ if (isequipado(2236) == 0)end; if (getskilllv(26)){habilidade 40,1;}else{habilidade 26,1+isequipado(2636);} }";
	setitemscript 2637,"";

---------------------------------------

*atoi("<string>")
*axtoi("<string>")
*strtol("<string>", base)

Esses comandos são usados ​​para converter strings em números. 'atoi' interpretará
dada string como um número decimal (base 10), enquanto 'axtoi' interpreta strings como
números hexadecimais (base 16). 'strtol' permite que o usuário especifique uma baif (intervalo válido
está entre 2 e 36 inclusive, ou o valor especial 0, que significa autodetecção).

As funções 'atoi' e 'strtol' estão em conformidade com as funções C com os mesmos nomes,
e 'axtoi' é o mesmo que strtol, com uma base de 16. Os resultados são fixados em assinados
Intervalo int de 32 bits (INT_MIN ~ INT_MAX).

Exemplos:

	.@var = atoi("11"); // Define .@var como 11
	.@var = axtoi("FF"); // Define .@var como 255
	mes axtoi("11"); // Exibe 17 (1 = 1, 10 = 16)
	.@var = strtol("11", 10); // Define .@var como 11 (11 base 10)
	.@var = strtol("11", 16); // Define .@var como 17 (11 base 16)
	.@var = strtol("11", 0); // Define .@var como 11 (11 base 10, detectado automaticamente)
	.@var = strtol("0x11", 0); // Define .@var como 17 (11 base 16, detectado automaticamente devido ao prefixo "0x")
	.@var = strtol("011", 0); // Define .@var como 9 (11 base 8, detectado automaticamente devido ao prefixo "0")
	.@var = strtol("11", 2); // Define .@var como 3 (binário 11)

---------------------------------------

*comparar("<string>","<substring>")

Este comando retorna 1 ou 0 quando a substring está na string principal (1) ou não (0).
Este comando não diferencia maiúsculas de minúsculas.

Exemplos:
	//dothis; será executado ('Bloody Murderer' contém 'Blood').
	if (compare("Assassino Sangrento","Sangue"))
		faça isso;

	//dothat; não será executado ('Blood butterfly' não contém 'Bloody').
	if (compare("Borboleta de Sangue","Sangrento"))
		faça isso;

---------------------------------------

*strcmp("<sequência de caracteres>","<sequência de caracteres>")

Este comando compara duas strings e retorna um valor:
   1: sequência 1 > sequência 2
   0: as strings são iguais
  -1: sequência 1 < sequência 2

---------------------------------------

*getstrlen("<string>")

Esta função retornará o comprimento da string fornecida como argumento. É
útil para verificar se alguma coisa inserida pelo jogador excede os limites de comprimento do nome e
outros limites de comprimento e pedindo que eles tentem inserir outra coisa.

---------------------------------------

*charisalpha("<string>",<posição>)

Esta função retornará 1 se o número do caractere Posição na string fornecida
é uma letra, 0 se não for uma letra, mas um dígito ou um espaço.
A primeira letra é a posição 0.

---------------------------------------

*charat(<string>,<índice>)

Retorna char no índice especificado. Se o índice estiver fora do intervalo, retorna string vazia.
A primeira letra de uma string é o índice 0.

Exemplo:
	charat("Esta é uma string", 10); //retorna "s"

---------------------------------------

*setchar(<string>,<caractere>,<índice>)

Retorna a string original com o char no índice especificado definido como
char especificado. Se o índice estiver fora do intervalo, a string original será retornada.
Somente o 1º caractere no parâmetro <char> será usado.

Exemplo:
	setchar("Gato", "B", 0); //retorna "Morcego"

---------------------------------------

*insertchar(<string>,<caractere>,<índice>)

Retorna a string original com o caractere especificado inserido no local especificado
índice. Se o índice estiver fora do intervalo, o char será inserido no final do
string que é mais próximo. Somente o 1º char no parâmetro <char> será usado.

Exemplo:
	insertchar("riso", "s", 0); //retorna "massacre"

---------------------------------------

*delchar(<string>,<índice>)

Retorna a string original com o caractere no índice especificado removido.
Se o índice estiver fora do intervalo, a string original será retornada.

Exemplo:
	delchar("Dieta", 3); //retorna "Morrer"

---------------------------------------

*strtoupper(<string>)
*strtolower(<string>)

Retorna a string especificada em sua forma maiúscula/minúscula.
Todos os caracteres não alfa serão preservados.

Exemplo:
	strtoupper("O pato é azul!!"); //retorna "O PATO É AZUL!!"

---------------------------------------

*charisupper(<string>,<índice>)
*charislower(<string>,<índice>)

Retorna 1 se o caractere no índice especificado da string especificada for
maiúsculas/minúsculas. Caso contrário, 0. Caracteres que não sejam do alfabeto retornarão 0.

Exemplo:
	charisupper("brHades", 1); //retorna 1

---------------------------------------

*substr(<string>,<índice_inicial>,<índice_final>)

Retorna a substring da string especificada, inclusive entre o conjunto
índices. Se os índices estiverem fora do intervalo, ou o índice inicial estiver após o final
índice, uma string vazia será retornada.

Exemplo:
	substr("foobar", 3, 5); //retorna "bar"

---------------------------------------

*explode(<matriz_destino>,<string>,<delimitador>)

Quebra uma string em substrings com base no delimitador especificado. Substrings
será armazenado dentro da matriz de strings especificada. Apenas o 1º caractere do
parâmetro delimitador será usado. Se uma string vazia for passada como delimitador,
a string será colocada no array em sua forma original.

Exemplo:
	explodir(.@my_array$, "Explodir:Teste:1965:vermelho:PIE", ":");
	//.@my_array$ o conteúdo será...
	//.@my_array$[0]: "Explodir"
	//.@my_array$[1]: "Teste"
	//.@my_array$[2]: "1965"
	//.@my_array$[3]: "vermelho"
	//.@my_array$[4]: "TORTA"

---------------------------------------

*implode(<string_array>{,<cola>})

Combina todas as substrings dentro da matriz de strings especificada em uma única string.
Se o parâmetro glue for especificado, ele será inserido entre cada substring.

Exemplo:
	setarray .@my_array$[0], "Isto", "é", "um", "teste";
	implode(.@my_array$, " "); //retorna "Este é um teste"

---------------------------------------

*sprintf(<formato>[,param[,param[,...]]])

Sprintf estilo C. A string resultante é retornada da mesma forma que em PHP. Todos os formatos C
especificadores são suportados, exceto %n. Mais informações: sprintf @ www.cplusplus.com.
O número de parâmetros é limitado apenas pelo mecanismo de script do rA.

Exemplo:
	.@format$ = "O %s contém %d macacos";
	dispbottom(sprintf(.@format$, "zoo", 5)); //imprime "O zoológico contém 5 macacos"
	dispbottom(sprintf(.@format$, "barrel", 82)); //imprime "O barril contém 82 macacos"

---------------------------------------

*sscanf(<string>,<formato>[,parâmetro[,parâmetro[,...]]])

Sscanf estilo C. Todos os especificadores de formato C são suportados.
Mais informações: sscanf @ www.cplusplus.com. O número de parâmetros é limitado apenas
pelo mecanismo de script do rA.

Exemplo:
	sscanf("Este é um teste: 42 foobar", "Este é um teste: %d %s", .@num, .@str$);
	dispbottom(.@num + " " + .@str$); //imprime "42 foobar"

---------------------------------------

*strpos(<palheiro>,<agulha>{,<deslocamento>})

strpos estilo PHP. Encontra uma substring (agulha) dentro de uma string (palheiro).
O parâmetro offset indica o índice da string para iniciar a pesquisa.
Retorna o índice da substring em caso de pesquisa bem-sucedida, caso contrário, -1.
A comparação diferencia maiúsculas de minúsculas.

Exemplo:
	strpos("foobar", "bar", 0); //retorna 3
	strpos("foobarfoo", "foo", 0); //retorna 0
	strpos("foobarfoo", "foo", 1); //retorna 6

---------------------------------------

*replacestr(<entrada>, <pesquisa>, <substituir>{, <caso de uso>{, <contagem>}})

Substitui todas as instâncias de uma string de pesquisa na entrada com a especificada
string de substituição. Por padrão, diferencia maiúsculas de minúsculas, a menos que <usecase> esteja definido
para 0. Se especificado, ele substituirá apenas quantas instâncias forem especificadas
no parâmetro de contagem.

Exemplo:
	replacestr("testando testador", "teste", "traço"); //retorna "dasher dashing"
	replacestr("Burro", "don", "mon", 0); //retorna "macaco"
	replacestr("teste teste teste teste teste", "teste", "yay", 0, 3); //retorna "yay yay yay teste teste"

---------------------------------------

*countstr(<entrada>, <pesquisa>{, <caso de uso>})

Conta todas as instâncias de uma string de pesquisa na entrada. Por padrão, é case
sensível, a menos que <usecase> esteja definido como 0.

Exemplo:
	countstr("teste teste teste Teste", "teste"); //retorna 3
	countstr("bolo Bolo", "Bolo", 0); //retorna 2

---------------------------------------

*preg_match(<padrão de expressão regular>,<string>{,<offset>})

Pesquisa uma string para uma correspondência com a expressão regular fornecida. O
O parâmetro offset indica o índice da string para iniciar a pesquisa.
Retorna deslocamentos para substrings capturadas ou 0 se nenhuma correspondência for encontrada.

Este comando só está disponível se o servidor for compilado com o comando regular
biblioteca de expressões habilitada.

---------------------------------------

*setfont <fonte>;

Este comando define a fonte atual da interface do cliente RO para uma das
fontes armazenadas em data\*.eot usando um ID da fonte. Quando o ID
da fonte usada atualmente é usada, a fonte de interface padrão é usada
de novo.

	0 - Padrão
	1 - RixLoveangel
	2 - Esquilo Rix
	3 - NHCgogo
	4 - RixDiário
	5 - RixMiniHeart
	6 - Calouro Rix
	7 - RixKid
	8 - RixMagic
	9 - RixJJangu

---------------------------------------

*showdigit <valor>{,<tipo>};

Exibe o 'valor' numérico fornecido em uma fonte de relógio digital grande na parte superior
a tela. O parâmetro opcional 'tipo' especifica aspectos visuais
do "relógio" e pode ser um dos seguintes valores:

	0 - Exibe o valor por 5 segundos (padrão).
	1 - Contador incremental (1 tique/segundo).
	2 - Contador decremental (1 tick/segundo). Não para em zero,
		mas transborda.
	3 - Contador decremental (2 ticks/segundo). Apenas dois dígitos, para
		em zero.

Exceto para o tipo 3, o valor é interpretado como segundos e formatado
como tempo em dias, horas, minutos e segundos. Observe que o oficial
O comando script não tem o parâmetro opcional.

	// exibe 23:59:59 por 5 segundos
	mostrardígito 86399;

	// contador que começa em 60 e dura 30 segundos
	mostrardígito 60,3;

---------------------------------------

*setcell "<nome do mapa>",<x1>,<y1>,<x2>,<y2>,<tipo>,<sinalizador>;

Cada célula do mapa tem vários "sinalizadores" que especificam as propriedades daquela célula.
Isso inclui propriedades do terreno (capacidade de caminhar, capacidade de atirar, presença de água),
habilidades (basílica, protetor de terras, ...) e outras (NPC próximo, sem vendas, ...).
Cada um deles pode ser 'on' ou 'off'. Juntos, eles definem o comportamento de uma célula.

Este comando permite que você altere esses sinalizadores para todas as células do mapa no campo especificado.
(x1,y1)-(x2,y2) retângulo. O 'flag' pode ser 0 ou 1 (0:clear flag, 1:set flag).
O 'type' define qual flag modificar. Opções possíveis veja 'src/map/script_constants.hpp'.

Exemplo:

	set célula "arena",0,0,300,300,célula_basílica,1;
	set célula "arena",140,140,160,160,célula_basílica,0;
	set célula "arena",135,135,165,165,célula_percorrível,0;
	set célula "arena",140,140,160,160,célula_percorrível,1;

Isso adicionará um anel improvisado no centro do mapa. O anel será
cercado por uma 'lacuna' de 5 células de largura para evitar interferência externa e
o resto do mapa será marcado como 'basílica', impedindo os observadores de
conjurando quaisquer habilidades ofensivas ou lutando entre si. Note que a parede
não será mostrado nem conhecido do lado do cliente, o que pode causar problemas de movimentação.

Outro exemplo:

OnBarricadeDeploy:
	set célula "schg_cas05",114,51,125,51,célula_percorrível,0;
	end;
OnBarricadeBreak:
	set célula "schg_cas05",114,51,125,51,célula_percorrível,1;
	end;

Isso pode ser parte do script WoE:SE, onde os atacantes não têm permissão
para prosseguir até que todas as barricadas sejam destruídas. Este script colocaria e
remova uma fileira de celas não transitáveis ​​depois dos grupos de barricadas.

---------------------------------------

*checkcell ("<nome do mapa>",<x>,<y>,<tipo>);

Este comando retornará 1 ou 0, dependendo se a célula especificada tem
o sinalizador 'type' definido ou não. Existem vários tipos para verificar, todos imitando
a enumeração cell_chk do servidor. Os tipos podem ser encontrados em 'src/map/script_constants.hpp'.

O significado dos tipos individuais pode ser confuso, então aqui está uma visão geral:
  - cell_chkwall/água/penhasco
    eles verificam diretamente o 'componente do terreno' da célula especificada
  - célula_chkpass/alcance/nopass/noreach
    transitável = não parede e não penhasco, alcançável = transitável em relação ao mod sem empilhamento
  - cell_chknpc/basílica/landprotector/novending/nochat
    eles verificam sinalizadores dinâmicos específicos (seu nome indica o que eles fazem)

Exemplo:
	mes "Escolha um mapa de destino.";
	entrada .@map$;
	mes "Tudo bem, agora me dê as coordenadas.";
	entrada .@x;
	entrada .@y;
	if ( !verificarcélula(.@map$,.@x,.@y,cell_chkpass) ) {
		mes "Não posso te teletransportar para lá, desculpe!";
		close;
	} outro {
		mes "Ok, prepare-se...";
		close2;
		deformar .@map$, .@x, .@y;
		end;
	}

---------------------------------------

*getfreecell "<nome do mapa>",<rX>,<rY>{,<x>,<y>,<intervaloX>,<intervaloY>,<sinalizador>};

Encontra uma célula livre no mapa fornecido e armazena a referência à célula encontrada
em <rX> e <rY>. Passar <x> e <y> com <rangeX> e <rangeY> permite
pesquisando dentro de uma área específica no mapa fornecido. O <flag> é uma máscara de bits
e tem os seguintes valores possíveis:
- 1 = Célula aleatória no mapa ou do intervalo <x>,<y>. (padrão)
- 2 = O alvo deve ser capaz de caminhar até o ladrilho alvo.
- 4 = Não deve haver nenhum jogador ao redor do ladrilho alvo (use a configuração no_spawn_on_player).

Exemplos:
	getfreecell("prontera",.@x,.@y); // Encontre uma célula vazia aleatória em Prontera e armazene-a dentro de .@x e .@y
	getfreecell("prontera",.@x,.@y,150,150,5,5); // Encontre uma célula vazia aleatória em 150,150 (com um intervalo de 5x5) em Prontera e armazene-a dentro de .@x e .@y

---------------------------------------

*setwall "<nome do mapa>",<x>,<y>,<tamanho>,<dir>,<atirável>,"<nome>";
*delwall "<nome>";

Cria uma parede invisível, uma matriz de "setcell" começando em x, y e fazendo um
linha do tamanho dado na direção dada. A diferença com setcell é
esta atualização parte do cliente também para evitar o problema de falha. As instruções são as
o mesmo que as direções dos sprites NPC: 0=norte, 1=noroeste, 2=oeste, etc.

---------------------------------------

*checkwall "<nome>";

Este comando retornará verdadeiro se a parede com o nome fornecido existir, falso caso contrário.

---------------------------------------

*readbook <id do livro>,<página>;

Este comando abrirá um item de livro na página especificada.

---------------------------------------

*roleta_aberta( {char_id} )

Abre a janela da roleta para o personagem atualmente anexado ou o personagem
com o id de personagem fornecido.

---------------------------------------

*naviregisterwarp("<Nome do Link>", "<dest_map>", <dest_x>, <dest_y>)

Útil somente ao usar o map-server-generator. Registra um warp extra deste
npc para o mapa de destino/x/y para os arquivos de cliente gerados.

---------------------------------------

*esconderijo de navegação

Útil somente ao usar o map-server-generator. Oculta este npc e todos os links de
este npc na geração de navegação.

---------------------------------------

========================
|7.- Comandos de instância.|
========================
---------------------------------------

*instance_create("<nome da instância>"{,<modo da instância>{,<id do proprietário>}});

Cria uma instância para o <id do proprietário> de <modo>. O nome da instância, junto com
todos os outros dados de instância são lidos de 'db/(pre-)re/instance_db.yml'. Após o sucesso,
o comando gera um ID de instância exclusivo, duplica todos os mapas e NPCs listados,
define o tempo de atividade e aciona o rótulo "OnInstanceInit" em todos os NPCs dentro
a instância.

Opções do Modo de Instância:
IM_NONE: Não vinculado a ninguém.
IM_CHAR: Anexado a um único caractere.
IM_PARTY: Anexado a uma parte (modo de instância padrão).
IM_GUILD: Anexado a uma guilda.
IM_CLAN: Anexado a um clã.

O comando retorna o ID da instância em caso de sucesso e estes valores em caso de falha:
-1: Tipo inválido.
-2: Personagem/Grupo/Guilda/Clã não encontrado.
-3: A instância já existe.
-4: Nenhuma instância livre (MAX_INSTANCE excedido).

---------------------------------------

*instance_destroy {<id da instância>};

Destrói a instância com o ID <instance id>. Se nenhum ID for especificado, a instância
o script está anexado é usado. Se isso falhar, o script será interrompido.
Isso também acionará o rótulo "OnInstanceDestroy" em todos os NPCs dentro da instância.

---------------------------------------

*instance_enter("<nome da instância>",{<x>,<y>,<char_id>,<id da instância>});

Transmite o player anexado para o <id da instância> especificado. Se nenhum ID for especificado,
a instância IM_PARTY à qual o jogador que faz a chamada está anexado é usada.

O mapa e as coordenadas estão localizados em 'db/(pre-)re/instance_db.yml'.

O comando retorna IE_OK em caso de sucesso e estes valores em caso de falha:
IE_NOMEMBER: Grupo/Guilda/Clã não encontrado (para modos grupo/guilda/clã).
IE_NOINSTANCE: Personagem/Grupo/Guilda/Clã não tem uma instância.
IE_OTHER: Outros erros (nome de instância inválido, instância não corresponde ao personagem/grupo/guilda/clã).

Coloque -1 para x e y se quiser teleportar o jogador com coordenadas de entrada padrão.

---------------------------------------

*instance_npcname("<nome do npc>"{,<id da instância>})

Retorna o nome exclusivo do script instanciado. Se nenhuma ID for especificada,
a instância à qual o script está anexado é usada. Se isso falhar, o script
irá parar.

---------------------------------------

*instance_mapname("<nome do mapa>"{,<id da instância>})

Retorna o nome exclusivo do mapa instanciado. Se nenhuma ID de instância for especificada,
a instância à qual o script está anexado é usada. Se isso falhar, o comando
retorna uma string vazia.

---------------------------------------

*instance_id({<modo de instância>})

Retorna o ID de instância exclusivo do modo fornecido.

Por padrão (nenhum parâmetro fornecido), o comando retorna o ID da instância do NPC anexado.
Se <modo de instância> for fornecido, o ID da instância do player atualmente conectado será retornado.
Se isso falhar, a função retornará 0.

Observe que o comando sempre requer o parâmetro <modo de instância> para obter o ID da instância de um jogador anexado!

Opções do Modo de Instância:
IM_CHAR: Anexado ao personagem.
IM_PARTY: Anexado ao grupo do personagem.
IM_GUILD: Anexado à guilda do personagem.
IM_CLAN: Anexado ao clã do personagem.

Exemplos:
	// Exemplo com um player anexado:
	npctalk "O ID da instância atual (modo party) do jogador anexado é: " + instance_id(IM_PARTY);

	// Exemplo com um NPC anexado em um mapa de instância:
	npctalk "O ID da instância atual do NPC anexado é: " + instance_id();

---------------------------------------

*instance_warpall "<nome do mapa>",<x>,<y>{,<id da instância>,{<flag>}};

Teletransporta todos os jogadores em <id da instância> para <nome do mapa> nas coordenadas fornecidas.
Se nenhuma ID for especificada, a instância IM_PARTY do player que a invoca será anexada
para é usado. Se isso falhar, o script será interrompido.

<flag> bitmask permite adicionar restrições.

Valores disponíveis para a máscara de bits <flag>:
IWA_NONE Sem restrição. (padrão)
IWA_NOTDEAD Se jogadores mortos são teletransportados ou não

---------------------------------------

*instance_announce <id da instância>,"<texto>",<bandeira>{,<cor da fonte>{,<tipo da fonte>{,<tamanho da fonte>{,<alinhamento da fonte>{,<fonteY>}}}}};

Transmite uma mensagem a todos os jogadores no <id da instância> atualmente residindo em
um mapa de instância. Se 0 for especificado para <id da instância>, a instância do script
está anexado a é usado.

Para detalhes sobre os outros parâmetros, consulte 'anunciar'.

---------------------------------------

*instance_check_party(<id da parte>{,<quantidade>{,<min>{,<máx>}}})

Esta função verifica se uma parte atende a determinados requisitos, retornando 1 se todos
condições forem atendidas e 0 caso contrário. Ele só verificará caracteres online.
O comando retorna 0 se o ID da parte não existir.

quantidade - número de membros do grupo online (o padrão é 1).
min - nível mínimo de todos os personagens do grupo (o padrão é 1).
max - nível máximo de todos os personagens no grupo (o padrão é o nível máximo na configuração).

Exemplo:

if (instance_check_party(getcharid(1),2,2,149)) {
	mes "Seu grupo atende aos requisitos do Memorial Dungeon.",
	mes "Todos os membros online estão entre os níveis 1-150 e pelo menos dois estão online.";
	close;
} outro {
	mes "Desculpe, sua festa não atende aos requisitos.";
	close;
}

---------------------------------------

*instance_check_guild(<id da guilda>{,<quantidade>{,<min>{,<máx>}}})

Esta função verifica se uma guilda atende a certos requisitos, retornando 1 se todos
condições forem atendidas e 0 caso contrário. Ele só verificará caracteres online.

quantidade - número de membros da guilda online (o padrão é 1).
min - nível mínimo de todos os personagens da guilda (o padrão é 1).
max - nível máximo de todos os personagens da guilda (o padrão é o nível máximo na conf).

Exemplo:

if (instance_check_guild(getcharid(2),2,2,149)) {
	mes "Sua guilda atende aos requisitos do Memorial Dungeon.",
	mes "Todos os membros online estão entre os níveis 1-150 e pelo menos dois estão online.";
	close;
} outro {
	mes "Desculpe, sua guilda não atende aos requisitos.";
	close;
}

---------------------------------------

*instance_check_clan(<id do clã>{,<quantidade>{,<min>{,<max>}}})

Esta função verifica se um clã atende a certos requisitos, retornando 1 se todos
condições forem atendidas e 0 caso contrário. Ele só verificará caracteres online.

quantidade - número de membros do clã online (o padrão é 1).
min - nível mínimo de todos os personagens do clã (o padrão é 1).
max - nível máximo de todos os personagens do clã (o padrão é o nível máximo na configuração).

Exemplo:

if (instance_check_clan(getcharid(5),2,2,149)) {
	mes "Seu clã atende aos requisitos do Memorial Dungeon.",
	mes "Todos os membros online estão entre os níveis 1-150 e pelo menos dois estão online.";
	close;
} outro {
	mes "Desculpe, seu clã não atende aos requisitos.";
	close;
}

---------------------------------------

*instance_info("<nome da instância>",<tipo de informação>{,<índice do mapa do banco de dados da instância>});

Retorna o <tipo de informação> especificado do <nome da instância> fornecido do banco de dados da instância.
Se o <nome da instância> for desconhecido ou um <tipo de informação> inválido for fornecido, -1 será retornado.

Tipos de informação válidos:
IIT_ID: ID do banco de dados da instância como inteiro.
IIT_TIME_LIMIT: Tempo de vida total do banco de dados da instância como inteiro.
IIT_IDLE_TIMEOUT: Tempo limite do banco de dados da instância como inteiro.
IIT_ENTER_MAP: Mapa de entrada do banco de dados de instância como string.
IIT_ENTER_X: O banco de dados de instância insere o local X como inteiro.
IIT_ENTER_Y: O banco de dados de instância insere o local Y como inteiro.
IIT_MAPCOUNT: Mapas totais do banco de dados de instância como inteiro.
IIT_MAP: Nome do mapa do banco de dados de instância do <índice do mapa do banco de dados de instância> fornecido como string.
          Se o índice for inválido, uma string vazia será retornada.

Exemplo:

.@name$ = "Torre sem fim";
mes .@name$ + " será destruído se ninguém estiver na instância por " + instance_info(.@name$,IIT_IDLETIMEOUT) + " segundos.";
// A Torre Infinita será destruída se ninguém estiver na instância por 300 segundos.

---------------------------------------

*instance_live_info(<tipo de informação>{,<id da instância>});

Retorna o <tipo de informação> especificado da instância anexada ao npc ou, se
um ID de instância é especificado para essa instância.

<Tipo de informação> válido:
ILI_NAME - Nome da instância
			  Retorne o nome da instância ou "" se isso falhar.
ILI_MODE - Modo de Instância
			  Retorne IM_NONE, IM_CHAR, IM_PARTY, IM_GUILD, IM_CLAN ou -1 se isso falhar.
ILI_OWNER - ID do proprietário
			  Retorna um ID de acordo com o modo de instância da instância anexada/especificada ou -1 se isso falhar.
			  Quando o modo de instância é IM_NONE, ILI_OWNER retornará o ID do npc que criou a instância,
			  IM_CHAR - o ID do char do proprietário
			  IM_PARTY - o ID da festa
			  IM_GUILD - o ID da guilda
			  IM_CLAN - o ID do clã

Exemplos:
	// Retorna o nome da instância anexada ao npc.
	.@instance_name$ = instance_live_info(ILI_NAME);

	// Retorna o ID do proprietário da guilda do ID de instância fornecido.
	.@owner = instance_live_info(ILI_OWNER, instance_id(IM_GUILD));

---------------------------------------

*instance_list(<"nome do mapa">{,<modo de instância>});

Cria a matriz '.@instance_list' com possíveis IDs de instância para o <nome do mapa> fornecido e <modo> opcional.
Retorna o tamanho do array '.@instance_list'.

Opções de modo de instância: IM_NONE, IM_CHAR, IM_PARTY, IM_GUILD ou IM_CLAN
Se o modo de instância não for fornecido, ele retornará todos os IDs de instância para esse mapa.

Exemplos:
	// Este exemplo pressupõe que há várias instâncias no mapa de Prontera.
	.@size = instance_list("prontera");
	para ( .@i = 0; .@i < .@tamanho; ++.@i )
		mes instance_mapname("prontera", .@instance_list[.@i]);
	//a saída seria uma lista de todas as cópias do prontera que estão ativas no servidor.

---------------------------------------

*getinstancevar(<variável>,<id da instância>);

Retorna uma referência a uma variável de instância (prefixo ') do ID de instância específico.
Isso só pode ser usado para obter ' variáveis.

Exemplos:
	// Isso setá a variável .@s para o valor da variável 'var' do ID de instância específico.
	set .@s, getinstancevar('var, instance_id(IM_PARTY));

	// Isso setá a variável 'var' do ID de instância específico como 1.
	set getinstancevar('var, instance_id(IM_GUILD)), 1;

---------------------------------------

*setinstancevar(<variável>,<valor>,<id da instância>);

Este comando setá uma variável de instância para o valor resultante da expressão.
Veja o comando 'set' para mais informações.

Retorna a referência da variável.

Exemplos:
	// Isso setá a variável 'var' do ID de instância específico como 9.
	setinstancevar('var, 9, instance_id(IM_GUILD));

---------------------------------------

=========================
|8.- Comandos do Quest Log.|
=========================
---------------------------------------

*questinfo <Ícone>{,<Cor da marca do mapa>{,"<condição>"}};

Este comando deve ser usado somente em rótulos OnInit/OnInstanceInit.
Mostre uma emoção em cima de um NPC e, opcionalmente, uma marca colorida no minimapa, como "viewpoint" ou "viewpointmap".
Quando um usuário realiza alguma ação, cada NPC é verificado em busca de informações de missão que foram definidas no mapa.
Se questinfo estiver presente, ele verificará se o jogador atende à condição.
Se ele/ela fizer isso ou nenhuma condição tiver sido definida, a bolha aparecerá.

Disponível <Ícone>:

Nenhum ícone: QTYPE_NONE
! Ícone da missão: QTYPE_QUEST
? Ícone da missão: QTYPE_QUEST2
! Ícone de trabalho: QTYPE_JOB
? Ícone de trabalho: QTYPE_JOB2
! Ícone do evento: QTYPE_EVENT
? Ícone do evento: QTYPE_EVENT2
Warg: QTYPE_WARG (somente para packetver < 20170315)
Warg Face: QTYPE_WARG2 (Somente para packetver >= 20120410 e < 20170315)
Clique em mim: QTYPE_CLICKME (somente para packetver >= 20170315)
Missão diária: QTYPE_DAILYQUEST (somente para packetver >= 20170315)
! Ícone do evento: QTYPE_EVENT3 (somente para packetver >= 20170315)
Job Quest: QTYPE_JOBQUEST (Somente para packetver >= 20170315)
Jumping Poring: QTYPE_JUMPING_PORING (Somente para packetver >= 20170315)

<Map Mark Color>, quando usado, cria uma marca no minimapa do usuário na posição do NPC,
os valores de cores disponíveis são:

QMARK_NONE - Nenhum marcador (padrão)
QMARK_YELLOW - Marcador Amarelo
QMARK_GREEN - Marcador verde
QMARK_PURPLE - Marcador roxo

<condição> pode ser qualquer expressão semelhante à <condição> no comando 'if'.

Lista de ações do jogador para acionar a condição questinfo:
- Item adicionado/removido do inventário do jogador
- Mudança de nível de base/trabalho
- Mudança de emprego
- Missão dada/apagada/concluída
- Objetivo da missão atualizado (o personagem matou um monstro alvo da missão)
- Deformar


Exemplo:
izlude,100,100,4 script Teste 844,{
	mes "[Teste]";
	mes "Olá Mundo.";
	close;

OnInit:
	// Exibe um ícone se o jogador completou a missão de caça fornecida e sua variável 'unknown_var' estiver acima de 0
	questinfo QTYPE_QUEST, QMARK_AMARELO, "checkquest(1001,HUNTING) == 2 && unknown_var > 0";

	//.. ou exibir um ícone se o jogador não iniciou a missão dada e ele/ela tem uma poção vermelha no inventário
	questinfo QTYPE_QUEST, QMARK_AMARELO, "!isbegin_quest(1001) && countitem(501) == 1";
	end;
}

---------------------------------------

*questinfo_refresh {<id_char>};

Este comando atualiza cada bolha de missão que foi definida no mapa de acordo
para a condição questinfo para o jogador anexado/dado.

---------------------------------------

*setquest <ID>{,<id_char>};

Coloque a missão <ID> no registro de missões do usuário, cujo estado é "ativo".

Se *questinfo for definido e o mesmo ID for especificado aqui, o ícone será limpo quando a missão for definida.

---------------------------------------

*completarquest <ID>{,<id_char>};

Altere o estado da missão <ID> fornecida para "concluída" e remova-a do registro de missões do usuário.

---------------------------------------

*erasequest <ID>{,<id_char>};

Remove a missão do <ID> fornecido do registro de missões do usuário.

---------------------------------------

*changequest <ID>,<ID2>{,<id_char>};

Remove a missão do <ID> fornecido do registro de missões do usuário.
Adicione a missão <ID2> ao registro de missões e o estado será "ativo".

---------------------------------------

*checkquest(<ID>{,HORA DE BRINCAR|CAÇA{,<char_id>}})

Se nenhum argumento adicional for fornecido, retorne o estado da missão:
	-1 = Missão não iniciada (não está no registro de missões)
	0 = A missão foi dada, mas o estado é "inativo"
	1 = A missão foi dada e o estado é "ativo"
	2 = Missão concluída

Se o parâmetro "PLAYTIME" for fornecido:
	-1 = Missão não iniciada (não está no registro de missões)
	0 = o limite de tempo ainda não foi atingido
	1 = o limite de tempo não foi atingido, mas a missão está marcada como concluída
	2 = o limite de tempo foi atingido

Se o parâmetro "HUNTING" for fornecido:
	-1 = Missão não iniciada (não está no registro de missões)
	0 = você não matou todos os monstros alvo e o limite de tempo não foi atingido.
	1 = você não matou todos os monstros alvo, mas o limite de tempo foi atingido.
	2 = você matou todos os monstros alvo

---------------------------------------

*isbegin_quest(<ID>{,<id_char>})

Retorna o estado da missão:
	0 = Missão não iniciada (não está no registro de missão)
	1 = A missão foi dada (o estado é "inativo" ou "ativo")
	2 = Missão concluída

---------------------------------------

*showevent <ícone>{,<cor da marca>{,<id_do_caractere>}}

Mostre uma emoção em cima de um NPC e, opcionalmente,
uma marca colorida no minimapa como "viewpoint" ou "viewpointmap".
Isso é usado para indicar que um NPC tem uma missão ou um evento para
um certo jogador.

Ícones disponíveis:

Remover Ícone: QTYPE_NONE
! Ícone da missão: QTYPE_QUEST
? Ícone da missão: QTYPE_QUEST2
! Ícone de trabalho: QTYPE_JOB
? Ícone de trabalho: QTYPE_JOB2
! Ícone do evento: QTYPE_EVENT
? Ícone do evento: QTYPE_EVENT2
Warg: QTYPE_WARG
Warg Face: QTYPE_WARG2 (Somente para packetver >= 20120410)

Cor da marca:
QMARK_NONE - Nenhum marcador (padrão)
QMARK_YELLOW - Marcador Amarelo
QMARK_GREEN - Marcador verde
QMARK_PURPLE - Marcador roxo

---------------------------------------

*open_quest_ui {<ID da missão>,{<ID do caractere>}};

Abre a interface de missão para o jogador vinculado ou para o ID de personagem fornecido.
Use 0 como ID da missão para abrir a UI da missão principal. Se o ID da missão não for 0, a UI da missão será aberta para a missão fornecida. Se os dados da missão não forem preenchidos no LUB do cliente, uma mensagem será exibida dizendo que a missão não existe.

Este comando requer a versão do pacote 2015-12-02 ou mais recente.

---------------------------------------

============================
|9.- Comandos do campo de batalha.|
============================
---------------------------------------

*waitingroom2bg_single(<grupo de batalha>,{"<nome do mapa>",<x>,<y>{,"<nome do npc>"}});

Adiciona o primeiro jogador em espera da sala de bate-papo do NPC fornecido a um grupo de campo de batalha existente.
O jogador também será teletransportado para o ponto de spawn padrão do grupo de batalha ou para as coordenadas especificadas
<x> e <y> no <mapa> fornecido.
Observação: o mapa precisa do mapflag MF_BATTLEGROUND, caso contrário o jogador será removido do time do Campo de Batalha.

---------------------------------------

*waitingroom2bg("<nome do mapa>",<x>,<y>,{"<Evento ao sair>","<Evento ao morrer>"{,"<Nome do NPC>"}});

<nome do mapa>,<x>,<y> referem-se a onde fica a base de "respawn", onde o grupo de jogadores irá reaparecer quando morrer.
<On Quit Event> refere-se a um rótulo de NPC que é anexado ao personagem e é executado quando ele faz login novamente. (Opcional)
<On Death Event> refere-se a um rótulo de NPC que é anexado ao personagem e é executado quando ele morre. (Opcional)

Se "-" for fornecido para <nome do mapa>, o jogador não reaparecerá automaticamente após o atraso de 1 segundo.
Isso permite uma melhor manipulação de <On Death Event>. O jogador terá que ser teletransportado para o local desejado
no final de <On Death Event>.

Ao contrário do comando anterior, o último anexará um GRUPO em uma sala de espera ao campo de batalha e
define a matriz $@arenamembers[0] onde 0 contém os IDs do primeiro grupo e 1 contém os IDs do segundo.

Se o parâmetro opcional Nome do NPC for omitido, a sala de espera do NPC atual será usada.

Exemplo:
	// O Grupo de Batalha será chamado de $@KvM01BG_id1 e, quando morrer, reaparecerá em bat_c01,52,129.
	set $@KvM01BG_id1, waitingroom2bg("bat_c01",52,129,"KvM01_BG::OnGuillaumeQuit","KvM01_BG::OnGuillaumeDie");
	end;

---------------------------------------

*bg_create("<nome do mapa>",<x>,<y>{,"<Evento ao sair>","<Evento ao morrer>"});

Cria uma instância do grupo de batalha do campo de batalha que pode ser usada com outros comandos do campo de batalha.

<nome do mapa>,<x>,<y> referem-se a onde fica a base de "respawn", onde o grupo de jogadores irá reaparecer quando morrer.
<On Quit Event> refere-se a um rótulo de NPC que é anexado ao personagem e é executado quando ele faz login novamente. (Opcional)
<On Death Event> refere-se a um rótulo de NPC que é anexado ao personagem e é executado quando ele morre. (Opcional)

Se "-" for fornecido para <nome do mapa>, o jogador não reaparecerá automaticamente após o atraso de 1 segundo.
Isso permite uma melhor manipulação de <On Death Event>. O jogador terá que ser teletransportado para o local desejado
no final de <On Death Event>.

Retorna o ID do grupo de batalha em caso de sucesso. Retorna 0 em caso de falha.

---------------------------------------

*bg_join(<grupo de batalha>,{"<nome do mapa>",{<x>,<y>{,<id do caractere>}});

Adiciona um jogador anexado ou <char id> se especificado para um grupo de campo de batalha existente. O jogador também será teletransportado
para o ponto de surgimento padrão do grupo de batalha ou para as coordenadas especificadas <x> e <y> no <mapa> fornecido.
Observação: o mapa precisa do mapflag MF_BATTLEGROUND, caso contrário o jogador será removido do time do Campo de Batalha.

Retorna true em caso de sucesso. Retorna false em caso de falha.

---------------------------------------

*bg_team_setxy <ID do Grupo de Batalha>,<x>,<y>;

Atualiza o ponto de respawn do Grupo de Batalha fornecido para x,y no mesmo mapa. <ID do Grupo de Batalha> pode ser recuperado
usando getcharid(4).

Exemplo:
	bg_team_setxy getcharid(4),56,212;
	mapannounce "bat_a01", "O grupo [1] assumiu a oficina e agora irá reaparecer lá.",bc_map,"0xFFCE00";
	end;

---------------------------------------

*bg_reserve("<nome_do_mapa_do_campo_de_batalha>"{,<finalizado>});

Reserva um mapa de campo de batalha para o sistema de interface de usuário do campo de batalha. Quando um mapa é reservado, ele impede outro semelhante
a fila seja criada e permitirá que os jogadores participem de um evento ativo do Battlegrounds.

Se <ended> for verdadeiro, então o campo de batalha é marcado como terminado para evitar que novos jogadores entrem. Este estado é destinado
para o período em que os jogadores podem obter seus emblemas.

---------------------------------------

*bg_unbook("<nome_do_mapa_do_campo_de_batalha>");

Remove um mapa Battleground para o Battleground UI System. Quando um mapa é desmarcado, ele permite que uma fila seja criada.

---------------------------------------

*bg_desert({<id_char>});

O mesmo que 'bg_leave', mas dá ao jogador o status de desertor para que ele não possa entrar em outra fila naquele momento
definido em battleground_db (10 minutos por padrão).

Com o Sistema de Fila do Campo de Batalha, ele também levará o jogador à posição anterior quando ele entrou ou
para seu ponto de salvamento se o mapa tivesse MF_NOSAVE.

---------------------------------------

*bg_warp <Grupo de Batalha>,"<nome do mapa>",<x>,<y>;

Semelhante ao comando 'warp'.
Coloca todos os membros do <Grupo de Batalha> no mapa e coordenadas especificados.

Exemplo:
	//coloque o grupo de batalha um para Tierra Gorge na posição inicial.
	bg_warp $@TierraBG1_id1,"bat_a01",352,342;
	end;

---------------------------------------

*bg_monster <Grupo de Batalha>,"<nome do mapa>",<x>,<y>,"<nome a ser exibido>",<id do mob>,"<rótulo do evento>";
*bg_monster(<Grupo de Batalha>,"<nome do mapa>",<x>,<y>,"<nome a ser exibido>",<id do mob>,"<rótulo do evento>");

Semelhante ao comando "monstro".
Gera um monstro com lealdade ao Grupo de Batalha fornecido.
Não permite a invocação de múltiplos monstros.
Os monstros são semelhantes aos da Guerra do Emperium, pois o Grupo de Batalha especificado é considerado amigável.

Exemplo:
	// Pode ser usado de duas maneiras diferentes.
	bg_monster $@TierraBG1_id2,"bat_a01",167,50,"Depósito de alimentos",1910,"Depósito de alimentos#1::OnMyMobDead";
	end;

	// Alternativamente, você pode set um ID para o monstro usando "set".
	// Isso se torna útil quando usado com o comando abaixo.
	set $@Guardian_3, bg_monster($@TierraBG1_id2,"bat_a01",268,204,"Guardian",1949,"NPCNAME::OnMyMobDead");
	end;

---------------------------------------

*bg_monster_set_team <GID>,<Grupo de Batalha>;

Este comando mudará a lealdade de um monstro em um campo de batalha.
O GID pode ser definido ao gerar o monstro através do comando 'bg_monster'.

Exemplo:

	end;

Ao habilitar:
	mapannounce "Um guardião foi convocado para o Grupo de Batalha 2!",bc_map,"0xFFCE00";
	set $@Guardian, bg_monster($@BG_2,"bat_a01",268,204,"Guardian",1949,"NPCNAME::OnMyMobDead");
	initnpctimer;
	end;

OnTimer1000:
	parar o temporizador;
	mapannounce "Erm, desculpe por isso! Este monstro era para o Grupo de Batalha 1.",bc_map,"0xFFCE00";
	bg_monster_set_team $@Guardian, $@BG_1;
	end;

---------------------------------------

*bg_leave {<id_caractere>};

Remove o jogador anexado do seu Grupo de Batalha.

Com o Sistema de Fila do Campo de Batalha, ele também levará o jogador à posição anterior quando ele entrou ou
para seu ponto de salvamento se o mapa tivesse MF_NOSAVE.

---------------------------------------

*bg_destroy <Grupo de Bateria>;

Destrói o Grupo de Batalha criado para aquele campo de batalha.

---------------------------------------

*areapercentheal "<nome do mapa>",<x1>,<y1>,<x2>,<y2>,<hp>,<sp>;

Restaura uma porcentagem do HP/SP máximo dos jogadores dentro de uma área definida.
Isso é usado principalmente em scripts de campo de batalha, mas não se limita a eles.

Exemplo:
	áreapercentualheal "bat_a01",52,208,61,217,100,100;
	end;

---------------------------------------

*bg_get_data(<Grupo de Batalha>,<tipo>);

Recupera dados relacionados ao Battle Group fornecido. O tipo pode ser um dos seguintes:

	0 - Quantidade de jogadores que atualmente pertencem ao grupo.
	1 - Armazene o GID dos jogadores em <Grupo de Batalha> em um array global temporário $@arenamembers,
		armazena e também retorna a quantidade de jogadores atualmente pertencentes ao grupo em $@arenamemberscount.

---------------------------------------

*bg_getareusers(<Grupo de Batalha>,"<nome do mapa>",<x0>,<y0>,<x1>,<y1>);

Recupera a quantidade de jogadores pertencentes ao Grupo de Batalha fornecido no dado
mapa dentro da área retangular especificada.

---------------------------------------

*bg_updatescore "<nome do mapa>",<Pontuação Guillaume>,<Pontuação Croix>;

Este comando forçará a atualização do placar exibido.
Só pode ser usado quando o mapa é definido como um Campo de Batalha Tipo 2:
mapflag <nome do mapa> campo de batalha 2

---------------------------------------

*bg_info("<nome do campo de batalha>", <tipo>);

Recupera dados relacionados a <nome do campo de batalha> fornecido do banco de dados. Requer feature.bgqueue
para ser habilitado. <Tipo> pode ser um dos seguintes:

	BG_INFO_ID: ID do campo de batalha.
	BG_INFO_REQUIRED_PLAYERS: Jogadores necessários para iniciar um campo de batalha (por lado).
	BG_INFO_MAX_PLAYERS: Número máximo de jogadores permitidos em um campo de batalha.
	BG_INFO_MIN_LEVEL: Nível mínimo permitido para entrar em um campo de batalha.
	BG_INFO_MAX_LEVEL: Nível máximo permitido para entrar em um campo de batalha.
	BG_INFO_MAPS: Número de mapas em um campo de batalha. Armazena um array de nomes de mapas em @bgmaps[] e uma contagem em @bgmapscount.
	BG_INFO_DESERTER_TIME: Quantidade de tempo em segundos que um jogador é marcado como desertor.

---------------------------------------

====================
|10.- Comandos para animais de estimação.|
====================
---------------------------------------

*bpet;
*birthpet;

Este comando abre uma janela de incubação de animais de estimação no cliente conectado ao
invocando personagem. É usado no script de item para incubadoras de animais de estimação e irá
deixe o jogador chocar um ovo próprio. Se o personagem não tiver ovos, ele apenas
abrir uma janela vazia da incubadora.
Isso ainda pode ser usado fora dos scripts de itens.

---------------------------------------

*pet {<item_id>{,flag}};
*catchpet {<item_id>{,flag}};

Este comando é usado em todos os scripts de itens para domesticar itens.
Executar este comando fará com que o cursor de captura de animal de estimação apareça no cliente do personagem invocador
e o jogador pode então tentar capturar um monstro.
Se o ID do item não for especificado, o comando usará o ID do item do script do item invocado.
Também funcionará fora de um script de item, se o ID do item for fornecido.
As seguintes constantes podem ser usadas como parâmetro <flag>:
	PET_CATCH_NORMAL: Tentará capturar o monstro alvo enquanto ele estiver no banco de dados de animais de estimação e
o item de domesticação corresponde ao item de domesticação necessário no banco de dados de animais de estimação.Este é o padrão se <flag> não for especificado.
	PET_CATCH_UNIVERSAL_NO_BOSS: Tentará capturar o monstro alvo enquanto ele estiver no banco de dados de animais de estimação e não possui o modo monstro MD_STATUS_IMMUNE.
	PET_CATCH_UNIVERSAL_ALL: Tentará capturar o monstro alvo enquanto ele estiver no banco de dados de animais de estimação.

Veja 'doc/mob_db_mode_list.txt' para mais informações sobre os modos monstro.

Uma lista completa de IDs de animais de estimação pode ser encontrada em 'db/(pre-)re/pet_db.yml'.

---------------------------------------

*makepet <id do animal de estimação>;

Este comando criará um ovo de estimação e o colocará no personagem que o invoca.
inventário. O tipo de animal de estimação é especificado pelos números de identificação do animal de estimação listados em
'db/(pre-)re/pet_db.yml'. O ovo é criado exatamente como se o personagem tivesse acabado de
pegou um animal de estimação da maneira normal.

	// Isso fará com que você tenha um poring:
	fazerpet 1002;

Observe que você absolutamente tem que criar ovos de estimação com este comando. Se você tentar
para dar um ovo de estimação com 'getitem', os dados do animal de estimação não serão criados pelo char
servidor e o ovo desaparecerá quando alguém tentar chocá-lo.

---------------------------------------

*getpetinfo(<tipo>{,<id_char>})

Esta função retornará informações do animal de estimação para o animal de estimação do personagem invocador
atualmente tem ativo. Os tipos válidos são:

PETINFO_ID - ID exclusivo do animal de estimação
PETINFO_CLASS - Número da classe do animal de estimação conforme 'db/(pre-)re/pet_db.yml' - informará que tipo de animal de estimação é.
PETINFO_NAME - Nome do animal de estimação. Retornará "null" se não houver animal de estimação.
PETINFO_INTIMATE - Nível de aceitação de animais de estimação (pontuação de intimidade). 1000 é lealdade total.
PETINFO_HUNGRY - Nível de fome do animal de estimação. 100 é fome total.
PETINFO_RENAMED - Sinalizador de renomeação de animal de estimação. 0 significa que este animal de estimação ainda não foi nomeado.
PETINFO_LEVEL - Nível do animal de estimação
PETINFO_BLOCKID - ID do jogo do animal de estimação
PETINFO_EGGID - ID do item ovo do animal de estimação
PETINFO_FOODID - ID do item de comida para animais de estimação

PETINFO_INTIMATE pode ser usado com as seguintes constantes para verificar valores:
ANIMAL_INTIMO_NENHUM = 0
PET_ÍNTIMO_ESTRANHO = 1 ~ 99
TÍMIDO_INTIMADO_DE_ANIMAL_DE_ESTIMAÇÃO = 100 ~ 249
PET_ÍNTIMO_NEUTRO = 250 ~ 749
CORDIAL_ÍNTIMO_DE_ANIMAL_DE_ESTIMAÇÃO = 750 ~ 909
PET_ÍNTIMO_LEAL = 910 ~ 1000

PETINFO_HUNGRY pode ser usado com as seguintes constantes para verificar valores:
PET_FOME_NENHUM = 0
PET_FAMÍLIA_MUITA_FAMÍLIA = 1 ~ 10
PET_FOME_FOME = 11 ~ 25
PET_FOME_NEUTRO = 26 ~ 75
PET_FAMILIAR_SATISFEITO = 76 ~ 90
PET_FAMILIARES_RECHEADOS = 91 ~ 100

Exemplo:
	mes "[Veterinário]";
	mes "Seu animal de estimação + " getpetinfo(PETINFO_NAME);
	if (getpetinfo(PETINFO_INTIMATE) < PET_INTIMATE_LOYAL)
		mes "tem algo para crescer em você!";
	outro
		mes "parece te amar muito!";
	close;

---------------------------------------

=============================
|10.1.- Os comandos da IA ​​do Pet.|
=============================
---------------------------------------

Esses comandos só funcionarão se o personagem que os invoca tiver um animal de estimação e são destinados
para ser executado a partir de scripts de estimação. Eles modificarão a tomada de decisão da IA ​​do animal de estimação para
o animal de estimação atual do personagem invocador e NÃO terá nenhum independente
efeito por si mesmos, razão pela qual apenas um deles pode estar em vigor em qualquer momento
tempo para um pet específico. Um pet pode ter 'petloot', 'petskillbonus',
'petskillattack' OU 'petpetskillattack2' e 'petskillsupport'.

Todos os comandos com atrasos e durações só tornarão o comportamento ativo por
a duração especificada de segundos, com um atraso do número especificado de
segundos entre as ativações. As taxas são uma chance do efeito ocorrer e são
dado em porcentagem. 'bonusrate' é adicionado à taxa normal se a intimidade do animal de estimação for
no máximo possível.

O comportamento modificado com os comandos abaixo mencionados só será exibido se
o animal de estimação é leal e opções de configuração apropriadas são definidas em
'battle_athena.conf'.

Os scripts de animais de estimação no banco de dados normalmente são executados sempre que um animal de estimação desse tipo nasce
do ovo. Outros comandos utilizáveis ​​em scripts de itens (veja 'bônus') também
felizmente executado a partir de scripts de animais de estimação. Aparentemente, os comandos específicos para animais de estimação também
trabalhe em scripts de NPC e modifique o comportamento do animal de estimação atual até que o animal de estimação
é chocado novamente. (O que também ocorrerá quando o personagem for logado novamente
com o animal de estimação ainda fora do ovo.) Não se sabe ao certo por quanto tempo o efeito de
tal comando executado a partir de um script NPC eventualmente persistirá, mas aparentemente,
é possível empregá-los utilmente em scripts de itens utilizáveis ​​para criar animais de estimação
polindo itens.

Ninguém tentou isso antes, então você está basicamente sozinho aqui.

---------------------------------------

*petskillbonus <tipo de bônus>,<valor>,<duração>,<atraso>;

Este comando fará com que o animal de estimação dê um bônus ao atributo do dono em certos
duração em segundos e será repetido por um certo atraso em segundos.

Para uma lista completa de bônus, consulte 'doc/item_bonus.txt'
OBSERVAÇÃO: Atualmente, há suporte SOMENTE para bônus usados ​​pelo script 'bonus'.

---------------------------------------

*petrecovery <tipo de status>,<atraso>;

Este comando fará com que o pet cure uma condição de status especificada. A cura
as ações ocorrerão uma vez a cada Delay segundos. Para uma lista completa de status
condições que podem ser curadas, veja a lista de constantes de condição de status 'SC_'
em 'src/map/script_constants.hpp'.

---------------------------------------

*petloot <itens máximos>;

Este comando ativará o saque de animais de estimação, com um número máximo de itens para saquear
especificado. O animal de estimação armazenará os itens e os devolverá quando o máximo for atingido ou
quando o desempenho do animal de estimação é ativado.

---------------------------------------

*petskillsupport <id da habilidade>,<nível da habilidade>,<atraso>,<porcentagem hp>,<porcentagem sp>;
*petskillsupport "<nome da habilidade>",<nível da habilidade>,<atraso>,<porcentagem hp>,<porcentagem sp>;

Isso fará com que o animal de estimação use uma habilidade de suporte específica no dono sempre que o
HP e SP estão abaixo dos valores percentuais fornecidos, com um tempo de atraso especificado
entre ativações. Os números de habilidade são conforme 'db/(pre-)re/skill_db.yml'.

Não é bem certo quais estatísticas serão usadas para o elenco de habilidades,
personagem ou os animais de estimação. Provavelmente, Skotlex pode responder a essa pergunta.

---------------------------------------

*petskillattack <id da habilidade>,<nível da habilidade>,<taxa>,<taxa de bônus>;
*petskillattack "<nome da habilidade>",<nível da habilidade>,<taxa>,<taxa de bônus>;
*petskillattack2 <id da habilidade>,<dano>,<número de ataques>,<taxa>,<taxa de bônus>;
*petskillattack2 "<nome da habilidade>",<dano>,<número de ataques>,<taxa>,<taxa de bônus>;

Esses dois comandos farão com que o pet lance uma habilidade de ataque no inimigo do pet
o dono está lutando no momento. IDs de habilidade e níveis são como por 'petskillsupport'.
'petskillattack2' fará com que o pet lance a habilidade com uma quantidade fixa de dano
infligido e o número especificado de ataques.

O valor de 'rate' está entre 1 e 100. 100 = 100%

---------------------------------------

*petautobonus <script de bônus>,<taxa>,<duração>{,<sinalizador>,{<outro script>}};
*petautobonus2 <script de bônus>,<taxa>,<duração>{,<sinalizador>,{<outro script>}};
*petautobonus3 <script de bônus>,<taxa>,<duração>,<id da habilidade>,{<outro script>};
*petautobonus3 <script de bônus>,<taxa>,<duração>,"<nome da habilidade>",{<outro script>};

Veja 'autobonus' para mais detalhes.

---------------------------------------

===========================
|11.- Comandos do Homúnculo.|
===========================
---------------------------------------

*evolução doméstica;

Este comando tentará evoluir o homúnculo do jogador atual.
Se não funcionar, a emoção /swt será exibida.

Para evoluir um homúnculo, o jogador que invoca deve ter um homúnculo,
o homúnculo não deve ser a última evolução e
o homúnculo deve ter mais de 91000 de intimidade com seu dono.

---------------------------------------

*morfembrio;

Este comando tentará colocar o Homúnculo do jogador que o invoca em um
estado inominável, necessário para mutação em um Homúnculo S. O jogador
também receberá um Embrião Estranho (ID 6415) em seu inventário se
bem-sucedido, que é excluído após a mutação.

O comando falhará se o jogador que o invoca não tiver um evoluído
Homúnculo no nível 99 ou acima. A emoção /swt é mostrada em caso de falha.

Retorna 1 em caso de sucesso e 0 para todas as falhas.

---------------------------------------

*hommutate {<ID>};

Este comando tentará transformar o Homúnculo do jogador que o invoca em
um Homúnculo S. O Estranho Embrião (ID 6415) é excluído em caso de sucesso.

O comando falhará se o jogador que o invoca não tiver um evoluído
Homúnculo no nível 99 ou superior, se não estiver no estado embrionário
(do comando 'morphembryo'), ou se o jogador que invoca não
possui um Embrião Estranho. A emoção /swt é mostrada em caso de falha.

Se o parâmetro opcional <ID> for definido, o Homúnculo do jogador que invoca
mudará para o ID do Homúnculo especificado. Caso contrário, um Homúnculo S aleatório
será escolhido. Veja 'db/homunculus_db.txt' para uma lista completa de IDs.

Retorna 1 em caso de sucesso e 0 para todas as falhas.

---------------------------------------

*verificarchamadahom()

Esta função verifica se o Homúnculo do jogador anexado está ativo,
e retornará os seguintes valores:
-1: O jogador não tem Homúnculo.
  0: O Homúnculo do jogador está ativo.
  1: O Homúnculo do jogador é vaporizado.
  2: O Homúnculo do jogador está em estado de metamorfose.

---------------------------------------

*gethominfo(<tipo>{,<id_char>})

Esta função retornará informações do Homúnculo para o Homúnculo do
invocando o personagem, independentemente do seu estado de vaporização. Ele retorna zero ou
"nulo" se o jogador não possuir um Homúnculo.

Os tipos válidos são:
0 - ID do Homúnculo
1 - Classe Homúnculo
2 - Nome do Homúnculo
3 - Nível de amizade com o homúnculo (pontuação de intimidade). 100000 é lealdade total.
4 - Nível de fome do homúnculo. 100 é completamente cheio.
5 - Sinalizador de renomeação de homúnculo. 0 significa que este homúnculo ainda não foi nomeado.
6 - Nível Homúnculo
7 - ID do jogo Homunculus

---------------------------------------

*homshuffle;

Isso irá recalcular as estatísticas do homúnculo de acordo com seu nível, do
caractere de invocação atual.

---------------------------------------

*addhomintimacy <quantidade>{,<char_id>};

Aumenta ou diminui o valor de intimidade de um homúnculo em um determinado <valor>. 100000 é lealdade total.
Falha silenciosamente quando não há jogadores anexados ou se o jogador não tem homúnculo.

---------------------------------------

==========================
|12.- Comandos mercenários.|
==========================
---------------------------------------

*mercenary_create <classe>,<tempo do contrato>;

Este comando invoca um mercenário por um tempo determinado (em milissegundos). Para um
lista de todas as classes disponíveis, veja 'db/mercenary_db.txt'.

Este comando é normalmente usado em scripts de itens de pergaminhos mercenários.

---------------------------------------

*mercenary_delete {<id do caractere>{,<resposta>}};

Este comando remove o mercenário de um jogador.
O parâmetro 'responder' pode ser um dos seguintes valores:

	0 - O horário de serviço do soldado mercenário acabou, a fé aumentou em 1. (padrão)
	1 - Seu soldado mercenário foi morto, fé reduzida em 1.
	2 - Seu soldado mercenário foi demitido.
	3 - Seu soldado mercenário fugiu.

---------------------------------------

*mercenary_heal <hp>,<sp>;

Este comando funciona como 'curar', mas afeta o mercenário do
personagem atualmente anexado.

---------------------------------------

*mercenary_sc_start <tipo>,<tique>,<val1>;

Este comando funciona como 'sc_start', mas afeta o mercenário do
personagem atualmente anexado.

---------------------------------------

*mercenary_get_calls(<guilda>);
*mercenary_set_calls <guilda>,<valor>;

Define ou obtém o valor das chamadas de mercenários para a guilda fornecida no momento
personagem anexado. Guild pode ser uma ou as seguintes constantes:

	GUILDA_ARQUI_MERC
	LANÇA_MERC_GUILD
	GUILDA_DE_MERCADOS_DA_ESPADA

---------------------------------------

*mercenary_get_faith(<guilda>);
*mercenary_set_faith <guilda>,<valor>;

Define ou obtém o valor da fé mercenária para a guilda fornecida no momento
personagem anexado. Guild pode ser uma ou as seguintes constantes:

	GUILDA_ARQUI_MERC
	LANÇA_MERC_GUILD
	GUILDA_DE_MERCADOS_DA_ESPADA

---------------------------------------

*getmercinfo(<tipo>{,<id do caractere>});

Recupera informações sobre o mercenário do atualmente anexado
personagem. Se char id for fornecido, as informações desse personagem são
recuperado em vez disso. O tipo especifica quais informações recuperar e
pode ser um dos seguintes:

	0 - ID do Mercenário
	1 - Classe Mercenária
	2 - Nome Mercenário
	3 - Valor de fé mercenária para esta guilda de mercenários, se houver
	4 - O mercenário chama o valor da guilda deste mercenário, se houver
	5 - Contagem de mortes de mercenários
	6 - Tempo de vida restante do mercenário em mseg
	7 - Nível mercenário
	8 - ID do jogo Mercenário

Se o personagem não tiver um mercenário, o comando retornará ""
para nome e 0 para todos os outros tipos.

---------------------------------------

======================
|13.- Comandos do partido.|
======================
---------------------------------------

*getpartyname(<id da parte>)

Esta função retornará o nome de uma parte que possui o número de ID especificado.
Se não houver esse ID de parte, "null" será retornado.

Digamos que o ID de uma parte foi salvo como uma variável global:

	// Isso retornaria o nome da parte do ID armazenado em uma variável
	mes "Você está na festa '" + getpartyname($@var) + "', eu sei!";

---------------------------------------

*getpartymember <id da parte>{,<tipo>{,<variável_de_matriz>}};

Este comando encontrará todos os membros de um grupo especificado e retornará seus nomes
(ou id do personagem ou id da conta dependendo do valor de "tipo") em uma matriz
de variáveis ​​globais temporárias. Na verdade, existem alguns comandos como este
que preencherá uma variável especial com dados durante a execução e não fará nada
outro.

Ao executar isso,

$@partymembername$[] é uma matriz de string temporária global que contém todos os
                     nomes desses membros do partido
                     (definido somente quando o tipo é 0 ou não especificado)

$@partymembercid[] é uma matriz numérica temporária global que contém o
                     ID do personagem desses membros do grupo.
                     (definido somente quando o tipo é 1)

$@partymemberaid[] é uma matriz numérica temporária global que contém o
                     ID da conta desses membros do grupo.
                     (definido somente quando o tipo é 2)

$@partymembercount é o número de membros do grupo que foram encontrados.

Os membros do partido serão (aparentemente) encontrados independentemente de serem
online ou offline. Note que os nomes não vêm em nenhuma ordem específica.

Certifique-se de usar $@partymembercount para percorrer esta matriz, e não
'getarraysize', porque não é limpo entre as execuções de 'getpartymember'. Se
alguém com 7 membros do grupo invoca este script, a matriz teria 7
elementos. Mas se outra pessoa chamar o NPC, e ele tiver um grupo de 5, o
o servidor não limpará a matriz para você, substituindo os valores. Então, em
além de retornar os nomes dos 5 membros, o 6º e o 7º elementos do último
ligue para permanecer, e você obterá 5+2 membros, dos quais os 2 últimos não pertencem a
a festa do novato. $@partymembercount sempre conterá o número correto,
(5) diferente de 'getarraysize()' que retornará 7 neste caso.

Se 'array_variable' for definido, o resultado será armazenado nessa variável
usando variável global.

Exemplo 1: listar nomes dos membros do grupo

	// obtém os nomes dos membros do grupo
	obter membro do grupo obter charid(1),0;

	// É uma boa ideia copiar o temporário global $@partymember*****
	// variáveis ​​para suas próprias variáveis ​​de escopo porque se você tiver pausas neste
	// script (sleep, sleep2, next, close2, entrada, menu, selecionar ou prompt),
	// outro jogador pode clicar neste NPC, acionar 'getpartymember' e
	// sobrescreve as variáveis ​​$@partymember*****.
	.@contagem = $@contagem de membros do partido;
	copyarray .@nome$[0], $@nomemembrodopartido$[0], $@contagemmembrodopartido;

	// lista os nomes dos membros do grupo
	para (.@i = 0; .@i < .@count; .@i++)
		mes (.@i +1) + ". ^0000FF" + .@name$[.@i] + "^000000";
	close;


Exemplo 2: verificar a contagem do grupo (com uma pausa 'próximo'), antes de passar para o evento

	.register_num = 5; // Quantos membros do grupo são necessários?

	// obtém o charID e o accountID dos membros do grupo do personagem
	obtermembro do grupo obtercharid(1), 1;
	obtermembro do grupo obtercharid(1), 2;

	if ($@partymembercount! = .register_num) {
		mes "Por favor, forme um grupo de " + .register_num + " para continuar";
		close;
	}

	// faça um loop em ambos e use 'isloggedin' para contar os membros do grupo online
	para ( .@i = 0; .@i < $@partymembercount; .@i++ )
		if ( está logado em ($@partymemberaid[.@i], $@partymembercid[.@i] ) )
			.@contagem_online++;

	// Pesquisamos accountID e charID porque uma única parte pode ter vários
	// caracteres da mesma conta. Sem procurar pelo charID,
	// se um jogador tiver 2 personagens da mesma conta dentro do grupo, mas
	// apenas 1 caractere online, o caractere online seria contado duas vezes.

	if ( .@count_online != .register_num ) {
		mes "Todos os membros do seu grupo devem estar online para continuar";
		close;
	}

	// copie o array para evitar que os jogadores trapaceiem no sistema
	copyarray .@partymembercid, $@partymembercid, .register_num;

	mes "Você está pronto?";
	next; // cuidado aqui
	select("Sim");

	// Quando um script atinge um próximo, menu, suspensão ou entrada que pausa o script,
	// os jogadores podem convidar ou /sair e fazer mudanças em seu grupo. Para evitar
	// isso, chamamos getpartymember novamente e comparamos com os valores originais.

	obtermembro do grupo obtercharid(1), 1;
	if ($@partymembercount! = .register_num) {
		mes "Você fez mudanças no seu grupo!";
		close;
	}
	para ( .@i = 0; .@i < $@partymembercount; .@i++ ) {
		if ( .@partymembercid[.@i] != $@partymembercid[.@i] ) {
			mes "Você fez mudanças no seu grupo!";
			close;
		}
	}

	// Finalmente, é seguro começar o evento!
	warpparty "mapa_de_eventos", 0,0, getcharid(1);

---------------------------------------

*getpartyleader(<id da parte>{,<tipo>})

Esta função retorna algumas informações sobre o líder do party-id fornecido.
Quando o tipo é omitido, a informação padrão recuperada é o nome do líder.
Os tipos possíveis são:

	1: ID da conta do líder
	2: Id do personagem líder
	3: Classe do líder
	4: Nome atual do líder no mapa
	5: Nível atual do líder conforme armazenado na estrutura do grupo (pode não ser
	   nível atual se o líder subiu de nível recentemente).

Se a recuperação falhar (líder não encontrado ou grupo não existir), esta função
retorna "null" em vez do nome do caractere e -1 para os outros tipos.

---------------------------------------

*is_party_leader({<ID do partido>})

Este comando retornará verdadeiro se o jogador anexado ao script for o líder
do seu partido ou, se for especificado um ID de partido, desse partido.

---------------------------------------

*party_create("<nome da festa>"{,<id do personagem>{,<compartilhamento do item>,<tipo de compartilhamento do item>}});

Organiza uma party com o personagem anexado ou especificado como líder. Se
bem-sucedido, o comando retorna 1 e define a variável temporária global
"$@party_create_id" para o ID da festa criada.

Além disso, opções de compartilhamento de itens podem ser fornecidas:
- Compartilhamento de itens: 0-Cada tomada (padrão), 1-Compartilhamento de grupo
- Tipo de compartilhamento de itens: 0-Cada tomada (padrão), 1-Compartilhamento uniforme

Esses valores são retornados em caso de falha:
0: Erro desconhecido.
-1: Jogador não encontrado.
-2: O jogador já tem um grupo.
-3: O nome da parte existe.

---------------------------------------

*party_destroy(<id da parte>);

Dissolve um grupo. O comando retorna 1 em caso de sucesso e 0 em caso de falha.

---------------------------------------

*party_addmember(<id do grupo>,<id do personagem>);

Adiciona um jogador a um grupo existente.

O comando retorna 1 em caso de sucesso e estes valores em caso de falha:
0: Erro desconhecido.
-1: Jogador não encontrado.
-2: O jogador já tem um grupo.
-3: Parte não encontrada.
-4: A festa está cheia.
-5: Outro personagem da mesma conta já está no grupo.

---------------------------------------

*party_delmember({<id do personagem>,<id do grupo>});

Remove um jogador de seu grupo. Se nenhum jogador for especificado, o comando
será executado para o jogador que invoca. Se esse jogador for o único membro do grupo
restantes, o partido será dissolvido.

O comando retorna 1 em caso de sucesso e estes valores em caso de falha:
0: Erro desconhecido.
-1: Jogador não encontrado.
-2: Parte não encontrada.
-3: O jogador não está no grupo.

---------------------------------------

*party_changeleader(<id do grupo>,<id do personagem>);

Transfere a liderança de um grupo para o personagem especificado.

O comando retorna 1 em caso de sucesso e estes valores em caso de falha:
0: Erro desconhecido.
-1: Parte não encontrada.
-2: Jogador não encontrado.
-3: O jogador não está no grupo.
-4: O jogador já é o líder do grupo.

---------------------------------------

*party_changeoption(<id da parte>,<opção>,<sinalizador>);

Altera uma opção de grupo.

As opções válidas são:
0 - Exp Share (sinalizadores: 0-Cada Take, 1-Even Share)
1 - Compartilhamento de itens (sinalizadores: 0-Cada tomada, 1-Compartilhamento de grupo)
2 - Tipo de compartilhamento de itens (sinalizadores: 0-Cada tomada, 1-Compartilhamento uniforme)

O comando retorna 1 em caso de sucesso e estes valores em caso de falha:
0: Opção inválida.
-1: Parte não encontrada.

---------------------------------------

*opendressroom(<flag>{,<char_id>});

Isso abrirá a janela Dress Room no cliente conectado ao personagem invocador.

	mes "Feche esta janela para abrir a janela do Dress Room.";
	close2;
	opendressroom(1);
	end;

As bandeiras válidas são:
1 - Abra a janela do Dress Room

---------------------------------------

*navigateto("<mapa>"{,<x>,<y>,<bandeira>,<ocultar_janela>,<id_monstro>,<id_caractere>});

Gera uma navegação para o caractere anexado ou especificado. Requer cliente
2011-10-10aRagEXE ou mais recente.

O sinalizador especifica como o cliente calculará a rota específica.

As bandeiras válidas são:
NAV_NONE - Nenhum serviço
NAV_AIRSHIP_ONLY - Apenas dirigível
NAV_SCROLL_ONLY - Rolar somente
NAV_AIRSHIP_AND_SCROLL - Dirigível e rolagem
NAV_KAFRA_ONLY - Somente Kafra
NAV_KAFRA_AND_AIRSHIP - Kafra e dirigível
NAV_KAFRA_AND_SCROLL - Kafra e pergaminho
NAV_ALL - Todos os serviços

Quando o sinalizador não é especificado, o valor padrão é NAV_KAFRA_AND_AIRSHIP.

hide_window especifica se deve exibir (0) ou ocultar (1) a janela de navegação.
Por padrão, a janela fica oculta.

Você pode especificar o monster_id em combinação com um mapname para fazer o
o sistema de navegação informa que você chegou ao local desejado.

Observação:
O cliente requer que os spawns de monstros personalizados estejam no arquivo de navegação
para usar o recurso de navegação do cliente incorporado para funcionar corretamente. Neste
por exemplo, enviar o jogador para o mapa onde o monstro aparece é uma maneira mais simples
solução em vez de enviar o mapa e o monster_id.

---------------------------------------

*hateffect(<ID do efeito do chapéu>,<Estado>);

Isso setá um Efeito de Chapéu no jogador. O campo de estado permite que você
habilitar (true) ou desabilitar (false) o efeito no player.
As constantes do efeito Hat podem ser encontradas em 'src/map/script_constants.hpp' começando
com HAT_EF_*.

Requer o cliente 2015-05-13aRagEXE ou mais recente.

---------------------------------------

*getrandomoptinfo(<tipo>);

Retorna o valor de um atributo da opção aleatória atual.

Os atributos válidos são:
ROA_ID - ID da opção atual
ROA_VALUE - Campo de valor da opção atual
ROA_PARAM - Campo de parâmetro da opção atual

Este comando de script é destinado ao uso em scripts de opções aleatórias.

---------------------------------------

*getequiprandomoption(<índice do equipamento>,<índice>,<tipo>{,<id do caractere>});

Retorna o valor de um atributo de uma opção aleatória em um item equipado.

Veja 'getequipid' para uma lista completa de slots de equipamentos válidos.

o parâmetro index pode ser de 0 a MAX_ITEM_RDM_OPT-1 (padrão 0-4).

Para tipos de atributos válidos, consulte a referência do comando `getrandomoptinfo`.

---------------------------------------

*setrandomoption(<slot de equipamento>,<índice>,<id>,<valor>,<parâmetro>{,<id do caractere>});

Define <index+1>ª opção aleatória para equipamento equipado em <slot de equipamento>
para <id>, <valor> e <parâmetro>.

Veja 'getequipid' para uma lista completa de slots de equipamentos válidos.

o parâmetro index pode ser de 0 a MAX_ITEM_RDM_OPT-1 (padrão 0-4).

ID - ID da opção aleatória. Veja db/item_randomopt_db.yml para constantes.
Valor - Valor da opção aleatória
Param - Parâmetro de opção aleatória

---------------------------------------

*randomoptgroup <ID do grupo de opções aleatórias>;

Este comando preenche as seguintes matrizes com os resultados de um grupo de opções aleatório.
Os IDs do grupo de opções aleatórias são especificados em 'db/(pre-)re/item_randomopt_group.yml'.

Matrizes - do índice 0 a MAX_ITEM_RDM_OPT-1:
.@opt_id[] - matriz de ID de opção aleatória.
.@opt_value[] - matriz de valores.
.@opt_param[] - matriz de parâmetros.

Exemplo:
	// Preencha as matrizes usando o ID do grupo de opções aleatórias 5 (grupo usado para armas Crimson).
	grupoopt aleatório(5);

	// Cria uma Adaga Carmesim +9 [2] com o Grupo 5 aplicado
	getitem3 28705,1,1,9,0,0,0,0,0,.@opt_id,.@opt_value,.@opt_param;

---------------------------------------

*clan_join(<id do clã>{,<id do caractere>});

O jogador anexado se junta ao clã com o <clan id>. Em uma junção bem-sucedida,
true é retornado, caso contrário false se a junção falhou.
Se <char id> for especificado, o jogador especificado será usado em vez do anexado.

---------------------------------------

*clan_leave({<id do caractere>});

O jogador anexado deixará seu clã. Em uma saída bem-sucedida, true é retornado,
caso contrário, será falso se a licença falhou.
Se <char id> for especificado, o jogador especificado será usado em vez do anexado.

---------------------------------------

*itemlink(<item_id>{,<refinar>{,<cartão0>{,<cartão1>{,<cartão2>{,<cartão3>,{<enchantgrade>{,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>}}}}}}});

Gera uma string de link de item para um item que pode ser usado para npctalk, mensagem,
dispbottom e comandos de transmissão. O resultado é um nome de item clicável apenas
como SHIFT+Clique na janela de inventário/carrinho/equipamento de um jogador. Este comando pode ser
usado comigo, mas o nome do item não será clicável. Você deve usar o comando script
"mesitemlink" para exibir links de itens em diálogos do mes, se o cliente os suportar.


Exemplos:

	npctalk "Faca [3] : "+itemlink(1201)+"";
	npctalk "+16 Faca [3] : "+itemlink(1201,16)+"";
	npctalk "+13 BXB Bapho+VR+EA2+EA1 : "+itemlink(18110,13,4147,4407,4833,4832)+"";
	setarray .@opt_ids[0],RDMOPT_VAR_ATKPERCENT,RDMOPT_VAR_ATKPERCENT,RDMOPT_VAR_ATTMPOWER,0,0;
	setarray .@opt_values[0],3,5,20,0,0;
	setarray .@opt_params[0],0,0,0,0,0;
	npctalk "+13 BXB Bapho+VR+EA2+EA1 + 3 Opções: "+itemlink(18110,13,4147,4407,4833,4832,0,.@opt_ids,.@opt_values,.@opt_params)+"";


RandomIDArray, RandomValueArray e RandomParamArray só funcionam se o
cliente (e servidor) suporta o recurso Opções aleatórias de itens (PACKETVER >= 20150225).

---------------------------------------

*mesitemlink(<item_id>{,<usar_colchetes>{,<nome_de_exibição>});

Gera uma string de link de item para um item e pode ser usada com o comando mes do NPC.
A mensagem do NPC mostrará o nome do item que poderá ser clicado e abrirá o
descrição do item do lado do cliente.
Por padrão, <use_brackets> é true, que envolve o link com colchetes. Envie false para desabilitar.
Por padrão, o link será criado com o nome do item armazenado no banco de dados de itens,
mas em alguns casos pode ser necessário substituir o <display_name> por outra coisa.

Exemplos:

	mes mesitemlink( 1201 ); // Irá exibir "[Knife]" e será clicável. Se clicado, abre a descrição para Knife [3]
	mes "Traga-me um " + mesitemlink( 1201 ) + "."; // Exibirá "Traga-me uma [Faca]." e "[Faca]" será clicável.
	mes "Traga-me uma " + mesitemlink( 1201, false ) + "."; // Exibirá "Traga-me uma faca." e "Faca" será clicável.
	mes "Traga-me uma " + mesitemlink( 1201, true, "Super faca de corte" ) + "."; // Exibirá "Traga-me uma [Super faca de corte]." e "[Super faca de corte]" será clicável.

========================
|14.- Comandos de canal.|
========================
---------------------------------------

*channel_create "<chname>","<alias>"{,"<senha>"{<opção>{,<atraso>{,<cor>{,<char_id>}}}}};

Cria um canal público com <chname> como nome do canal. Para proteger o
canal, use <senha> ou escreva "null" para criá-lo sem uma senha.
O nome do canal deve começar com '#' e não pode ser o mesmo do mapa ou aliado
nomes de canais.

<alias> será usado para alterar o nome do canal quando a mensagem do canal
é exibido.

Os valores de <option> são:
	CHAN_OPT_BASE - Opção padrão incluindo CHAN_OPT_ANNOUNCE_SELF|CHAN_OPT_MSG_DELAY|CHAN_OPT_CAN_CHAT|CHAN_OPT_CAN_LEAVE
	CHAN_OPT_ANNOUNCE_SELF - Mostrar informações do próprio jogador se ele entrou/saiu do canal
	CHAN_OPT_ANNOUNCE_JOIN - Exibir mensagem quando o jogador estiver entrando no canal
	CHAN_OPT_ANNOUNCE_LEAVE - Exibir mensagem quando o jogador estiver saindo do canal
	CHAN_OPT_MSG_DELAY - Habilita atraso de chat para o canal
	CHAN_OPT_COLOR_OVERRIDE - A cor da fonte exclusiva do jogador substituirá a cor do canal
	CHAN_OPT_CAN_CHAT - O jogador pode conversar no canal
	CHAN_OPT_CAN_LEAVE - O jogador pode sair do canal
	CHAN_OPT_AUTOJOIN - Os jogadores entrarão automaticamente no canal no login

O <atraso> é o atraso mínimo do bate-papo em milissegundos para um único jogador antes
o jogador pode conversar novamente no mesmo canal.

Use o código hexadecimal <cor> para set a cor deste canal, se não for definido, padrão
a cor do canal será usada.

Se <char_id> for definido, o canal será um canal privado e o player
será o proprietário do canal.

Retorna 1 em caso de sucesso.

	/**
	 * Este exemplo mostrará a mensagem neste canal como
	 * [brHades] Admin: Olá, mundo!
	 * em vez de
	 * #brHades Admin: Olá, mundo!
	 **/
	channel_create("#brHades","[brHades]");
	channel_create("#vip","[VIP]","somente membros vip");

---------------------------------------

*channel_join "<nome_do_canal>"{, <id_do_caractere>};

Entre em um canal existente.
O comando retorna 0 em caso de sucesso e estes valores em caso de falha:
-1: Canal ou player inválido
-2: Jogador já no canal
-3 : Jogador banido
-4: Limite máximo atingido

---------------------------------------

*channel_setopt "<chname>",<opção>,<valor>;

Defina a opção para o canal. Use 1 em <valor> para defini-lo, ou 0 para desdefini-lo.
Os valores de <option> são os mesmos que as opções 'channel_create'.

Para CHAN_OPT_MSG_DELAY, o atraso em milissegundos deve ser enviado ou usar 0
para remover o atraso em <valor>.

Retorna 1 em caso de sucesso.

	// Exemplo para set atraso
	channel_setopt("#global",CHAN_OPT_MSG_DELAY,5000);

Somente para canais públicos e privados.

---------------------------------------

*channel_getopt "<chname>",<opção>;

Obter valor de opção para o canal. Os valores <option> são os mesmos que os
Opções 'channel_create'. Retorna verdadeiro ou falso, exceto para CHAN_OPT_MSG_DELAY
que retorna um inteiro.

	// Exemplo para obter o atraso
	.delay = channel_getopt("#global",CHAN_OPT_MSG_DELAY);

Somente para canais públicos e privados.

---------------------------------------

*channel_setcolor "<nome do canal>",<cor>;

Para alterar a cor do canal.
<color> usa valores RGB hexadecimais.

Retorna 1 em caso de sucesso.

---------------------------------------

*channel_setpass "<chname>","<senha>";

Para set, remover ou alterar a senha de um canal.
Use "null" para remover a senha.

Retorna 1 em caso de sucesso.
Somente para canais públicos e privados.

---------------------------------------

*channel_setgroup "<nome_do_canal>",<id_do_grupo>{,...,<id_do_grupo>};
*channel_setgroup2 "<chname>",<matriz_de_grupos>;

Defina a restrição de grupo para um canal. Somente player com <group_id> correspondente
estão autorizados a entrar no canal.

Ao utilizar 0 no primeiro canal de grupo, a restrição de grupo será
removido da configuração do canal.

'channel_setgroup2' recebe entrada para lista de grupos como uma matriz.

Retorna 0 em caso de falha e 1 (ou n grupos contam) em caso de sucesso.

	// Exemplo 1: Remover grupos
	channel_setgroup("#evento",0);

	// Exemplo 2: Vários valores
	channel_setgroup("#vip",2,5);

	// Exemplo 3: Usando array
	setarray .@staffs[0],2,3,4,10,99;
	channel_setgroup("#equipe",.@equipes);

Somente para canais públicos e privados.

---------------------------------------

*channel_chat "<chname>","<mensagem>"{,<cor>};

Envia mensagem para o canal.
Retorna 1 em caso de sucesso.

	// Exemplo se o canal não tiver alias
	channel_chat(#brHades,"Olá, mundo!"); // #brHades Olá, mundo!

	// Exemplo se o canal tiver alias
	channel_chat(#brHades,"Olá Mundo!"); // [brHades] Olá Mundo!

---------------------------------------

*channel_ban "<nome_do_canal>",<id_do_caractere>;

Banir jogador de um canal público ou privado.
O proprietário do canal ou grupo com PC_PERM_CHANNEL_ADMIN não pode ser banido.
Retorna 1 em caso de sucesso.

---------------------------------------

*channel_unban "<chname>",<char_id>;

Desbanir um jogador de um canal público ou privado.
Retorna 1 em caso de sucesso.

---------------------------------------

*channel_kick "<nome_do_canal>",<id_do_caractere>;
*channel_kick "<nome_do_canal>","<nome_do_caractere>";

Expulsar jogador de um canal público ou privado.
O proprietário do canal ou grupo com PC_PERM_CHANNEL_ADMIN não pode ser expulso.
Retorna 1 em caso de sucesso.

---------------------------------------

*channel_delete "<nome do canal>";

Exclua um canal público ou privado existente. Não é possível excluir aliado ou
canal de mapa local.
Retorna 0 em caso de sucesso.

---------------------------------------

============================
|15.- Comandos de realização.|
============================
---------------------------------------

*achievementadd(<id da conquista>{,<id do caractere>})

Esta função adicionará uma conquista ao registro do jogador para o anexo
player ou o <char id> fornecido. Os requisitos objetivos não são ignorados
ao usar esta função.
Retorna verdadeiro em caso de sucesso e falso em caso de falha.

---------------------------------------

*achievementremove(<id da conquista>{,<id do caractere>})

Esta função removerá uma conquista do registro do jogador para o anexo
player ou o <char id> fornecido.
Retorna verdadeiro em caso de sucesso e falso em caso de falha.

---------------------------------------

*achievementinfo(<id da conquista>,<tipo>{,<id do caractere>})

Esta função retornará o valor <tipo> especificado para uma conquista do
player anexado ou o <char id> fornecido. Se o player não tiver o
conquista ativa (nenhum progresso foi feito): se a conquista não
exist -1 será retornado, ou -2 será retornado em qualquer outro erro, como
um <tipo> inválido.

Tipos válidos:
- ACHIEVEINFO_COUNT1
- ACHIEVEINFO_COUNT2
- ACHIEVEINFO_COUNT3
- ACHIEVEINFO_COUNT4
- ACHIEVEINFO_COUNT5
- ACHIEVEINFO_COUNT6
- ACHIEVEINFO_COUNT7
- ACHIEVEINFO_COUNT8
- ACHIEVEINFO_COUNT9
- ACHIEVEINFO_COUNT10
- ACHIEVEINFO_COMPLETO
- ACHIEVEINFO_COMPLETEDATE
- ACHIEVEINFO_GOTREWARD
- ACHIEVEINFO_LEVEL (<id da conquista> é inútil para isso)
- ACHIEVEINFO_SCORE (<id da conquista> é inútil para isso)

---------------------------------------

*achievementcomplete(<id da conquista>{,<id do caractere>})

Esta função completará uma conquista para o jogador anexado ou fornecido
<char id>. Os requisitos objetivos são ignorados ao usar esta função.
Retorna verdadeiro em caso de sucesso e falso em caso de falha.

---------------------------------------

*achievementexists(<id da conquista>{,<id do caractere>});

Esta função retornará se a conquista existir no jogador ou no fornecido
<char id> e está concluído.
Retorna verdadeiro em caso de sucesso e falso em caso de falha.

---------------------------------------

*achievementupdate(<id da conquista>,<tipo>,<valor>{,<id do caractere>})

Esta função atualizará o valor de uma conquista para uma conquista do anexo
jogador ou o <char id> fornecido. Se o jogador não tiver a conquista ativa
(nenhum progresso foi feito) será adicionado ao log do jogador antes de atualizar
o valor <tipo>.
Retorna verdadeiro em caso de sucesso e falso em caso de falha.

Veja 'achievementinfo' para valores <type> válidos.
- ACHIEVEINFO_COMPLETE, ACHIEVEINFO_COMPLETEDATE e ACHIEVEINFO_GOTREWARD requerem o
  valor específico retornado de 'gettimetick(2)'.
- Exclui ACHIEVEINFO_LEVEL e ACHIEVEINFO_SCORE.

---------------------------------------

*addfame(<quantidade>,{,<id do caractere>})

Aumenta a fama do jogador anexado ou do <id do personagem> fornecido pela <quantidade> fornecida.
Observação: funciona somente com classes que usam o sistema de classificação.

---------------------------------------

*getfame({<id do caractere>})

Obtém os pontos de fama do jogador anexado ou do <id do personagem> fornecido.
Observação: funciona somente com classes que usam o sistema de classificação.

---------------------------------------

*getfamerank({<id do caractere>})

Retorna a classificação de fama (começa de 1 a MAX_FAME_LIST), caso contrário 0.
Observação: funciona somente com classes que usam o sistema de classificação.

---------------------------------------

*isdead({<id da conta>})

Retorna verdadeiro se o jogador estiver morto, caso contrário, retorna falso.

---------------------------------------

*has_autoloot({<id_char>});

Este comando verifica se um jogador configurou o autoloot.
Retorna o valor atual do autoloot em caso de sucesso.

---------------------------------------

*autoloot({<taxa>{, <id_char>}});

Este comando define a taxa de autoloot.
Se nenhuma taxa for fornecida e o usuário tiver o autoloot desabilitado, o padrão será 10000 = 100% (habilitado) ou
se o usuário tiver o autoloot habilitado, o padrão será 0 = 0% (desabilitado).
Retorna verdadeiro em caso de sucesso e falso em caso de falha.

Exemplo:
    autoloot(); // alternar entre ligado/desligado dependendo do autoloot existente
    autoloot(0); // 0,00% ou desconto
    autoloot(100); // 1,00%
    autoloot(3333); // 33,33%
    autoloot(10000); // 100,00%

---------------------------------------

*setdialogalign(<alinhar>);

Defina o alinhamento vertical ou horizontal no diálogo do NPC.
Alinhamentos válidos:
- alinhamento horizontal:
  DIÁLOGO_ALINHAMENTO_ESQUERDA
  CENTRO_DE_ALINHAMENTO_DE_DIÁLOGO
  DIÁLOGO_ALINHAMENTO_DIREITO

- alinhamento vertical:
  DIÁLOGO_ALINHAR_TOPO
  DIÁLOGO_ALINHAMENTO_MEIO
  DIÁLOGO_ALINHAMENTO_INFERIOR

---------------------------------------

*setdialogsize(<largura>, <altura>)

Defina o tamanho do diálogo do NPC em pixels.

---------------------------------------

*setdialogpos(<x>, <y>)

Defina a posição do diálogo do NPC em pixels.

---------------------------------------

*setdialogpospercent(<x>, <y>)

Defina a posição do diálogo do NPC em porcentagem do tamanho da tela.

---------------------------------------

*force_memo("<nome do mapa>", <x>, <y>, <memoslot>)

Forçar o slot de memorando a lembrar de um mapa sem estar no mapa. (usado em missões de memorando AL_WARP)

---------------------------------------

